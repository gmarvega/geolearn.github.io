import { watch as ae, unref as ee, onScopeDispose as Oe, ref as B, readonly as Ae, reactive as Q, inject as Be, defineComponent as fe, toRefs as pe, computed as z, nextTick as Z, openBlock as R, createElementBlock as M, mergeProps as ne, createElementVNode as q, normalizeStyle as le, Fragment as Re, renderList as ze, normalizeClass as he, watchEffect as He, createCommentVNode as G, renderSlot as se, onMounted as xe, resolveComponent as we, createBlock as oe, Teleport as Xe, Transition as ye, withCtx as de, normalizeProps as me, guardReactiveProps as be, toDisplayString as re } from "vue";
const Ee = ["top", "left", "right", "bottom"], Ye = ["start", "center", "end"], ke = {
  allowInteraction: {
    type: Boolean,
    default: !0
  }
}, Te = {
  arrow: {
    type: Boolean,
    default: !0
  },
  offset: {
    type: Number,
    default: 0
  },
  position: {
    type: String,
    default: "bottom",
    validator: function(e) {
      return Ee.indexOf(e) !== -1;
    }
  },
  placement: {
    type: String,
    default: "start",
    validator: function(e) {
      return Ye.indexOf(e) !== -1;
    }
  },
  autoAdjust: {
    type: Boolean,
    default: !0
  },
  width: {
    type: [String, Number],
    default: 250
  }
}, Ie = {
  steps: {
    type: Array,
    required: !0,
    default: () => []
  },
  stepIndex: {
    type: Number,
    default: -1
  },
  padding: {
    type: Number,
    default: 0
  },
  useOverlay: {
    type: Boolean,
    default: !0
  },
  pagination: {
    type: Boolean,
    default: !0
  },
  closeBtn: {
    type: Boolean,
    default: !0
  },
  allowKeyboardEvent: {
    type: Boolean,
    default: !0
  },
  allowOverlayClose: {
    type: Boolean,
    default: !0
  },
  allowEscClose: {
    type: Boolean,
    default: !0
  },
  name: {
    type: String,
    default: void 0
  },
  ...Te,
  ...ke
}, je = {
  rect: {
    type: Object
  },
  ...ke
}, Ve = {
  rect: {
    type: Object
  },
  ...Te
};
function J(e, t, o, u) {
  let i;
  const v = () => {
    i && (i.removeEventListener(
      t,
      o,
      u
    ), i = void 0);
  }, r = ae(
    () => ee(e),
    (m) => {
      v(), m && (i = m, m.addEventListener(t, o, u));
    },
    { immediate: !0, flush: "post" }
  ), s = () => {
    r(), v();
  };
  return Oe(s), s;
}
function Fe(e) {
  const t = B(!1), o = B([]), u = (r) => {
    if (!(!t.value || !ee(e) || !(r.key === "Tab")))
      if (o.value.length === 0)
        r.preventDefault();
      else {
        const m = o.value[0], p = o.value[o.value.length - 1];
        r.shiftKey ? document.activeElement === m && (p.focus(), r.preventDefault()) : document.activeElement === p && (m.focus(), r.preventDefault());
      }
  }, i = () => {
    const r = ee(e);
    r && (t.value = !0, o.value = Le(r), o.value.length > 0 && o.value[0].focus());
  }, v = () => {
    t.value = !1;
  };
  return J(e, "keydown", u), { active: Ae(t), enableTrap: i, disableTrap: v };
}
function Le(e) {
  const t = "button, [href], input, select, textarea, [tabindex]";
  return [...e.querySelectorAll(t)].filter((u) => {
    const i = u.getAttribute("tabindex");
    if (i && parseInt(i, 10) < 0 || u.getAttribute("disabled"))
      return !1;
    let v = u;
    for (; v; ) {
      if (getComputedStyle(v).display === "none" || getComputedStyle(v).visibility === "hidden")
        return !1;
      v = v.parentElement;
    }
    return !0;
  });
}
function _e(e, t, o = {}) {
  let u;
  const i = () => {
    u && (u.disconnect(), u = void 0);
  }, v = ae(
    () => ee(e),
    (s) => {
      i(), s && (u = new window.ResizeObserver(t), u.observe(s, o));
    },
    { immediate: !0, flush: "post" }
  ), r = () => {
    v(), i();
  };
  return Oe(r), r;
}
const Se = (e, t = 0) => ({
  top: e.top - t,
  right: e.right + t,
  bottom: e.bottom + t,
  left: e.left - t,
  width: e.width + t * 2,
  height: e.height + t * 2
}), Me = ({
  top: e,
  left: t,
  bottom: o,
  right: u
}) => {
  const { innerWidth: i, innerHeight: v } = window;
  return e >= 0 && t >= 0 && u <= i && o <= v;
}, $e = ({
  top: e,
  left: t,
  bottom: o,
  right: u
}) => {
  const { innerWidth: i, innerHeight: v } = window;
  return {
    top: e < 0,
    left: t < 0,
    right: u > i,
    bottom: o > v
  };
}, L = (e) => e === "top" || e === "bottom", Ce = (e) => {
  let t;
  return (...o) => {
    t || (t = requestAnimationFrame(() => {
      t = null, e(...o);
    }));
  };
}, ie = () => {
  const { innerWidth: e, innerHeight: t } = window;
  return {
    top: t / 2,
    left: e / 2,
    right: e / 2,
    bottom: t / 2,
    width: 0,
    height: 0
  };
};
function De(e) {
  const t = Q({
    top: 0,
    left: 0,
    width: 0,
    height: 0,
    bottom: 0,
    right: 0
  }), o = () => {
    const i = ee(e);
    if (!i) {
      v({});
      return;
    }
    v(i.getBoundingClientRect());
    function v({ top: r = 0, left: s = 0, width: m = 0, height: p = 0 }) {
      t.top = r, t.left = s, t.width = m, t.height = p, t.bottom = p + r, t.right = m + s;
    }
  }, u = Ce(o);
  return ae(
    () => ee(e),
    () => {
      o();
    },
    { immediate: !0 }
  ), J(window, "resize", u), J(window, "scroll", u), _e(e, u), {
    rect: t
  };
}
const Pe = Symbol("vgt");
function Ne() {
  const e = Be(Pe);
  if (!e)
    throw new Error("[vue-guided-tour]: Did you forget to install the plugin?");
  return e;
}
const Ge = fe({
  name: "VueGuidedOverlay",
  inheritAttrs: !1,
  props: {
    ...je
  },
  expose: ["highlight", "isTimeout"],
  emits: ["overlay-click", "update:rect"],
  setup(e, { emit: t }) {
    const { rect: o, allowInteraction: u } = pe(e), i = B(!1), v = B(!1), r = ie(), s = Q({ ...r }), m = Q({ ...r }), p = Q({
      width: 0,
      height: 0
    }), O = {
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      scaleX: 1,
      scaleY: 1
    }, _ = [...Ee, "center"], E = Q(
      Object.fromEntries(
        _.map(
          (n) => [n, { ...O }]
        )
      )
    ), $ = 300, S = "cubic-bezier(.65,.05,.36,1)", H = 200, b = z(() => {
      const n = document.body.scrollWidth > document.body.clientWidth;
      return {
        width: `${p.width}px`,
        height: `${p.height}px`,
        "max-width": n ? void 0 : "100%",
        overflow: "hidden",
        position: "absolute",
        top: "0px",
        left: "0px",
        "pointer-events": u.value ? "none" : void 0
      };
    }), V = z(() => (n) => {
      const c = E[n], l = {};
      return n === "bottom" ? (l.bottom = "0px", l.transformOrigin = "bottom left") : n === "right" ? (l.right = "0px", l.transformOrigin = "top right") : (n === "center" && (l.transitionTimingFunction = v.value ? S : void 0, l.transitionDuration = v.value ? `${$}ms` : void 0, l.transitionProperty = v.value ? "transform, border-width, border-radius" : void 0, l.borderStyle = "solid", l.borderColor = "var(--vgo-border-color)", l.borderTopWidth = `calc(var(--vgo-border-width) / ${c.scaleY || 1})`, l.borderBottomWidth = `calc(var(--vgo-border-width) / ${c.scaleY || 1})`, l.borderLeftWidth = `calc(var(--vgo-border-width) / ${c.scaleX || 1})`, l.borderRightWidth = `calc(var(--vgo-border-width) / ${c.scaleX || 1})`), l.top = "0px", l.left = "0px", l.transformOrigin = "top left"), {
        position: "absolute",
        width: `${c.width}px`,
        height: `${c.height}px`,
        transform: `translate3d(${c.x}px, ${c.y}px, 0) scale3d(${c.scaleX}, ${c.scaleY}, 1)`,
        transition: v.value ? `${$}ms transform ${S}` : void 0,
        ...l
      };
    }), C = (n, { top: c = 0, left: l = 0, width: h = 0, height: f = 0 }) => {
      n.top = c, n.left = l, n.width = h, n.height = f, n.bottom = f + c, n.right = h + l;
    }, P = () => {
      const { innerWidth: n, innerHeight: c } = window;
      p.width = n, p.height = c, Z(() => {
        const l = Math.max(
          document.body.scrollHeight,
          document.documentElement.scrollHeight,
          document.body.offsetHeight,
          document.documentElement.offsetHeight,
          document.body.clientHeight,
          document.documentElement.clientHeight
        ), h = Math.max(
          document.body.scrollWidth,
          document.documentElement.scrollWidth,
          document.body.offsetWidth,
          document.documentElement.offsetWidth,
          document.body.clientWidth,
          document.documentElement.clientWidth
        );
        p.width = h, p.height = l;
      });
    }, W = ({
      width: n,
      height: c,
      top: l,
      left: h,
      right: f,
      bottom: Y
    }) => {
      const X = p.width, x = p.height, y = 200, N = {
        width: y,
        height: y,
        x: 0,
        y: l + window.scrollY < 0 ? -y + l + window.scrollY : 0,
        scaleX: X / y,
        scaleY: l + window.scrollY < 0 ? 1 : (l + window.scrollY) / y
      }, U = {
        width: y,
        height: y,
        x: h + window.scrollX < 0 ? -y + h + window.scrollX : 0,
        y: 0,
        scaleX: h + window.scrollX < 0 ? 1 : (h + window.scrollX) / y,
        scaleY: x / y
      }, ue = {
        width: y,
        height: y,
        x: f + window.scrollX > X ? -(X - (f + window.scrollX)) + y : 0,
        y: 0,
        scaleX: f + window.scrollX > X ? 1 : (X - (f + window.scrollX)) / y,
        scaleY: x / y
      }, ce = {
        width: y,
        height: y,
        x: 0,
        y: Y + window.scrollY > x ? -(x - (Y + window.scrollY)) + y : 0,
        scaleX: X / y,
        scaleY: Y + window.scrollY > x ? 1 : (x - (Y + window.scrollY)) / y
      }, ve = {
        width: n,
        height: c,
        x: h + window.scrollX,
        y: l + window.scrollY,
        scaleX: n ? 1 : 0,
        scaleY: c ? 1 : 0
      };
      return {
        top: N,
        left: U,
        right: ue,
        bottom: ce,
        center: ve
      };
    }, A = (n) => W(n).center, F = () => {
      const n = W(s), { center: c, ...l } = E;
      let h;
      for (h in l) {
        const f = E[h];
        f.width = n[h].width, f.height = n[h].height, f.x = n[h].x, f.y = n[h].y, f.scaleX = n[h].scaleX, f.scaleY = n[h].scaleY;
      }
    }, D = () => {
      const n = A(s), c = E.center;
      c.width = n.width || H, c.height = n.height || H, c.x = n.x, c.y = n.y, c.scaleX = n.scaleX, c.scaleY = n.scaleY;
    }, K = () => {
      const n = A(m), c = A(s), l = E.center;
      l.x += n.x - c.x, l.y += n.y - c.y, l.scaleX = c.width ? n.width / c.width : n.width / H, l.scaleY = c.height ? n.height / c.height : n.height / H;
    }, d = () => {
      if (i.value)
        return;
      const n = ie();
      P(), Z(() => {
        C(s, o.value || n), F(), D();
      });
    }, g = (n) => {
      if (i.value || !n)
        return;
      function c() {
        return new Promise((l) => {
          i.value = !0, Z(() => {
            D(), K(), requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                v.value = !0, F(), D(), setTimeout(() => {
                  v.value = !1, i.value = !1, l("");
                }, $);
              });
            });
          });
        });
      }
      return new Promise((l) => {
        P(), Z(() => {
          F(), C(m, s), C(s, n);
        }), c().then(() => {
          t("update:rect", s), l("highlight");
        });
      });
    }, w = Ce(d), k = () => {
      t("overlay-click");
    };
    return ae(
      () => o.value,
      () => {
        w();
      },
      {
        deep: !0,
        immediate: !0
      }
    ), J(window, "scroll", w), J(window, "resize", w), {
      overlayKeys: z(() => _.filter((n) => n != "center")),
      overlaysStyle: V,
      overlayWrapperStyle: b,
      overlaysTransform: E,
      isTimeout: z(() => i.value),
      onClick: k,
      highlight: g
    };
  }
});
const ge = (e, t) => {
  const o = e.__vccOpts || e;
  for (const [u, i] of t)
    o[u] = i;
  return o;
}, Ke = { style: { opacity: "var(--vgo-opacity)" } };
function qe(e, t, o, u, i, v) {
  return R(), M("div", ne({ class: "vue-guided-overlay" }, e.$attrs), [
    q("div", {
      class: "vgo__wrapper",
      style: le(e.overlayWrapperStyle)
    }, [
      q("div", Ke, [
        (R(!0), M(Re, null, ze(e.overlayKeys, (r) => (R(), M("div", {
          key: r,
          class: he(`vgo__overlay vgo__overlay--${r}`),
          style: le(e.overlaysStyle(r)),
          onClick: t[0] || (t[0] = (...s) => e.onClick && e.onClick(...s))
        }, null, 6))), 128))
      ]),
      q("div", {
        class: he("vgo__hightlight"),
        style: le(e.overlaysStyle("center"))
      }, null, 4)
    ], 4)
  ], 16);
}
const Ue = /* @__PURE__ */ ge(Ge, [["render", qe]]), Je = fe({
  name: "VueGuidedPopover",
  inheritAttrs: !1,
  props: {
    ...Ve
  },
  setup(e) {
    const t = B(null), { rect: o, width: u } = pe(e), i = B(0), v = B(0), r = Q({
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      width: 0,
      height: 0
    }), s = B(!1), m = z(() => {
      const d = ie();
      return o.value || d;
    }), p = z(() => ({
      "max-width": typeof u.value == "string" ? u.value : `${u.value}px`,
      transform: `translateX(${r.left}px) translateY(${r.top}px)`
    })), O = z(() => {
      const d = O.value;
      if (!o.value || !e.autoAdjust || A(e.position))
        return e.position;
      {
        if (A(d))
          return d;
        const g = D();
        return s.value ? e.position : g;
      }
    }), _ = z(() => {
      const d = K(O.value);
      return s.value ? d : O.value;
    }), { arrowStyle: E, arrowRect: $, isArrowEnabled: S } = Qe(
      e,
      _,
      r,
      m
    ), H = () => {
      !t.value || !r.width && !r.height || (o.value ? (C(), V(), P(), b()) : (V(), b()));
    }, b = () => {
      if (!t.value)
        return;
      const { width: d, height: g } = t.value.getBoundingClientRect();
      r.top = v.value, r.left = i.value, r.right = d + i.value, r.bottom = g + v.value, r.width = d, r.height = g;
    }, V = () => {
      const d = r.width, g = r.height, { innerWidth: w, innerHeight: k } = window, n = O.value, c = e.placement, l = e.offset + $.value.height;
      let h = w / 2 - d / 2, f = k / 2 - g / 2;
      if (o.value) {
        switch (n) {
          case "bottom":
            h = o.value.left, f = o.value.height + o.value.top + (s.value ? -g - l : l);
            break;
          case "top":
            h = o.value.left, f = o.value.top - g - (s.value ? -g - l : l);
            break;
          case "right":
            h = o.value.width + o.value.left + (s.value ? -d - l : l), f = o.value.top;
            break;
          case "left":
            h = o.value.left - d - (s.value ? -d - l : l), f = o.value.top;
            break;
        }
        switch (c) {
          case "end":
            L(n) ? h = h - d + o.value.width : f = f - g + o.value.height;
            break;
          case "center":
            L(n) ? h = h - d / 2 + o.value.width / 2 : f = f - g / 2 + o.value.height / 2;
            break;
        }
      }
      i.value = h, v.value = f;
    }, C = () => {
      let d = !1;
      e.autoAdjust ? d = Object.values(W()).some((g) => g) : d = W()[e.position], d ? s.value = !1 : s.value = !0;
    }, P = () => {
      if (!e.autoAdjust)
        return;
      const { innerWidth: d, innerHeight: g } = window, w = {
        top: v.value,
        left: i.value,
        bottom: v.value + r.height,
        right: i.value + r.width,
        width: r.width,
        height: r.height
      }, k = $e(w), n = m.value, c = $.value.height + $.value.offset, l = n.top + c, h = n.height + n.top - c, f = n.left + c, Y = n.width + n.left - c, X = $e({
        top: h,
        bottom: l,
        left: Y,
        right: f
      }), x = X.left || X.right, y = X.top || X.bottom;
      let N, U;
      L(O.value) ? k.left ? N = x ? Y : 0 : k.right && (N = x ? -w.width + f : d - w.width) : k.top ? U = y ? h : 0 : k.bottom && (U = y ? -w.height + l : g - w.height), N != null && (i.value = N), U != null && (v.value = U);
    }, W = () => {
      const d = {};
      for (const g of ["top", "left", "right", "bottom"])
        Object.assign(d, { [g]: A(g) });
      return d;
    }, A = (d) => {
      if (!t.value)
        return;
      const g = F()[d], { height: w, width: k } = t.value.getBoundingClientRect(), n = L(d) ? w : k, c = e.offset + $.value.height;
      return g >= n + c;
    }, F = () => {
      const { innerWidth: d, innerHeight: g } = window, w = m.value;
      return {
        bottom: g - (w.height + w.top),
        top: w.top,
        right: d - (w.width + w.left),
        left: w.left
      };
    }, D = () => {
      const d = F();
      return ["top", "right", "left", "bottom"].sort((w, k) => A(w) ? -1 : A(k) ? 1 : d[k] - d[w])[0];
    }, K = (d) => {
      switch (d) {
        case "top":
          return "bottom";
        case "bottom":
          return "top";
        case "left":
          return "right";
        case "right":
          return "left";
      }
    };
    return He(
      () => {
        H();
      },
      {
        flush: "post"
      }
    ), _e(t, b), J(window, "resize", H), {
      rect: o,
      popoverRef: t,
      currentPosition: O,
      popoverStyle: p,
      arrowStyle: E,
      isArrowEnabled: S
    };
  }
});
function Qe(e, t, o, u) {
  const v = Math.sqrt(2) * 14 / 2, r = 6, s = z(() => ({
    size: p.value ? 14 : 0,
    height: p.value ? v : 0,
    offset: p.value ? r : 0
  })), m = z(() => {
    const { tx: _, ty: E } = O();
    return {
      width: `${s.value.size}px`,
      height: `${s.value.size}px`,
      left: L(t.value) ? "0px" : void 0,
      top: L(t.value) ? void 0 : "0px",
      [t.value]: "100%",
      transform: `translateX(${_}px) translateY(${E}px) rotate(45deg)`
    };
  }), p = z(() => e.arrow && e.rect && o.width && o.height), O = () => {
    if (!e.arrow)
      return { tx: 0, ty: 0 };
    const _ = o.width, E = o.height, $ = e.placement, S = s.value.offset, b = (2 * s.value.height - s.value.size) / 2 + S, V = o.top, C = o.left;
    let P = 0, W = 0;
    switch (L(t.value) ? W = t.value === "bottom" ? s.value.size / 2 : -(s.value.size / 2) : P = t.value === "right" ? s.value.size / 2 : -(s.value.size / 2), $) {
      case "center":
        L(t.value) ? P = u.value.left - C + u.value.width / 2 - s.value.size / 2 : W = u.value.top - V + u.value.height / 2 - s.value.size / 2;
        break;
      case "start":
        L(t.value) ? P = u.value.left - C + b : W = u.value.top - V + b;
        break;
      case "end":
        L(t.value) ? P = u.value.width + u.value.left - C - s.value.size - b : W = u.value.height + u.value.top - V - s.value.size - b;
        break;
    }
    const A = b, F = (d) => d - s.value.height * 2 + b, D = F(_), K = F(E);
    return L(t.value) ? P > D ? P = D : P < A && (P = A) : W > K ? W = K : W < A && (W = A), { tx: P, ty: W };
  };
  return {
    arrowStyle: m,
    arrowRect: s,
    isArrowEnabled: p
  };
}
const Ze = { class: "vgp__body" };
function et(e, t, o, u, i, v) {
  return R(), M("div", ne({
    ref: "popoverRef",
    class: "vue-guided-popover",
    style: e.popoverStyle
  }, e.$attrs), [
    e.isArrowEnabled ? (R(), M("div", {
      key: 0,
      class: he(`vgp__arrow vgp__arrow--${e.currentPosition}`),
      style: le(e.arrowStyle)
    }, null, 6)) : G("", !0),
    q("div", Ze, [
      se(e.$slots, "default")
    ])
  ], 16);
}
const tt = /* @__PURE__ */ ge(Je, [["render", et]]), ot = fe({
  name: "VueGuidedTour",
  components: {
    "vgt-overlay": Ue,
    "vgt-popover": tt
  },
  inheritAttrs: !1,
  props: {
    ...Ie
  },
  emits: ["update:step-index", "after-start", "after-exit", "after-move"],
  setup(e, { emit: t }) {
    const {
      steps: o,
      allowKeyboardEvent: u,
      allowEscClose: i,
      allowOverlayClose: v,
      useOverlay: r,
      padding: s,
      name: m
    } = pe(e), p = B(null), O = B(
      null
    ), _ = Ne(), E = Math.random().toString(36).substring(2), $ = B(!1), S = B(!1), H = B(!1), b = B(-1), V = B(-1), C = B(null), P = B(null), { enableTrap: W } = Fe(p);
    let A = null;
    const { getHighlightEl: F, addHighlight: D, removeHighlight: K } = nt(), { rect: d } = De(C), g = z(() => C.value ? Se(d, w.value) : void 0), w = z(() => {
      var a;
      return ((a = k.value) == null ? void 0 : a.padding) ?? s.value;
    }), k = z(() => {
      var T, I, j;
      if (b.value < 0)
        return null;
      const a = o.value[b.value];
      return a ? {
        ...a,
        // popover options
        popover: {
          ...a.popover,
          role: "dialog",
          id: ((T = a.popover) == null ? void 0 : T.id) || `popover-${E}`,
          "aria-labelledby": a.title ? `${((I = a.popover) == null ? void 0 : I.id) || E}-title` : void 0,
          "aria-describedby": a.content ? `${((j = a.popover) == null ? void 0 : j.id) || E}-desc` : void 0
        },
        // overlay options
        overlay: {
          ...a.overlay
        },
        _step: a
      } : null;
    }), n = z(() => b.value === 0), c = z(() => b.value === o.value.length - 1), l = (a = 0) => {
      $.value || ($.value = !0, x(a));
    }, h = async () => {
      var I, j;
      if (!$.value || r.value && ((I = O.value) != null && I.isTimeout))
        return;
      const a = b.value + 1;
      if (a > o.value.length - 1)
        return;
      const T = (j = k.value) == null ? void 0 : j.onBeforeNext;
      T && await T() === !1 || x(a);
    }, f = async () => {
      var I, j;
      if (!$.value || r.value && ((I = O.value) != null && I.isTimeout))
        return;
      const a = b.value - 1;
      if (a < 0)
        return;
      const T = (j = k.value) == null ? void 0 : j.onBeforePrev;
      T && await T() === !1 || x(a);
    }, Y = async () => {
      var I, j;
      if (!$.value || r.value && ((I = O.value) != null && I.isTimeout))
        return;
      const a = (j = k.value) == null ? void 0 : j.onBeforeExit;
      if (a && await a() === !1)
        return;
      x(-1);
    }, X = (a = 0) => {
      var T;
      $.value && (r.value && ((T = O.value) != null && T.isTimeout) || x(a));
    }, x = (a) => {
      if (a < -1 || a > o.value.length - 1 || a === b.value)
        return;
      const T = F(a, o.value);
      S.value = !1, K(), V.value = b.value, b.value = a, t("update:step-index", b.value), a === -1 ? (P.value = null, C.value = null, U()) : (P.value = C.value, C.value = T, y());
    }, y = () => {
      const a = C.value, T = V.value != -1;
      A = document.activeElement, r.value ? T ? (async () => {
        var te;
        const j = a ? Se(
          a.getBoundingClientRect(),
          w.value
        ) : ie();
        await ((te = O.value) == null ? void 0 : te.highlight(j)), N();
      })() : H.value = !0 : Z(() => {
        N();
      });
    }, N = () => {
      const a = C.value, T = V.value != -1;
      a && (Me(a.getBoundingClientRect()) || a.scrollIntoView({ block: "center" }), D(a)), S.value = !0, Z(() => {
        W();
      }), t(T ? "after-move" : "after-start");
    }, U = () => {
      S.value = !1, K(), r.value && (H.value = !1);
    }, ue = () => {
      A.focus({
        preventScroll: !0
      }), $.value = !1, t("after-exit");
    }, ce = (a) => {
      u.value && (a.key === "ArrowLeft" ? f() : a.key === "ArrowRight" ? h() : a.key === "Escape" && i.value && Y());
    }, ve = () => {
      v.value && Y();
    }, We = () => {
      Y();
    };
    return xe(() => {
      const a = {
        start: l,
        next: h,
        prev: f,
        exit: Y,
        move: X
      };
      m.value ? Object.defineProperty(_, m.value, { value: a }) : Object.assign(_, a);
    }), J(window, "keyup", ce), {
      vgtRef: p,
      vgtOverlayRef: O,
      showPopover: S,
      showOverlay: H,
      currentStepIndex: b,
      currentStepRect: g,
      currentStep: k,
      isFirstStep: n,
      isLastStep: c,
      start: l,
      next: h,
      prev: f,
      exit: Y,
      move: X,
      onOverlayClick: ve,
      onCloseClick: We,
      afterMove: N,
      afterLeave: ue
    };
  }
});
function nt() {
  const e = "vgt__target--highlighted";
  return {
    getHighlightEl: (i, v) => {
      if (typeof i != "number" || i < 0 || i > v.length - 1)
        return null;
      const r = v[i].target, s = document.querySelector(`${r}`);
      return r && !s ? (console.warn(
        `[vue-guided-tour]: Target to highlight "${r}" not found`
      ), null) : s;
    },
    addHighlight: (i) => {
      i.classList.add(e);
    },
    removeHighlight: () => {
      document.querySelectorAll(`.${e}`).forEach((v) => {
        v.classList.remove(e);
      });
    }
  };
}
const rt = { class: "vgt__body" }, lt = ["id"], st = ["id"], it = { class: "vgt__footer" }, at = {
  key: 0,
  class: "vgt__pages"
}, ut = { class: "vgt__nav" };
function ct(e, t, o, u, i, v) {
  var m, p, O;
  const r = we("vgt-overlay"), s = we("vgt-popover");
  return R(), oe(Xe, { to: "body" }, [
    q("div", ne({
      ref: "vgtRef",
      class: "vue-guided-tour"
    }, e.$attrs), [
      e.useOverlay ? (R(), oe(ye, {
        key: 0,
        name: "overlay-fade",
        onAfterEnter: e.afterMove,
        onAfterLeave: e.afterLeave
      }, {
        default: de(() => {
          var _;
          return [
            e.showOverlay ? (R(), oe(r, ne({
              key: 0,
              ref: "vgtOverlayRef",
              rect: e.currentStepRect,
              "allow-interaction": e.allowInteraction
            }, { ...(_ = e.currentStep) == null ? void 0 : _.overlay }, { onOverlayClick: e.onOverlayClick }), null, 16, ["rect", "allow-interaction", "onOverlayClick"])) : G("", !0)
          ];
        }),
        _: 1
      }, 8, ["onAfterEnter", "onAfterLeave"])) : G("", !0),
      (m = e.currentStep) != null && m.title || (p = e.currentStep) != null && p.content || (O = e.currentStep) != null && O.slot && e.$slots[e.currentStep.slot] || e.$slots.content ? (R(), oe(ye, {
        key: 1,
        name: "popover-fade"
      }, {
        default: de(() => {
          var _;
          return [
            e.showPopover ? (R(), oe(s, ne({
              key: 0,
              rect: e.currentStepRect,
              arrow: e.arrow,
              offset: e.offset,
              position: e.position,
              placement: e.placement,
              "auto-adjust": e.autoAdjust,
              width: e.width
            }, { ...(_ = e.currentStep) == null ? void 0 : _.popover }), {
              default: de(() => {
                var E, $;
                return [
                  e.closeBtn ? se(e.$slots, "close", { key: 0 }, () => [
                    q("button", {
                      class: "vgt__close-btn",
                      "aria-label": "close Tour",
                      onClick: t[0] || (t[0] = (...S) => e.onCloseClick && e.onCloseClick(...S))
                    }, " × ")
                  ]) : G("", !0),
                  q("div", rt, [
                    se(e.$slots, ((E = e.currentStep) == null ? void 0 : E.slot) || "content", me(be({
                      step: ($ = e.currentStep) == null ? void 0 : $._step,
                      stepIndex: e.currentStepIndex
                    })), () => {
                      var S, H;
                      return [
                        (S = e.currentStep) != null && S.title ? (R(), M("h3", {
                          key: 0,
                          id: e.currentStep.popover["aria-labelledby"],
                          class: "vgt__title"
                        }, re(e.currentStep.title), 9, lt)) : G("", !0),
                        (H = e.currentStep) != null && H.content ? (R(), M("div", {
                          key: 1,
                          id: e.currentStep.popover["aria-describedby"],
                          class: "vgt__content"
                        }, re(e.currentStep.content), 9, st)) : G("", !0)
                      ];
                    })
                  ]),
                  q("div", it, [
                    e.pagination ? (R(), M("div", at, re(e.currentStepIndex + 1) + " / " + re(e.steps.length), 1)) : G("", !0),
                    se(e.$slots, "nav", me(be({ isFirstStep: e.isFirstStep, isLastStep: e.isLastStep })), () => [
                      q("div", ut, [
                        e.isFirstStep ? G("", !0) : (R(), M("button", {
                          key: 0,
                          class: "vgt__btn vgt__btn--secondary vgt__prev-btn",
                          onClick: t[1] || (t[1] = (...S) => e.prev && e.prev(...S))
                        }, " Back ")),
                        e.isLastStep ? (R(), M("button", {
                          key: 1,
                          class: "vgt__btn vgt__btn--primary vgt__exit-btn",
                          onClick: t[2] || (t[2] = (...S) => e.exit && e.exit(...S))
                        }, " Done ")) : (R(), M("button", {
                          key: 2,
                          class: "vgt__btn vgt__btn--primary vgt__next-btn",
                          onClick: t[3] || (t[3] = (...S) => e.next && e.next(...S))
                        }, " Next "))
                      ])
                    ])
                  ])
                ];
              }),
              _: 3
            }, 16, ["rect", "arrow", "offset", "position", "placement", "auto-adjust", "width"])) : G("", !0)
          ];
        }),
        _: 3
      })) : G("", !0)
    ], 16)
  ]);
}
const vt = /* @__PURE__ */ ge(ot, [["render", ct]]), ht = {
  install(e) {
    const t = {};
    e.config.globalProperties.$vgt = t, e.provide(Pe, t), e.component("VueGuidedTour", vt);
  }
};
export {
  Ue as VueGuidedOverlay,
  tt as VueGuidedPopover,
  ht as default,
  De as useRect,
  Ne as useVgt,
  je as vueGuidedOverlayProps,
  Ve as vueGuidedPopoverProps,
  Ie as vueGuidedTourProps
};
