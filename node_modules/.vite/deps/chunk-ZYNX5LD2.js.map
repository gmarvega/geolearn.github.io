{
  "version": 3,
  "sources": ["../../ol/interaction/Property.js", "../../ol/interaction/Interaction.js", "../../ol/MapBrowserEventType.js", "../../ol/interaction/DoubleClickZoom.js", "../../ol/interaction/Pointer.js", "../../ol/events/condition.js", "../../ol/extent.js", "../../ol/extent/Relationship.js", "../../ol/string.js", "../../ol/coordinate.js", "../../ol/interaction/DragPan.js", "../../ol/rotationconstraint.js", "../../ol/interaction/DragRotate.js", "../../ol/transform.js", "../../ol/proj/Units.js", "../../ol/proj/Projection.js", "../../ol/proj/epsg3857.js", "../../ol/proj/epsg4326.js", "../../ol/proj/projections.js", "../../ol/proj/transforms.js", "../../ol/sphere.js", "../../ol/console.js", "../../ol/proj.js", "../../ol/geom/flat/transform.js", "../../ol/geom/Geometry.js", "../../ol/geom/SimpleGeometry.js", "../../ol/geom/flat/closest.js", "../../ol/geom/flat/deflate.js", "../../ol/geom/flat/simplify.js", "../../ol/geom/flat/inflate.js", "../../ol/geom/flat/area.js", "../../ol/geom/LinearRing.js", "../../ol/geom/Point.js", "../../ol/geom/flat/contains.js", "../../ol/geom/flat/interiorpoint.js", "../../ol/geom/flat/segments.js", "../../ol/geom/flat/intersectsextent.js", "../../ol/geom/flat/reverse.js", "../../ol/geom/flat/orient.js", "../../ol/geom/Polygon.js", "../../ol/render/Box.js", "../../ol/interaction/DragBox.js", "../../ol/interaction/DragZoom.js", "../../ol/events/Key.js", "../../ol/interaction/KeyboardPan.js", "../../ol/interaction/KeyboardZoom.js", "../../ol/Kinetic.js", "../../ol/interaction/MouseWheelZoom.js", "../../ol/interaction/PinchRotate.js", "../../ol/interaction/PinchZoom.js", "../../ol/interaction/defaults.js"],
  "sourcesContent": ["/**\n * @module ol/interaction/Property\n */\n\n/**\n * @enum {string}\n */\nexport default {\n  ACTIVE: 'active',\n};\n", "/**\n * @module ol/interaction/Interaction\n */\nimport BaseObject from '../Object.js';\nimport InteractionProperty from './Property.js';\nimport {easeOut, linear} from '../easing.js';\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active', Return>} InteractionOnSignature\n */\n\n/**\n * Object literal with config options for interactions.\n * @typedef {Object} InteractionOptions\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} handleEvent\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. If the function returns a falsy value, propagation of\n * the event to other interactions in the map's interactions chain will be\n * prevented (this includes functions with no explicit return). The interactions\n * are traversed in reverse order of the interactions collection of the map.\n */\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * User actions that change the state of the map. Some are similar to controls,\n * but are not associated with a DOM element.\n * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is\n * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered\n * by a keyboard event not a button element event.\n * Although interactions do not have a DOM element, some of them do render\n * vectors and so are visible on the screen.\n * @api\n */\nclass Interaction extends BaseObject {\n  /**\n   * @param {InteractionOptions} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {InteractionOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {InteractionOnSignature<void>}\n     */\n    this.un;\n\n    if (options && options.handleEvent) {\n      this.handleEvent = options.handleEvent;\n    }\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default|null}\n     */\n    this.map_ = null;\n\n    this.setActive(true);\n  }\n\n  /**\n   * Return whether the interaction is currently active.\n   * @return {boolean} `true` if the interaction is active, `false` otherwise.\n   * @observable\n   * @api\n   */\n  getActive() {\n    return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));\n  }\n\n  /**\n   * Get the map associated with this interaction.\n   * @return {import(\"../Map.js\").default|null} Map.\n   * @api\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(mapBrowserEvent) {\n    return true;\n  }\n\n  /**\n   * Activate or deactivate the interaction.\n   * @param {boolean} active Active.\n   * @observable\n   * @api\n   */\n  setActive(active) {\n    this.set(InteractionProperty.ACTIVE, active);\n  }\n\n  /**\n   * Remove the interaction from its current map and attach it to the new map.\n   * Subclasses may set up event handlers to get notified about changes to\n   * the map here.\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMap(map) {\n    this.map_ = map;\n  }\n}\n\n/**\n * @param {import(\"../View.js\").default} view View.\n * @param {import(\"../coordinate.js\").Coordinate} delta Delta.\n * @param {number} [duration] Duration.\n */\nexport function pan(view, delta, duration) {\n  const currentCenter = view.getCenterInternal();\n  if (currentCenter) {\n    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];\n    view.animateInternal({\n      duration: duration !== undefined ? duration : 250,\n      easing: linear,\n      center: view.getConstrainedCenter(center),\n    });\n  }\n}\n\n/**\n * @param {import(\"../View.js\").default} view View.\n * @param {number} delta Delta from previous zoom level.\n * @param {import(\"../coordinate.js\").Coordinate} [anchor] Anchor coordinate in the user projection.\n * @param {number} [duration] Duration.\n */\nexport function zoomByDelta(view, delta, anchor, duration) {\n  const currentZoom = view.getZoom();\n\n  if (currentZoom === undefined) {\n    return;\n  }\n\n  const newZoom = view.getConstrainedZoom(currentZoom + delta);\n  const newResolution = view.getResolutionForZoom(newZoom);\n\n  if (view.getAnimating()) {\n    view.cancelAnimations();\n  }\n  view.animate({\n    resolution: newResolution,\n    anchor: anchor,\n    duration: duration !== undefined ? duration : 250,\n    easing: easeOut,\n  });\n}\n\nexport default Interaction;\n", "/**\n * @module ol/MapBrowserEventType\n */\nimport EventType from './events/EventType.js';\n\n/**\n * Constants for event names.\n * @enum {string}\n */\nexport default {\n  /**\n   * A true single click with no dragging and no double click. Note that this\n   * event is delayed by 250 ms to ensure that it is not a double click.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick\n   * @api\n   */\n  SINGLECLICK: 'singleclick',\n\n  /**\n   * A click with no dragging. A double click will fire two of this.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click\n   * @api\n   */\n  CLICK: EventType.CLICK,\n\n  /**\n   * A true double click, with no dragging.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick\n   * @api\n   */\n  DBLCLICK: EventType.DBLCLICK,\n\n  /**\n   * Triggered when a pointer is dragged.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag\n   * @api\n   */\n  POINTERDRAG: 'pointerdrag',\n\n  /**\n   * Triggered when a pointer is moved. Note that on touch devices this is\n   * triggered when the map is panned, so is not the same as mousemove.\n   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove\n   * @api\n   */\n  POINTERMOVE: 'pointermove',\n\n  POINTERDOWN: 'pointerdown',\n  POINTERUP: 'pointerup',\n  POINTEROVER: 'pointerover',\n  POINTEROUT: 'pointerout',\n  POINTERENTER: 'pointerenter',\n  POINTERLEAVE: 'pointerleave',\n  POINTERCANCEL: 'pointercancel',\n};\n\n/***\n * @typedef {'singleclick'|'click'|'dblclick'|'pointerdrag'|'pointermove'} Types\n */\n", "/**\n * @module ol/interaction/DoubleClickZoom\n */\nimport Interaction, {zoomByDelta} from './Interaction.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [delta=1] The zoom delta applied on each double click.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom by double-clicking on the map.\n * @api\n */\nclass DoubleClickZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a\n   * doubleclick) and eventually zooms the map.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {\n      const browserEvent = /** @type {MouseEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const map = mapBrowserEvent.map;\n      const anchor = mapBrowserEvent.coordinate;\n      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;\n      const view = map.getView();\n      zoomByDelta(view, delta, anchor, this.duration_);\n      browserEvent.preventDefault();\n      stopEvent = true;\n    }\n    return !stopEvent;\n  }\n}\n\nexport default DoubleClickZoom;\n", "/**\n * @module ol/interaction/Pointer\n */\nimport Interaction from './Interaction.js';\nimport MapBrowserEventType from '../MapBrowserEventType.js';\n\n/**\n * @typedef {Object} Options\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleDownEvent]\n * Function handling \"down\" events. If the function returns `true` then a drag\n * sequence is started.\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleDragEvent]\n * Function handling \"drag\" events. This function is called on \"move\" events\n * during a drag sequence.\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleEvent]\n * Method called by the map to notify the interaction that a browser event was\n * dispatched to the map. The function may return `false` to prevent the\n * propagation of the event to other interactions in the map's interactions\n * chain.\n * @property {function(import(\"../MapBrowserEvent.js\").default):void} [handleMoveEvent]\n * Function handling \"move\" events. This function is called on \"move\" events.\n * This functions is also called during a drag sequence, so during a drag\n * sequence both the `handleDragEvent` function and this function are called.\n * If `handleDownEvent` is defined and it returns true this function will not\n * be called during a drag sequence.\n * @property {function(import(\"../MapBrowserEvent.js\").default):boolean} [handleUpEvent]\n *  Function handling \"up\" events. If the function returns `false` then the\n * current drag sequence is stopped.\n * @property {function(boolean):boolean} [stopDown]\n * Should the down event be propagated to other interactions, or should be\n * stopped?\n */\n\n/**\n * @classdesc\n * Base class that calls user-defined functions on `down`, `move` and `up`\n * events. This class also manages \"drag sequences\".\n *\n * When the `handleDownEvent` user function returns `true` a drag sequence is\n * started. During a drag sequence the `handleDragEvent` user function is\n * called on `move` events. The drag sequence ends when the `handleUpEvent`\n * user function is called and returns `false`.\n * @api\n */\nclass PointerInteraction extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options),\n    );\n\n    if (options.handleDownEvent) {\n      this.handleDownEvent = options.handleDownEvent;\n    }\n\n    if (options.handleDragEvent) {\n      this.handleDragEvent = options.handleDragEvent;\n    }\n\n    if (options.handleMoveEvent) {\n      this.handleMoveEvent = options.handleMoveEvent;\n    }\n\n    if (options.handleUpEvent) {\n      this.handleUpEvent = options.handleUpEvent;\n    }\n\n    if (options.stopDown) {\n      this.stopDown = options.stopDown;\n    }\n\n    /**\n     * @type {boolean}\n     * @protected\n     */\n    this.handlingDownUpSequence = false;\n\n    /**\n     * @type {Array<PointerEvent>}\n     * @protected\n     */\n    this.targetPointers = [];\n  }\n\n  /**\n   * Returns the current number of pointers involved in the interaction,\n   * e.g. `2` when two fingers are used.\n   * @return {number} The number of pointers.\n   * @api\n   */\n  getPointerCount() {\n    return this.targetPointers.length;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n  handleDownEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @protected\n   */\n  handleDragEvent(mapBrowserEvent) {}\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into\n   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are\n   * detected.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   * @api\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!mapBrowserEvent.originalEvent) {\n      return true;\n    }\n\n    let stopEvent = false;\n    this.updateTrackedPointers_(mapBrowserEvent);\n    if (this.handlingDownUpSequence) {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {\n        this.handleDragEvent(mapBrowserEvent);\n        // prevent page scrolling during dragging\n        mapBrowserEvent.originalEvent.preventDefault();\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {\n        const handledUp = this.handleUpEvent(mapBrowserEvent);\n        this.handlingDownUpSequence =\n          handledUp && this.targetPointers.length > 0;\n      }\n    } else {\n      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {\n        const handled = this.handleDownEvent(mapBrowserEvent);\n        this.handlingDownUpSequence = handled;\n        stopEvent = this.stopDown(handled);\n      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {\n        this.handleMoveEvent(mapBrowserEvent);\n      }\n    }\n    return !stopEvent;\n  }\n\n  /**\n   * Handle pointer move events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @protected\n   */\n  handleMoveEvent(mapBrowserEvent) {}\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   * @protected\n   */\n  handleUpEvent(mapBrowserEvent) {\n    return false;\n  }\n\n  /**\n   * This function is used to determine if \"down\" events should be propagated\n   * to other interactions or should be stopped.\n   * @param {boolean} handled Was the event handled by the interaction?\n   * @return {boolean} Should the `down` event be stopped?\n   */\n  stopDown(handled) {\n    return handled;\n  }\n\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @private\n   */\n  updateTrackedPointers_(mapBrowserEvent) {\n    if (mapBrowserEvent.activePointers) {\n      this.targetPointers = mapBrowserEvent.activePointers;\n    }\n  }\n}\n\n/**\n * @param {Array<PointerEvent>} pointerEvents List of events.\n * @return {{clientX: number, clientY: number}} Centroid pixel.\n */\nexport function centroid(pointerEvents) {\n  const length = pointerEvents.length;\n  let clientX = 0;\n  let clientY = 0;\n  for (let i = 0; i < length; i++) {\n    clientX += pointerEvents[i].clientX;\n    clientY += pointerEvents[i].clientY;\n  }\n  return {clientX: clientX / length, clientY: clientY / length};\n}\n\nexport default PointerInteraction;\n", "/**\n * @module ol/events/condition\n */\nimport MapBrowserEventType from '../MapBrowserEventType.js';\nimport {FALSE, TRUE} from '../functions.js';\nimport {MAC, WEBKIT} from '../has.js';\nimport {assert} from '../asserts.js';\n\n/**\n * A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * `{boolean}`. If the condition is met, true should be returned.\n *\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default): boolean} Condition\n */\n\n/**\n * Creates a condition function that passes when all provided conditions pass.\n * @param {...Condition} var_args Conditions to check.\n * @return {Condition} Condition function.\n */\nexport function all(var_args) {\n  const conditions = arguments;\n  /**\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   * @return {boolean} All conditions passed.\n   */\n  return function (event) {\n    let pass = true;\n    for (let i = 0, ii = conditions.length; i < ii; ++i) {\n      pass = pass && conditions[i](event);\n      if (!pass) {\n        break;\n      }\n    }\n    return pass;\n  };\n}\n\n/**\n * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when\n * additionally the shift-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the alt key is pressed.\n * @api\n */\nexport const altKeyOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    originalEvent.altKey &&\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n    !originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise\n * (e.g. when additionally the platform-modifier-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the alt and shift keys are pressed.\n * @api\n */\nexport const altShiftKeysOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    originalEvent.altKey &&\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n    originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if the map has the focus. This condition requires a map target\n * element with a `tabindex` attribute, e.g. `<div id=\"map\" tabindex=\"1\">`.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n * @return {boolean} The map has the focus.\n * @api\n */\nexport const focus = function (event) {\n  const targetElement = event.map.getTargetElement();\n  const activeElement = event.map.getOwnerDocument().activeElement;\n  return targetElement.contains(activeElement);\n};\n\n/**\n * Return `true` if the map has the focus or no 'tabindex' attribute set.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} event Map browser event.\n * @return {boolean} The map container has the focus or no 'tabindex' attribute.\n */\nexport const focusWithTabindex = function (event) {\n  return event.map.getTargetElement().hasAttribute('tabindex')\n    ? focus(event)\n    : true;\n};\n\n/**\n * Return always true.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True.\n * @api\n */\nexport const always = TRUE;\n\n/**\n * Return `true` if the event is a `click` event, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `click` event.\n * @api\n */\nexport const click = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.CLICK;\n};\n\n/**\n * Return `true` if the event has an \"action\"-producing mouse button.\n *\n * By definition, this includes left-click on windows/linux, and left-click\n * without the ctrl key on Macs.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} The result.\n */\nexport const mouseActionButton = function (mapBrowserEvent) {\n  const originalEvent = /** @type {MouseEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);\n};\n\n/**\n * Return always false.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} False.\n * @api\n */\nexport const never = FALSE;\n\n/**\n * Return `true` if the browser event is a `pointermove` event, `false`\n * otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the browser event is a `pointermove` event.\n * @api\n */\nexport const pointerMove = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == 'pointermove';\n};\n\n/**\n * Return `true` if the event is a map `singleclick` event, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `singleclick` event.\n * @api\n */\nexport const singleClick = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;\n};\n\n/**\n * Return `true` if the event is a map `dblclick` event, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event is a map `dblclick` event.\n * @api\n */\nexport const doubleClick = function (mapBrowserEvent) {\n  return mapBrowserEvent.type == MapBrowserEventType.DBLCLICK;\n};\n\n/**\n * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is\n * pressed.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True only if there no modifier keys are pressed.\n * @api\n */\nexport const noModifierKeys = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    !originalEvent.altKey &&\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n    !originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if only the platform-modifier-key (the meta-key on Mac,\n * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally\n * the shift-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the platform modifier key is pressed.\n * @api\n */\nexport const platformModifierKeyOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    !originalEvent.altKey &&\n    (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) &&\n    !originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if the platform-modifier-key (the meta-key on Mac,\n * ctrl-key otherwise) is pressed.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the platform modifier key is pressed.\n * @api\n */\nexport const platformModifierKey = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;\n};\n\n/**\n * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when\n * additionally the alt-key is pressed).\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if only the shift key is pressed.\n * @api\n */\nexport const shiftKeyOnly = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  return (\n    !originalEvent.altKey &&\n    !(originalEvent.metaKey || originalEvent.ctrlKey) &&\n    originalEvent.shiftKey\n  );\n};\n\n/**\n * Return `true` if the target element is not editable, i.e. not an `input`,\n * `select`, or `textarea` element and no `contenteditable` attribute is\n * set or inherited, `false` otherwise.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True only if the target element is not editable.\n * @api\n */\nexport const targetNotEditable = function (mapBrowserEvent) {\n  const originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (\n    mapBrowserEvent.originalEvent\n  );\n  const tagName = /** @type {Element} */ (originalEvent.target).tagName;\n  return (\n    tagName !== 'INPUT' &&\n    tagName !== 'SELECT' &&\n    tagName !== 'TEXTAREA' &&\n    // `isContentEditable` is only available on `HTMLElement`, but it may also be a\n    // different type like `SVGElement`.\n    // @ts-ignore\n    !originalEvent.target.isContentEditable\n  );\n};\n\n/**\n * Return `true` if the event originates from a mouse device.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a mouse device.\n * @api\n */\nexport const mouseOnly = function (mapBrowserEvent) {\n  const pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */ (\n    mapBrowserEvent\n  ).originalEvent;\n  assert(\n    pointerEvent !== undefined,\n    'mapBrowserEvent must originate from a pointer event',\n  );\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n  return pointerEvent.pointerType == 'mouse';\n};\n\n/**\n * Return `true` if the event originates from a touchable device.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a touchable device.\n * @api\n */\nexport const touchOnly = function (mapBrowserEvent) {\n  const pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */ (\n    mapBrowserEvent\n  ).originalEvent;\n  assert(\n    pointerEvt !== undefined,\n    'mapBrowserEvent must originate from a pointer event',\n  );\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n  return pointerEvt.pointerType === 'touch';\n};\n\n/**\n * Return `true` if the event originates from a digital pen.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a digital pen.\n * @api\n */\nexport const penOnly = function (mapBrowserEvent) {\n  const pointerEvt = /** @type {import(\"../MapBrowserEvent\").default} */ (\n    mapBrowserEvent\n  ).originalEvent;\n  assert(\n    pointerEvt !== undefined,\n    'mapBrowserEvent must originate from a pointer event',\n  );\n  // see https://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType\n  return pointerEvt.pointerType === 'pen';\n};\n\n/**\n * Return `true` if the event originates from a primary pointer in\n * contact with the surface or if the left mouse button is pressed.\n * See https://www.w3.org/TR/pointerevents/#button-states.\n *\n * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n * @return {boolean} True if the event originates from a primary pointer.\n * @api\n */\nexport const primaryAction = function (mapBrowserEvent) {\n  const pointerEvent = /** @type {import(\"../MapBrowserEvent\").default} */ (\n    mapBrowserEvent\n  ).originalEvent;\n  assert(\n    pointerEvent !== undefined,\n    'mapBrowserEvent must originate from a pointer event',\n  );\n  return pointerEvent.isPrimary && pointerEvent.button === 0;\n};\n", "/**\n * @module ol/extent\n */\nimport Relationship from './extent/Relationship.js';\n\n/**\n * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.\n * @typedef {Array<number>} Extent\n * @api\n */\n\n/**\n * Extent corner.\n * @typedef {'bottom-left' | 'bottom-right' | 'top-left' | 'top-right'} Corner\n */\n\n/**\n * Build an extent that includes all given coordinates.\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Bounding extent.\n * @api\n */\nexport function boundingExtent(coordinates) {\n  const extent = createEmpty();\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Array<number>} xs Xs.\n * @param {Array<number>} ys Ys.\n * @param {Extent} [dest] Destination extent.\n * @private\n * @return {Extent} Extent.\n */\nfunction _boundingExtentXYs(xs, ys, dest) {\n  const minX = Math.min.apply(null, xs);\n  const minY = Math.min.apply(null, ys);\n  const maxX = Math.max.apply(null, xs);\n  const maxY = Math.max.apply(null, ys);\n  return createOrUpdate(minX, minY, maxX, maxY, dest);\n}\n\n/**\n * Return extent increased by the provided value.\n * @param {Extent} extent Extent.\n * @param {number} value The amount by which the extent should be buffered.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n * @api\n */\nexport function buffer(extent, value, dest) {\n  if (dest) {\n    dest[0] = extent[0] - value;\n    dest[1] = extent[1] - value;\n    dest[2] = extent[2] + value;\n    dest[3] = extent[3] + value;\n    return dest;\n  }\n  return [\n    extent[0] - value,\n    extent[1] - value,\n    extent[2] + value,\n    extent[3] + value,\n  ];\n}\n\n/**\n * Creates a clone of an extent.\n *\n * @param {Extent} extent Extent to clone.\n * @param {Extent} [dest] Extent.\n * @return {Extent} The clone.\n */\nexport function clone(extent, dest) {\n  if (dest) {\n    dest[0] = extent[0];\n    dest[1] = extent[1];\n    dest[2] = extent[2];\n    dest[3] = extent[3];\n    return dest;\n  }\n  return extent.slice();\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {number} Closest squared distance.\n */\nexport function closestSquaredDistanceXY(extent, x, y) {\n  let dx, dy;\n  if (x < extent[0]) {\n    dx = extent[0] - x;\n  } else if (extent[2] < x) {\n    dx = x - extent[2];\n  } else {\n    dx = 0;\n  }\n  if (y < extent[1]) {\n    dy = extent[1] - y;\n  } else if (extent[3] < y) {\n    dy = y - extent[3];\n  } else {\n    dy = 0;\n  }\n  return dx * dx + dy * dy;\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @return {boolean} The coordinate is contained in the extent.\n * @api\n */\nexport function containsCoordinate(extent, coordinate) {\n  return containsXY(extent, coordinate[0], coordinate[1]);\n}\n\n/**\n * Check if one extent contains another.\n *\n * An extent is deemed contained if it lies completely within the other extent,\n * including if they share one or more edges.\n *\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The second extent is contained by or on the edge of the\n *     first.\n * @api\n */\nexport function containsExtent(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[0] &&\n    extent2[2] <= extent1[2] &&\n    extent1[1] <= extent2[1] &&\n    extent2[3] <= extent1[3]\n  );\n}\n\n/**\n * Check if the passed coordinate is contained or on the edge of the extent.\n *\n * @param {Extent} extent Extent.\n * @param {number} x X coordinate.\n * @param {number} y Y coordinate.\n * @return {boolean} The x, y values are contained in the extent.\n * @api\n */\nexport function containsXY(extent, x, y) {\n  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];\n}\n\n/**\n * Get the relationship between a coordinate and extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate The coordinate.\n * @return {import(\"./extent/Relationship.js\").default} The relationship (bitwise compare with\n *     import(\"./extent/Relationship.js\").Relationship).\n */\nexport function coordinateRelationship(extent, coordinate) {\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const x = coordinate[0];\n  const y = coordinate[1];\n  let relationship = Relationship.UNKNOWN;\n  if (x < minX) {\n    relationship = relationship | Relationship.LEFT;\n  } else if (x > maxX) {\n    relationship = relationship | Relationship.RIGHT;\n  }\n  if (y < minY) {\n    relationship = relationship | Relationship.BELOW;\n  } else if (y > maxY) {\n    relationship = relationship | Relationship.ABOVE;\n  }\n  if (relationship === Relationship.UNKNOWN) {\n    relationship = Relationship.INTERSECTING;\n  }\n  return relationship;\n}\n\n/**\n * Create an empty extent.\n * @return {Extent} Empty extent.\n * @api\n */\nexport function createEmpty() {\n  return [Infinity, Infinity, -Infinity, -Infinity];\n}\n\n/**\n * Create a new extent or update the provided extent.\n * @param {number} minX Minimum X.\n * @param {number} minY Minimum Y.\n * @param {number} maxX Maximum X.\n * @param {number} maxY Maximum Y.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdate(minX, minY, maxX, maxY, dest) {\n  if (dest) {\n    dest[0] = minX;\n    dest[1] = minY;\n    dest[2] = maxX;\n    dest[3] = maxY;\n    return dest;\n  }\n  return [minX, minY, maxX, maxY];\n}\n\n/**\n * Create a new empty extent or make the provided one empty.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateEmpty(dest) {\n  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinate(coordinate, dest) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  return createOrUpdate(x, y, x, y, dest);\n}\n\n/**\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromCoordinates(coordinates, dest) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendCoordinates(extent, coordinates);\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromFlatCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  dest,\n) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);\n}\n\n/**\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function createOrUpdateFromRings(rings, dest) {\n  const extent = createOrUpdateEmpty(dest);\n  return extendRings(extent, rings);\n}\n\n/**\n * Determine if two extents are equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {boolean} The two extents are equivalent.\n * @api\n */\nexport function equals(extent1, extent2) {\n  return (\n    extent1[0] == extent2[0] &&\n    extent1[2] == extent2[2] &&\n    extent1[1] == extent2[1] &&\n    extent1[3] == extent2[3]\n  );\n}\n\n/**\n * Determine if two extents are approximately equivalent.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {number} tolerance Tolerance in extent coordinate units.\n * @return {boolean} The two extents differ by less than the tolerance.\n */\nexport function approximatelyEquals(extent1, extent2, tolerance) {\n  return (\n    Math.abs(extent1[0] - extent2[0]) < tolerance &&\n    Math.abs(extent1[2] - extent2[2]) < tolerance &&\n    Math.abs(extent1[1] - extent2[1]) < tolerance &&\n    Math.abs(extent1[3] - extent2[3]) < tolerance\n  );\n}\n\n/**\n * Modify an extent to include another extent.\n * @param {Extent} extent1 The extent to be modified.\n * @param {Extent} extent2 The extent that will be included in the first.\n * @return {Extent} A reference to the first (extended) extent.\n * @api\n */\nexport function extend(extent1, extent2) {\n  if (extent2[0] < extent1[0]) {\n    extent1[0] = extent2[0];\n  }\n  if (extent2[2] > extent1[2]) {\n    extent1[2] = extent2[2];\n  }\n  if (extent2[1] < extent1[1]) {\n    extent1[1] = extent2[1];\n  }\n  if (extent2[3] > extent1[3]) {\n    extent1[3] = extent2[3];\n  }\n  return extent1;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n */\nexport function extendCoordinate(extent, coordinate) {\n  if (coordinate[0] < extent[0]) {\n    extent[0] = coordinate[0];\n  }\n  if (coordinate[0] > extent[2]) {\n    extent[2] = coordinate[0];\n  }\n  if (coordinate[1] < extent[1]) {\n    extent[1] = coordinate[1];\n  }\n  if (coordinate[1] > extent[3]) {\n    extent[3] = coordinate[1];\n  }\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates Coordinates.\n * @return {Extent} Extent.\n */\nexport function extendCoordinates(extent, coordinates) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    extendCoordinate(extent, coordinates[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Extent} Extent.\n */\nexport function extendFlatCoordinates(\n  extent,\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n) {\n  for (; offset < end; offset += stride) {\n    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Array<Array<import(\"./coordinate.js\").Coordinate>>} rings Rings.\n * @return {Extent} Extent.\n */\nexport function extendRings(extent, rings) {\n  for (let i = 0, ii = rings.length; i < ii; ++i) {\n    extendCoordinates(extent, rings[i]);\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} x X.\n * @param {number} y Y.\n */\nexport function extendXY(extent, x, y) {\n  extent[0] = Math.min(extent[0], x);\n  extent[1] = Math.min(extent[1], y);\n  extent[2] = Math.max(extent[2], x);\n  extent[3] = Math.max(extent[3], y);\n}\n\n/**\n * This function calls `callback` for each corner of the extent. If the\n * callback returns a truthy value the function returns that value\n * immediately. Otherwise the function returns `false`.\n * @param {Extent} extent Extent.\n * @param {function(import(\"./coordinate.js\").Coordinate): S} callback Callback.\n * @return {S|boolean} Value.\n * @template S\n */\nexport function forEachCorner(extent, callback) {\n  let val;\n  val = callback(getBottomLeft(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getBottomRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopRight(extent));\n  if (val) {\n    return val;\n  }\n  val = callback(getTopLeft(extent));\n  if (val) {\n    return val;\n  }\n  return false;\n}\n\n/**\n * Get the size of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Area.\n * @api\n */\nexport function getArea(extent) {\n  let area = 0;\n  if (!isEmpty(extent)) {\n    area = getWidth(extent) * getHeight(extent);\n  }\n  return area;\n}\n\n/**\n * Get the bottom left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom left coordinate.\n * @api\n */\nexport function getBottomLeft(extent) {\n  return [extent[0], extent[1]];\n}\n\n/**\n * Get the bottom right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Bottom right coordinate.\n * @api\n */\nexport function getBottomRight(extent) {\n  return [extent[2], extent[1]];\n}\n\n/**\n * Get the center coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Center.\n * @api\n */\nexport function getCenter(extent) {\n  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];\n}\n\n/**\n * Get a corner coordinate of an extent.\n * @param {Extent} extent Extent.\n * @param {Corner} corner Corner.\n * @return {import(\"./coordinate.js\").Coordinate} Corner coordinate.\n */\nexport function getCorner(extent, corner) {\n  let coordinate;\n  if (corner === 'bottom-left') {\n    coordinate = getBottomLeft(extent);\n  } else if (corner === 'bottom-right') {\n    coordinate = getBottomRight(extent);\n  } else if (corner === 'top-left') {\n    coordinate = getTopLeft(extent);\n  } else if (corner === 'top-right') {\n    coordinate = getTopRight(extent);\n  } else {\n    throw new Error('Invalid corner');\n  }\n  return coordinate;\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Enlarged area.\n */\nexport function getEnlargedArea(extent1, extent2) {\n  const minX = Math.min(extent1[0], extent2[0]);\n  const minY = Math.min(extent1[1], extent2[1]);\n  const maxX = Math.max(extent1[2], extent2[2]);\n  const maxY = Math.max(extent1[3], extent2[3]);\n  return (maxX - minX) * (maxY - minY);\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @param {Extent} [dest] Destination extent.\n * @return {Extent} Extent.\n */\nexport function getForViewAndSize(center, resolution, rotation, size, dest) {\n  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(\n    center,\n    resolution,\n    rotation,\n    size,\n  );\n  return createOrUpdate(\n    Math.min(x0, x1, x2, x3),\n    Math.min(y0, y1, y2, y3),\n    Math.max(x0, x1, x2, x3),\n    Math.max(y0, y1, y2, y3),\n    dest,\n  );\n}\n\n/**\n * @param {import(\"./coordinate.js\").Coordinate} center Center.\n * @param {number} resolution Resolution.\n * @param {number} rotation Rotation.\n * @param {import(\"./size.js\").Size} size Size.\n * @return {Array<number>} Linear ring representing the viewport.\n */\nexport function getRotatedViewport(center, resolution, rotation, size) {\n  const dx = (resolution * size[0]) / 2;\n  const dy = (resolution * size[1]) / 2;\n  const cosRotation = Math.cos(rotation);\n  const sinRotation = Math.sin(rotation);\n  const xCos = dx * cosRotation;\n  const xSin = dx * sinRotation;\n  const yCos = dy * cosRotation;\n  const ySin = dy * sinRotation;\n  const x = center[0];\n  const y = center[1];\n  return [\n    x - xCos + ySin,\n    y - xSin - yCos,\n    x - xCos - ySin,\n    y - xSin + yCos,\n    x + xCos - ySin,\n    y + xSin + yCos,\n    x + xCos + ySin,\n    y + xSin - yCos,\n    x - xCos + ySin,\n    y - xSin - yCos,\n  ];\n}\n\n/**\n * Get the height of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Height.\n * @api\n */\nexport function getHeight(extent) {\n  return extent[3] - extent[1];\n}\n\n/**\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @return {number} Intersection area.\n */\nexport function getIntersectionArea(extent1, extent2) {\n  const intersection = getIntersection(extent1, extent2);\n  return getArea(intersection);\n}\n\n/**\n * Get the intersection of two extents.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent 2.\n * @param {Extent} [dest] Optional extent to populate with intersection.\n * @return {Extent} Intersecting extent.\n * @api\n */\nexport function getIntersection(extent1, extent2, dest) {\n  const intersection = dest ? dest : createEmpty();\n  if (intersects(extent1, extent2)) {\n    if (extent1[0] > extent2[0]) {\n      intersection[0] = extent1[0];\n    } else {\n      intersection[0] = extent2[0];\n    }\n    if (extent1[1] > extent2[1]) {\n      intersection[1] = extent1[1];\n    } else {\n      intersection[1] = extent2[1];\n    }\n    if (extent1[2] < extent2[2]) {\n      intersection[2] = extent1[2];\n    } else {\n      intersection[2] = extent2[2];\n    }\n    if (extent1[3] < extent2[3]) {\n      intersection[3] = extent1[3];\n    } else {\n      intersection[3] = extent2[3];\n    }\n  } else {\n    createOrUpdateEmpty(intersection);\n  }\n  return intersection;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @return {number} Margin.\n */\nexport function getMargin(extent) {\n  return getWidth(extent) + getHeight(extent);\n}\n\n/**\n * Get the size (width, height) of an extent.\n * @param {Extent} extent The extent.\n * @return {import(\"./size.js\").Size} The extent size.\n * @api\n */\nexport function getSize(extent) {\n  return [extent[2] - extent[0], extent[3] - extent[1]];\n}\n\n/**\n * Get the top left coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top left coordinate.\n * @api\n */\nexport function getTopLeft(extent) {\n  return [extent[0], extent[3]];\n}\n\n/**\n * Get the top right coordinate of an extent.\n * @param {Extent} extent Extent.\n * @return {import(\"./coordinate.js\").Coordinate} Top right coordinate.\n * @api\n */\nexport function getTopRight(extent) {\n  return [extent[2], extent[3]];\n}\n\n/**\n * Get the width of an extent.\n * @param {Extent} extent Extent.\n * @return {number} Width.\n * @api\n */\nexport function getWidth(extent) {\n  return extent[2] - extent[0];\n}\n\n/**\n * Determine if one extent intersects another.\n * @param {Extent} extent1 Extent 1.\n * @param {Extent} extent2 Extent.\n * @return {boolean} The two extents intersect.\n * @api\n */\nexport function intersects(extent1, extent2) {\n  return (\n    extent1[0] <= extent2[2] &&\n    extent1[2] >= extent2[0] &&\n    extent1[1] <= extent2[3] &&\n    extent1[3] >= extent2[1]\n  );\n}\n\n/**\n * Determine if an extent is empty.\n * @param {Extent} extent Extent.\n * @return {boolean} Is empty.\n * @api\n */\nexport function isEmpty(extent) {\n  return extent[2] < extent[0] || extent[3] < extent[1];\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {Extent} [dest] Extent.\n * @return {Extent} Extent.\n */\nexport function returnOrUpdate(extent, dest) {\n  if (dest) {\n    dest[0] = extent[0];\n    dest[1] = extent[1];\n    dest[2] = extent[2];\n    dest[3] = extent[3];\n    return dest;\n  }\n  return extent;\n}\n\n/**\n * @param {Extent} extent Extent.\n * @param {number} value Value.\n */\nexport function scaleFromCenter(extent, value) {\n  const deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);\n  const deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);\n  extent[0] -= deltaX;\n  extent[2] += deltaX;\n  extent[1] -= deltaY;\n  extent[3] += deltaY;\n}\n\n/**\n * Determine if the segment between two coordinates intersects (crosses,\n * touches, or is contained by) the provided extent.\n * @param {Extent} extent The extent.\n * @param {import(\"./coordinate.js\").Coordinate} start Segment start coordinate.\n * @param {import(\"./coordinate.js\").Coordinate} end Segment end coordinate.\n * @return {boolean} The segment intersects the extent.\n */\nexport function intersectsSegment(extent, start, end) {\n  let intersects = false;\n  const startRel = coordinateRelationship(extent, start);\n  const endRel = coordinateRelationship(extent, end);\n  if (\n    startRel === Relationship.INTERSECTING ||\n    endRel === Relationship.INTERSECTING\n  ) {\n    intersects = true;\n  } else {\n    const minX = extent[0];\n    const minY = extent[1];\n    const maxX = extent[2];\n    const maxY = extent[3];\n    const startX = start[0];\n    const startY = start[1];\n    const endX = end[0];\n    const endY = end[1];\n    const slope = (endY - startY) / (endX - startX);\n    let x, y;\n    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {\n      // potentially intersects top\n      x = endX - (endY - maxY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.RIGHT) &&\n      !(startRel & Relationship.RIGHT)\n    ) {\n      // potentially intersects right\n      y = endY - (endX - maxX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.BELOW) &&\n      !(startRel & Relationship.BELOW)\n    ) {\n      // potentially intersects bottom\n      x = endX - (endY - minY) / slope;\n      intersects = x >= minX && x <= maxX;\n    }\n    if (\n      !intersects &&\n      !!(endRel & Relationship.LEFT) &&\n      !(startRel & Relationship.LEFT)\n    ) {\n      // potentially intersects left\n      y = endY - (endX - minX) * slope;\n      intersects = y >= minY && y <= maxY;\n    }\n  }\n  return intersects;\n}\n\n/**\n * Apply a transform function to the extent.\n * @param {Extent} extent Extent.\n * @param {import(\"./proj.js\").TransformFunction} transformFn Transform function.\n * Called with `[minX, minY, maxX, maxY]` extent coordinates.\n * @param {Extent} [dest] Destination extent.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {Extent} Extent.\n * @api\n */\nexport function applyTransform(extent, transformFn, dest, stops) {\n  if (isEmpty(extent)) {\n    return createOrUpdateEmpty(dest);\n  }\n  let coordinates = [];\n  if (stops > 1) {\n    const width = extent[2] - extent[0];\n    const height = extent[3] - extent[1];\n    for (let i = 0; i < stops; ++i) {\n      coordinates.push(\n        extent[0] + (width * i) / stops,\n        extent[1],\n        extent[2],\n        extent[1] + (height * i) / stops,\n        extent[2] - (width * i) / stops,\n        extent[3],\n        extent[0],\n        extent[3] - (height * i) / stops,\n      );\n    }\n  } else {\n    coordinates = [\n      extent[0],\n      extent[1],\n      extent[2],\n      extent[1],\n      extent[2],\n      extent[3],\n      extent[0],\n      extent[3],\n    ];\n  }\n  transformFn(coordinates, coordinates, 2);\n  const xs = [];\n  const ys = [];\n  for (let i = 0, l = coordinates.length; i < l; i += 2) {\n    xs.push(coordinates[i]);\n    ys.push(coordinates[i + 1]);\n  }\n  return _boundingExtentXYs(xs, ys, dest);\n}\n\n/**\n * Modifies the provided extent in-place to be within the real world\n * extent.\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Extent} The extent within the real world extent.\n */\nexport function wrapX(extent, projection) {\n  const projectionExtent = projection.getExtent();\n  const center = getCenter(extent);\n  if (\n    projection.canWrapX() &&\n    (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])\n  ) {\n    const worldWidth = getWidth(projectionExtent);\n    const worldsAway = Math.floor(\n      (center[0] - projectionExtent[0]) / worldWidth,\n    );\n    const offset = worldsAway * worldWidth;\n    extent[0] -= offset;\n    extent[2] -= offset;\n  }\n  return extent;\n}\n\n/**\n * Fits the extent to the real world\n *\n * If the extent does not cross the anti meridian, this will return the extent in an array\n * If the extent crosses the anti meridian, the extent will be sliced, so each part fits within the\n * real world\n *\n *\n * @param {Extent} extent Extent.\n * @param {import(\"./proj/Projection.js\").default} projection Projection\n * @return {Array<Extent>} The extent within the real world extent.\n */\nexport function wrapAndSliceX(extent, projection) {\n  if (projection.canWrapX()) {\n    const projectionExtent = projection.getExtent();\n\n    if (!isFinite(extent[0]) || !isFinite(extent[2])) {\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n\n    wrapX(extent, projection);\n    const worldWidth = getWidth(projectionExtent);\n\n    if (getWidth(extent) > worldWidth) {\n      // the extent wraps around on itself\n      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];\n    }\n    if (extent[0] < projectionExtent[0]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2], extent[3]],\n      ];\n    }\n    if (extent[2] > projectionExtent[2]) {\n      // the extent crosses the anti meridian, so it needs to be sliced\n      return [\n        [extent[0], extent[1], projectionExtent[2], extent[3]],\n        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]],\n      ];\n    }\n  }\n\n  return [extent];\n}\n", "/**\n * @module ol/extent/Relationship\n */\n\n/**\n * Relationship to an extent.\n * @enum {number}\n */\nexport default {\n  UNKNOWN: 0,\n  INTERSECTING: 1,\n  ABOVE: 2,\n  RIGHT: 4,\n  BELOW: 8,\n  LEFT: 16,\n};\n", "/**\n * @module ol/string\n */\n\n/**\n * @param {number} number Number to be formatted\n * @param {number} width The desired width\n * @param {number} [precision] Precision of the output string (i.e. number of decimal places)\n * @return {string} Formatted string\n */\nexport function padNumber(number, width, precision) {\n  const numberString =\n    precision !== undefined ? number.toFixed(precision) : '' + number;\n  let decimal = numberString.indexOf('.');\n  decimal = decimal === -1 ? numberString.length : decimal;\n  return decimal > width\n    ? numberString\n    : new Array(1 + width - decimal).join('0') + numberString;\n}\n\n/**\n * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js\n * @param {string|number} v1 First version\n * @param {string|number} v2 Second version\n * @return {number} Value\n */\nexport function compareVersions(v1, v2) {\n  const s1 = ('' + v1).split('.');\n  const s2 = ('' + v2).split('.');\n\n  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {\n    const n1 = parseInt(s1[i] || '0', 10);\n    const n2 = parseInt(s2[i] || '0', 10);\n\n    if (n1 > n2) {\n      return 1;\n    }\n    if (n2 > n1) {\n      return -1;\n    }\n  }\n\n  return 0;\n}\n", "/**\n * @module ol/coordinate\n */\nimport {getWidth} from './extent.js';\nimport {modulo, toFixed} from './math.js';\nimport {padNumber} from './string.js';\n\n/**\n * An array of numbers representing an `xy`, `xyz` or `xyzm` coordinate.\n * Example: `[16, 48]`.\n * @typedef {Array<number>} Coordinate\n * @api\n */\n\n/**\n * A function that takes a {@link module:ol/coordinate~Coordinate} and\n * transforms it into a `{string}`.\n *\n * @typedef {function((Coordinate|undefined)): string} CoordinateFormat\n * @api\n */\n\n/**\n * Add `delta` to `coordinate`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {add} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     add(coord, [-2, 4]);\n *     // coord is now [5.85, 51.983333]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {Coordinate} delta Delta.\n * @return {Coordinate} The input coordinate adjusted by\n * the given delta.\n * @api\n */\nexport function add(coordinate, delta) {\n  coordinate[0] += +delta[0];\n  coordinate[1] += +delta[1];\n  return coordinate;\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed circle.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {import(\"./geom/Circle.js\").default} circle The circle.\n * @return {Coordinate} Closest point on the circumference.\n */\nexport function closestOnCircle(coordinate, circle) {\n  const r = circle.getRadius();\n  const center = circle.getCenter();\n  const x0 = center[0];\n  const y0 = center[1];\n  const x1 = coordinate[0];\n  const y1 = coordinate[1];\n\n  let dx = x1 - x0;\n  const dy = y1 - y0;\n  if (dx === 0 && dy === 0) {\n    dx = 1;\n  }\n  const d = Math.sqrt(dx * dx + dy * dy);\n\n  const x = x0 + (r * dx) / d;\n  const y = y0 + (r * dy) / d;\n\n  return [x, y];\n}\n\n/**\n * Calculates the point closest to the passed coordinate on the passed segment.\n * This is the foot of the perpendicular of the coordinate to the segment when\n * the foot is on the segment, or the closest segment coordinate when the foot\n * is outside the segment.\n *\n * @param {Coordinate} coordinate The coordinate.\n * @param {Array<Coordinate>} segment The two coordinates\n * of the segment.\n * @return {Coordinate} The foot of the perpendicular of\n * the coordinate to the segment.\n */\nexport function closestOnSegment(coordinate, segment) {\n  const x0 = coordinate[0];\n  const y0 = coordinate[1];\n  const start = segment[0];\n  const end = segment[1];\n  const x1 = start[0];\n  const y1 = start[1];\n  const x2 = end[0];\n  const y2 = end[1];\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const along =\n    dx === 0 && dy === 0\n      ? 0\n      : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);\n  let x, y;\n  if (along <= 0) {\n    x = x1;\n    y = y1;\n  } else if (along >= 1) {\n    x = x2;\n    y = y2;\n  } else {\n    x = x1 + along * dx;\n    y = y1 + along * dy;\n  }\n  return [x, y];\n}\n\n/**\n * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be\n * used to format\n * a {Coordinate} to a string.\n *\n * Example without specifying the fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY();\n *     const out = stringifyFunc(coord);\n *     // out is now '8, 48'\n *\n * Example with explicitly specifying 2 fractional digits:\n *\n *     import {createStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const stringifyFunc = createStringXY(2);\n *     const out = stringifyFunc(coord);\n *     // out is now '7.85, 47.98'\n *\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {CoordinateFormat} Coordinate format.\n * @api\n */\nexport function createStringXY(fractionDigits) {\n  return (\n    /**\n     * @param {Coordinate} coordinate Coordinate.\n     * @return {string} String XY.\n     */\n    function (coordinate) {\n      return toStringXY(coordinate, fractionDigits);\n    }\n  );\n}\n\n/**\n * @param {string} hemispheres Hemispheres.\n * @param {number} degrees Degrees.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} String.\n */\nexport function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {\n  const normalizedDegrees = modulo(degrees + 180, 360) - 180;\n  const x = Math.abs(3600 * normalizedDegrees);\n  const decimals = fractionDigits || 0;\n\n  let deg = Math.floor(x / 3600);\n  let min = Math.floor((x - deg * 3600) / 60);\n  let sec = toFixed(x - deg * 3600 - min * 60, decimals);\n\n  if (sec >= 60) {\n    sec = 0;\n    min += 1;\n  }\n\n  if (min >= 60) {\n    min = 0;\n    deg += 1;\n  }\n\n  let hdms = deg + '\\u00b0';\n  if (min !== 0 || sec !== 0) {\n    hdms += ' ' + padNumber(min, 2) + '\\u2032';\n  }\n  if (sec !== 0) {\n    hdms += ' ' + padNumber(sec, 2, decimals) + '\\u2033';\n  }\n  if (normalizedDegrees !== 0) {\n    hdms += ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);\n  }\n\n  return hdms;\n}\n\n/**\n * Transforms the given {@link module:ol/coordinate~Coordinate} to a string\n * using the given string template. The strings `{x}` and `{y}` in the template\n * will be replaced with the first and second coordinate values respectively.\n *\n * Example without specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template);\n *     // out is now 'Coordinate is (8|48).'\n *\n * Example explicitly specifying the fractional digits:\n *\n *     import {format} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const template = 'Coordinate is ({x}|{y}).';\n *     const out = format(coord, template, 2);\n *     // out is now 'Coordinate is (7.85|47.98).'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {string} template A template string with `{x}` and `{y}` placeholders\n *     that will be replaced by first and second coordinate values.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Formatted coordinate.\n * @api\n */\nexport function format(coordinate, template, fractionDigits) {\n  if (coordinate) {\n    return template\n      .replace('{x}', coordinate[0].toFixed(fractionDigits))\n      .replace('{y}', coordinate[1].toFixed(fractionDigits));\n  }\n  return '';\n}\n\n/**\n * @param {Coordinate} coordinate1 First coordinate.\n * @param {Coordinate} coordinate2 Second coordinate.\n * @return {boolean} The two coordinates are equal.\n */\nexport function equals(coordinate1, coordinate2) {\n  let equals = true;\n  for (let i = coordinate1.length - 1; i >= 0; --i) {\n    if (coordinate1[i] != coordinate2[i]) {\n      equals = false;\n      break;\n    }\n  }\n  return equals;\n}\n\n/**\n * Rotate `coordinate` by `angle`. `coordinate` is modified in place and\n * returned by the function.\n *\n * Example:\n *\n *     import {rotate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const rotateRadians = Math.PI / 2; // 90 degrees\n *     rotate(coord, rotateRadians);\n *     // coord is now [-47.983333, 7.85]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} angle Angle in radian.\n * @return {Coordinate} Coordinate.\n * @api\n */\nexport function rotate(coordinate, angle) {\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;\n  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;\n  coordinate[0] = x;\n  coordinate[1] = y;\n  return coordinate;\n}\n\n/**\n * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned\n * by the function.\n *\n * Example:\n *\n *     import {scale as scaleCoordinate} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const scale = 1.2;\n *     scaleCoordinate(coord, scale);\n *     // coord is now [9.42, 57.5799996]\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} scale Scale factor.\n * @return {Coordinate} Coordinate.\n */\nexport function scale(coordinate, scale) {\n  coordinate[0] *= scale;\n  coordinate[1] *= scale;\n  return coordinate;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Squared distance between coord1 and coord2.\n */\nexport function squaredDistance(coord1, coord2) {\n  const dx = coord1[0] - coord2[0];\n  const dy = coord1[1] - coord2[1];\n  return dx * dx + dy * dy;\n}\n\n/**\n * @param {Coordinate} coord1 First coordinate.\n * @param {Coordinate} coord2 Second coordinate.\n * @return {number} Distance between coord1 and coord2.\n */\nexport function distance(coord1, coord2) {\n  return Math.sqrt(squaredDistance(coord1, coord2));\n}\n\n/**\n * Calculate the squared distance from a coordinate to a line segment.\n *\n * @param {Coordinate} coordinate Coordinate of the point.\n * @param {Array<Coordinate>} segment Line segment (2\n * coordinates).\n * @return {number} Squared distance from the point to the line segment.\n */\nexport function squaredDistanceToSegment(coordinate, segment) {\n  return squaredDistance(coordinate, closestOnSegment(coordinate, segment));\n}\n\n/**\n * Format a geographic coordinate with the hemisphere, degrees, minutes, and\n * seconds.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord);\n *     // out is now '47 58 60 N 7 50 60 E'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringHDMS} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringHDMS(coord, 1);\n *     // out is now '47 58 60.0 N 7 50 60.0 E'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} Hemisphere, degrees, minutes and seconds.\n * @api\n */\nexport function toStringHDMS(coordinate, fractionDigits) {\n  if (coordinate) {\n    return (\n      degreesToStringHDMS('NS', coordinate[1], fractionDigits) +\n      ' ' +\n      degreesToStringHDMS('EW', coordinate[0], fractionDigits)\n    );\n  }\n  return '';\n}\n\n/**\n * Format a coordinate as a comma delimited string.\n *\n * Example without specifying fractional digits:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord);\n *     // out is now '8, 48'\n *\n * Example explicitly specifying 1 fractional digit:\n *\n *     import {toStringXY} from 'ol/coordinate.js';\n *\n *     const coord = [7.85, 47.983333];\n *     const out = toStringXY(coord, 1);\n *     // out is now '7.8, 48.0'\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {number} [fractionDigits] The number of digits to include\n *    after the decimal point. Default is `0`.\n * @return {string} XY.\n * @api\n */\nexport function toStringXY(coordinate, fractionDigits) {\n  return format(coordinate, '{x}, {y}', fractionDigits);\n}\n\n/**\n * Modifies the provided coordinate in-place to be within the real world\n * extent. The lower projection extent boundary is inclusive, the upper one\n * exclusive.\n *\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {Coordinate} The coordinate within the real world extent.\n */\nexport function wrapX(coordinate, projection) {\n  if (projection.canWrapX()) {\n    const worldWidth = getWidth(projection.getExtent());\n    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);\n    if (worldsAway) {\n      coordinate[0] -= worldsAway * worldWidth;\n    }\n  }\n  return coordinate;\n}\n/**\n * @param {Coordinate} coordinate Coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @param {number} [sourceExtentWidth] Width of the source extent.\n * @return {number} Offset in world widths.\n */\nexport function getWorldsAway(coordinate, projection, sourceExtentWidth) {\n  const projectionExtent = projection.getExtent();\n  let worldsAway = 0;\n  if (\n    projection.canWrapX() &&\n    (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])\n  ) {\n    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);\n    worldsAway = Math.floor(\n      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth,\n    );\n  }\n  return worldsAway;\n}\n", "/**\n * @module ol/interaction/DragPan\n */\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\nimport {FALSE} from '../functions.js';\nimport {\n  all,\n  focusWithTabindex,\n  noModifierKeys,\n  primaryAction,\n} from '../events/condition.js';\nimport {easeOut} from '../easing.js';\nimport {\n  rotate as rotateCoordinate,\n  scale as scaleCoordinate,\n} from '../coordinate.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.noModifierKeys} and {@link module:ol/events/condition.primaryAction}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {import(\"../Kinetic.js\").default} [kinetic] Kinetic inertia to apply to the pan.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map by dragging the map.\n * @api\n */\nclass DragPan extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super({\n      stopDown: FALSE,\n    });\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {import(\"../Kinetic.js\").default|undefined}\n     */\n    this.kinetic_ = options.kinetic;\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     */\n    this.lastCentroid = null;\n\n    /**\n     * @type {number}\n     */\n    this.lastPointersCount_;\n\n    /**\n     * @type {boolean}\n     */\n    this.panning_ = false;\n\n    const condition = options.condition\n      ? options.condition\n      : all(noModifierKeys, primaryAction);\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.onFocusOnly\n      ? all(focusWithTabindex, condition)\n      : condition;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.noKinetic_ = false;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    if (!this.panning_) {\n      this.panning_ = true;\n      map.getView().beginInteraction();\n    }\n    const targetPointers = this.targetPointers;\n    const centroid = map.getEventPixel(centroidFromPointers(targetPointers));\n    if (targetPointers.length == this.lastPointersCount_) {\n      if (this.kinetic_) {\n        this.kinetic_.update(centroid[0], centroid[1]);\n      }\n      if (this.lastCentroid) {\n        const delta = [\n          this.lastCentroid[0] - centroid[0],\n          centroid[1] - this.lastCentroid[1],\n        ];\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        scaleCoordinate(delta, view.getResolution());\n        rotateCoordinate(delta, view.getRotation());\n        view.adjustCenterInternal(delta);\n      }\n    } else if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger down, tiny drag, second finger down\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = centroid;\n    this.lastPointersCount_ = targetPointers.length;\n    mapBrowserEvent.originalEvent.preventDefault();\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (this.targetPointers.length === 0) {\n      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {\n        const distance = this.kinetic_.getDistance();\n        const angle = this.kinetic_.getAngle();\n        const center = view.getCenterInternal();\n        const centerpx = map.getPixelFromCoordinateInternal(center);\n        const dest = map.getCoordinateFromPixelInternal([\n          centerpx[0] - distance * Math.cos(angle),\n          centerpx[1] - distance * Math.sin(angle),\n        ]);\n        view.animateInternal({\n          center: view.getConstrainedCenter(dest),\n          duration: 500,\n          easing: easeOut,\n        });\n      }\n      if (this.panning_) {\n        this.panning_ = false;\n        view.endInteraction();\n      }\n      return false;\n    }\n    if (this.kinetic_) {\n      // reset so we don't overestimate the kinetic energy after\n      // after one finger up, tiny drag, second finger up\n      this.kinetic_.begin();\n    }\n    this.lastCentroid = null;\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      this.lastCentroid = null;\n      // stop any current animation\n      if (view.getAnimating()) {\n        view.cancelAnimations();\n      }\n      if (this.kinetic_) {\n        this.kinetic_.begin();\n      }\n      // No kinetic as soon as more than one pointer on the screen is\n      // detected. This is to prevent nasty pans after pinch.\n      this.noKinetic_ = this.targetPointers.length > 1;\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default DragPan;\n", "/**\n * @module ol/rotationconstraint\n */\nimport {toRadians} from './math.js';\n\n/**\n * @typedef {function((number|undefined), boolean=): (number|undefined)} Type\n */\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function disable(rotation) {\n  if (rotation !== undefined) {\n    return 0;\n  }\n  return undefined;\n}\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @return {number|undefined} Rotation.\n */\nexport function none(rotation) {\n  if (rotation !== undefined) {\n    return rotation;\n  }\n  return undefined;\n}\n\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToN(n) {\n  const theta = (2 * Math.PI) / n;\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving) {\n        return rotation;\n      }\n\n      if (rotation !== undefined) {\n        rotation = Math.floor(rotation / theta + 0.5) * theta;\n        return rotation;\n      }\n      return undefined;\n    }\n  );\n}\n\n/**\n * @param {number} [tolerance] Tolerance.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToZero(tolerance) {\n  const t = tolerance === undefined ? toRadians(5) : tolerance;\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {boolean} [isMoving] True if an interaction or animation is in progress.\n     * @return {number|undefined} Rotation.\n     */\n    function (rotation, isMoving) {\n      if (isMoving || rotation === undefined) {\n        return rotation;\n      }\n\n      if (Math.abs(rotation) <= t) {\n        return 0;\n      }\n      return rotation;\n    }\n  );\n}\n", "/**\n * @module ol/interaction/DragRotate\n */\nimport PointerInteraction from './Pointer.js';\nimport {FALSE} from '../functions.js';\nimport {\n  altShiftKeysOnly,\n  mouseActionButton,\n  mouseOnly,\n} from '../events/condition.js';\nimport {disable} from '../rotationconstraint.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an\n * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.altShiftKeysOnly}.\n * @property {number} [duration=250] Animation duration in milliseconds.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when the alt and shift keys are held down.\n *\n * This interaction is only supported for mouse devices.\n * @api\n */\nclass DragRotate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super({\n      stopDown: FALSE,\n    });\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return;\n    }\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n    const size = map.getSize();\n    const offset = mapBrowserEvent.pixel;\n    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);\n    if (this.lastAngle_ !== undefined) {\n      const delta = theta - this.lastAngle_;\n      view.adjustRotationInternal(-delta);\n    }\n    this.lastAngle_ = theta;\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return true;\n    }\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    view.endInteraction(this.duration_);\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (!mouseOnly(mapBrowserEvent)) {\n      return false;\n    }\n\n    if (\n      mouseActionButton(mapBrowserEvent) &&\n      this.condition_(mapBrowserEvent)\n    ) {\n      const map = mapBrowserEvent.map;\n      map.getView().beginInteraction();\n      this.lastAngle_ = undefined;\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default DragRotate;\n", "/**\n * @module ol/transform\n */\nimport {assert} from './asserts.js';\n\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n * @api\n */\n\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 33 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n\n/**\n * @private\n * @type {Transform}\n */\nconst tmp_ = new Array(6);\n\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nexport function create() {\n  return [1, 0, 0, 1, 0, 0];\n}\n\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nexport function reset(transform) {\n  return set(transform, 1, 0, 0, 1, 0, 0);\n}\n\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nexport function multiply(transform1, transform2) {\n  const a1 = transform1[0];\n  const b1 = transform1[1];\n  const c1 = transform1[2];\n  const d1 = transform1[3];\n  const e1 = transform1[4];\n  const f1 = transform1[5];\n  const a2 = transform2[0];\n  const b2 = transform2[1];\n  const c2 = transform2[2];\n  const d2 = transform2[3];\n  const e2 = transform2[4];\n  const f2 = transform2[5];\n\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n\n  return transform1;\n}\n\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nexport function set(transform, a, b, c, d, e, f) {\n  transform[0] = a;\n  transform[1] = b;\n  transform[2] = c;\n  transform[3] = d;\n  transform[4] = e;\n  transform[5] = f;\n  return transform;\n}\n\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nexport function setFromArray(transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n}\n\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nexport function apply(transform, coordinate) {\n  const x = coordinate[0];\n  const y = coordinate[1];\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n  return coordinate;\n}\n\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nexport function rotate(transform, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nexport function scale(transform, x, y) {\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n\n/**\n * Creates a scale transform.\n * @param {!Transform} target Transform to overwrite.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scale transform.\n */\nexport function makeScale(target, x, y) {\n  return set(target, x, 0, 0, y, 0, 0);\n}\n\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nexport function translate(transform, dx, dy) {\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n  const sin = Math.sin(angle);\n  const cos = Math.cos(angle);\n  transform[0] = sx * cos;\n  transform[1] = sy * sin;\n  transform[2] = -sx * sin;\n  transform[3] = sy * cos;\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform;\n}\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative). The resulting transform\n * string can be applied as `transform` property of an HTMLElement's style.\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {string} The composite css transform.\n * @api\n */\nexport function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {\n  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));\n}\n\n/**\n * Invert the given transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (source) transform.\n */\nexport function invert(source) {\n  return makeInverse(source, source);\n}\n\n/**\n * Invert the given transform.\n * @param {!Transform} target Transform to be set as the inverse of\n *     the source transform.\n * @param {!Transform} source The source transform to invert.\n * @return {!Transform} The inverted (target) transform.\n */\nexport function makeInverse(target, source) {\n  const det = determinant(source);\n  assert(det !== 0, 'Transformation matrix cannot be inverted');\n\n  const a = source[0];\n  const b = source[1];\n  const c = source[2];\n  const d = source[3];\n  const e = source[4];\n  const f = source[5];\n\n  target[0] = d / det;\n  target[1] = -b / det;\n  target[2] = -c / det;\n  target[3] = a / det;\n  target[4] = (c * f - d * e) / det;\n  target[5] = -(a * f - b * e) / det;\n\n  return target;\n}\n\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nexport function determinant(mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n}\n\n/**\n * @type {Array}\n */\nconst matrixPrecision = [1e6, 1e6, 1e6, 1e6, 2, 2];\n\n/**\n * A rounded string version of the transform.  This can be used\n * for CSS transforms.\n * @param {!Transform} mat Matrix.\n * @return {string} The transform as a string.\n */\nexport function toString(mat) {\n  const transformString =\n    'matrix(' +\n    mat\n      .map(\n        (value, i) =>\n          Math.round(value * matrixPrecision[i]) / matrixPrecision[i],\n      )\n      .join(', ') +\n    ')';\n  return transformString;\n}\n", "/**\n * @module ol/proj/Units\n */\n\n/**\n * @typedef {'radians' | 'degrees' | 'ft' | 'm' | 'pixels' | 'tile-pixels' | 'us-ft'} Units\n * Projection units.\n */\n\n/**\n * See http://duff.ess.washington.edu/data/raster/drg/docs/geotiff.txt\n * @type {Object<number, Units>}\n */\nconst unitByCode = {\n  '9001': 'm',\n  '9002': 'ft',\n  '9003': 'us-ft',\n  '9101': 'radians',\n  '9102': 'degrees',\n};\n\n/**\n * @param {number} code Unit code.\n * @return {Units} Units.\n */\nexport function fromCode(code) {\n  return unitByCode[code];\n}\n\n/**\n * @typedef {Object} MetersPerUnitLookup\n * @property {number} radians Radians\n * @property {number} degrees Degrees\n * @property {number} ft  Feet\n * @property {number} m Meters\n * @property {number} us-ft US feet\n */\n\n/**\n * Meters per unit lookup table.\n * @const\n * @type {MetersPerUnitLookup}\n * @api\n */\nexport const METERS_PER_UNIT = {\n  // use the radius of the Normal sphere\n  'radians': 6370997 / (2 * Math.PI),\n  'degrees': (2 * Math.PI * 6370997) / 360,\n  'ft': 0.3048,\n  'm': 1,\n  'us-ft': 1200 / 3937,\n};\n", "/**\n * @module ol/proj/Projection\n */\nimport {METERS_PER_UNIT} from './Units.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.\n * @property {import(\"./Units.js\").Units} [units] Units. Required unless a\n * proj4 projection is defined for `code`.\n * @property {import(\"../extent.js\").Extent} [extent] The validity extent for the SRS.\n * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.\n * @property {boolean} [global=false] Whether the projection is valid for the whole globe.\n * @property {number} [metersPerUnit] The meters per unit for the SRS.\n * If not provided, the `units` are used to get the meters per unit from the {@link METERS_PER_UNIT}\n * lookup table.\n * @property {import(\"../extent.js\").Extent} [worldExtent] The world extent for the SRS.\n * @property {function(number, import(\"../coordinate.js\").Coordinate):number} [getPointResolution]\n * Function to determine resolution at a point. The function is called with a\n * `number` view resolution and a {@link module:ol/coordinate~Coordinate} as arguments, and returns\n * the `number` resolution in projection units at the passed coordinate. If this is `undefined`,\n * the default {@link module:ol/proj.getPointResolution} function will be used.\n */\n\n/**\n * @classdesc\n * Projection definition class. One of these is created for each projection\n * supported in the application and stored in the {@link module:ol/proj} namespace.\n * You can use these in applications, but this is not required, as API params\n * and options use {@link module:ol/proj~ProjectionLike} which means the simple string\n * code will suffice.\n *\n * You can use {@link module:ol/proj.get} to retrieve the object for a particular\n * projection.\n *\n * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together\n * with the following aliases:\n * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,\n *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,\n *     http://www.opengis.net/gml/srs/epsg.xml#4326,\n *     urn:x-ogc:def:crs:EPSG:4326\n * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,\n *     urn:ogc:def:crs:EPSG:6.18:3:3857,\n *     http://www.opengis.net/gml/srs/epsg.xml#3857\n *\n * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can\n * be added using `proj4.defs()`. After all required projection definitions are\n * added, call the {@link module:ol/proj/proj4.register} function.\n *\n * @api\n */\nclass Projection {\n  /**\n   * @param {Options} options Projection options.\n   */\n  constructor(options) {\n    /**\n     * @private\n     * @type {string}\n     */\n    this.code_ = options.code;\n\n    /**\n     * Units of projected coordinates. When set to `TILE_PIXELS`, a\n     * `this.extent_` and `this.worldExtent_` must be configured properly for each\n     * tile.\n     * @private\n     * @type {import(\"./Units.js\").Units}\n     */\n    this.units_ = /** @type {import(\"./Units.js\").Units} */ (options.units);\n\n    /**\n     * Validity extent of the projection in projected coordinates. For projections\n     * with `TILE_PIXELS` units, this is the extent of the tile in\n     * tile pixel space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = options.extent !== undefined ? options.extent : null;\n\n    /**\n     * Extent of the world in EPSG:4326. For projections with\n     * `TILE_PIXELS` units, this is the extent of the tile in\n     * projected coordinate space.\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.worldExtent_ =\n      options.worldExtent !== undefined ? options.worldExtent : null;\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.axisOrientation_ =\n      options.axisOrientation !== undefined ? options.axisOrientation : 'enu';\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.global_ = options.global !== undefined ? options.global : false;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.canWrapX_ = !!(this.global_ && this.extent_);\n\n    /**\n     * @private\n     * @type {function(number, import(\"../coordinate.js\").Coordinate):number|undefined}\n     */\n    this.getPointResolutionFunc_ = options.getPointResolution;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.defaultTileGrid_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.metersPerUnit_ = options.metersPerUnit;\n  }\n\n  /**\n   * @return {boolean} The projection is suitable for wrapping the x-axis\n   */\n  canWrapX() {\n    return this.canWrapX_;\n  }\n\n  /**\n   * Get the code for this projection, e.g. 'EPSG:4326'.\n   * @return {string} Code.\n   * @api\n   */\n  getCode() {\n    return this.code_;\n  }\n\n  /**\n   * Get the validity extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getExtent() {\n    return this.extent_;\n  }\n\n  /**\n   * Get the units of this projection.\n   * @return {import(\"./Units.js\").Units} Units.\n   * @api\n   */\n  getUnits() {\n    return this.units_;\n  }\n\n  /**\n   * Get the amount of meters per unit of this projection.  If the projection is\n   * not configured with `metersPerUnit` or a units identifier, the return is\n   * `undefined`.\n   * @return {number|undefined} Meters.\n   * @api\n   */\n  getMetersPerUnit() {\n    return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];\n  }\n\n  /**\n   * Get the world extent for this projection.\n   * @return {import(\"../extent.js\").Extent} Extent.\n   * @api\n   */\n  getWorldExtent() {\n    return this.worldExtent_;\n  }\n\n  /**\n   * Get the axis orientation of this projection.\n   * Example values are:\n   * enu - the default easting, northing, elevation.\n   * neu - northing, easting, up - useful for \"lat/long\" geographic coordinates,\n   *     or south orientated transverse mercator.\n   * wnu - westing, northing, up - some planetary coordinate systems have\n   *     \"west positive\" coordinate systems\n   * @return {string} Axis orientation.\n   * @api\n   */\n  getAxisOrientation() {\n    return this.axisOrientation_;\n  }\n\n  /**\n   * Is this projection a global projection which spans the whole world?\n   * @return {boolean} Whether the projection is global.\n   * @api\n   */\n  isGlobal() {\n    return this.global_;\n  }\n\n  /**\n   * Set if the projection is a global projection which spans the whole world\n   * @param {boolean} global Whether the projection is global.\n   * @api\n   */\n  setGlobal(global) {\n    this.global_ = global;\n    this.canWrapX_ = !!(global && this.extent_);\n  }\n\n  /**\n   * @return {import(\"../tilegrid/TileGrid.js\").default} The default tile grid.\n   */\n  getDefaultTileGrid() {\n    return this.defaultTileGrid_;\n  }\n\n  /**\n   * @param {import(\"../tilegrid/TileGrid.js\").default} tileGrid The default tile grid.\n   */\n  setDefaultTileGrid(tileGrid) {\n    this.defaultTileGrid_ = tileGrid;\n  }\n\n  /**\n   * Set the validity extent for this projection.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  setExtent(extent) {\n    this.extent_ = extent;\n    this.canWrapX_ = !!(this.global_ && extent);\n  }\n\n  /**\n   * Set the world extent for this projection.\n   * @param {import(\"../extent.js\").Extent} worldExtent World extent\n   *     [minlon, minlat, maxlon, maxlat].\n   * @api\n   */\n  setWorldExtent(worldExtent) {\n    this.worldExtent_ = worldExtent;\n  }\n\n  /**\n   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}\n   * for this projection.\n   * @param {function(number, import(\"../coordinate.js\").Coordinate):number} func Function\n   * @api\n   */\n  setGetPointResolution(func) {\n    this.getPointResolutionFunc_ = func;\n  }\n\n  /**\n   * Get the custom point resolution function for this projection (if set).\n   * @return {function(number, import(\"../coordinate.js\").Coordinate):number|undefined} The custom point\n   * resolution function (if set).\n   */\n  getPointResolutionFunc() {\n    return this.getPointResolutionFunc_;\n  }\n}\n\nexport default Projection;\n", "/**\n * @module ol/proj/epsg3857\n */\nimport Projection from './Projection.js';\n\n/**\n * Radius of WGS84 sphere\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * @const\n * @type {number}\n */\nexport const HALF_SIZE = Math.PI * RADIUS;\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];\n\n/**\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const WORLD_EXTENT = [-180, -85, 180, 85];\n\n/**\n * Maximum safe value in y direction\n * @const\n * @type {number}\n */\nexport const MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));\n\n/**\n * @classdesc\n * Projection object for web/spherical Mercator (EPSG:3857).\n */\nclass EPSG3857Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   */\n  constructor(code) {\n    super({\n      code: code,\n      units: 'm',\n      extent: EXTENT,\n      global: true,\n      worldExtent: WORLD_EXTENT,\n      getPointResolution: function (resolution, point) {\n        return resolution / Math.cosh(point[1] / RADIUS);\n      },\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:3857.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG3857Projection('EPSG:3857'),\n  new EPSG3857Projection('EPSG:102100'),\n  new EPSG3857Projection('EPSG:102113'),\n  new EPSG3857Projection('EPSG:900913'),\n  new EPSG3857Projection('http://www.opengis.net/def/crs/EPSG/0/3857'),\n  new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),\n];\n\n/**\n * Transformation from EPSG:4326 to EPSG:3857.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function fromEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (HALF_SIZE * input[i]) / 180;\n    let y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));\n    if (y > MAX_SAFE_Y) {\n      y = MAX_SAFE_Y;\n    } else if (y < -MAX_SAFE_Y) {\n      y = -MAX_SAFE_Y;\n    }\n    output[i + 1] = y;\n  }\n  return output;\n}\n\n/**\n * Transformation from EPSG:3857 to EPSG:4326.\n *\n * @param {Array<number>} input Input array of coordinate values.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @param {number} [dimension] Dimension (default is `2`).\n * @return {Array<number>} Output array of coordinate values.\n */\nexport function toEPSG4326(input, output, dimension) {\n  const length = input.length;\n  dimension = dimension > 1 ? dimension : 2;\n  if (output === undefined) {\n    if (dimension > 2) {\n      // preserve values beyond second dimension\n      output = input.slice();\n    } else {\n      output = new Array(length);\n    }\n  }\n  for (let i = 0; i < length; i += dimension) {\n    output[i] = (180 * input[i]) / HALF_SIZE;\n    output[i + 1] =\n      (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;\n  }\n  return output;\n}\n", "/**\n * @module ol/proj/epsg4326\n */\nimport Projection from './Projection.js';\n\n/**\n * Semi-major radius of the WGS84 ellipsoid.\n *\n * @const\n * @type {number}\n */\nexport const RADIUS = 6378137;\n\n/**\n * Extent of the EPSG:4326 projection which is the whole world.\n *\n * @const\n * @type {import(\"../extent.js\").Extent}\n */\nexport const EXTENT = [-180, -90, 180, 90];\n\n/**\n * @const\n * @type {number}\n */\nexport const METERS_PER_UNIT = (Math.PI * RADIUS) / 180;\n\n/**\n * @classdesc\n * Projection object for WGS84 geographic coordinates (EPSG:4326).\n *\n * Note that OpenLayers does not strictly comply with the EPSG definition.\n * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).\n * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.\n */\nclass EPSG4326Projection extends Projection {\n  /**\n   * @param {string} code Code.\n   * @param {string} [axisOrientation] Axis orientation.\n   */\n  constructor(code, axisOrientation) {\n    super({\n      code: code,\n      units: 'degrees',\n      extent: EXTENT,\n      axisOrientation: axisOrientation,\n      global: true,\n      metersPerUnit: METERS_PER_UNIT,\n      worldExtent: EXTENT,\n    });\n  }\n}\n\n/**\n * Projections equal to EPSG:4326.\n *\n * @const\n * @type {Array<import(\"./Projection.js\").default>}\n */\nexport const PROJECTIONS = [\n  new EPSG4326Projection('CRS:84'),\n  new EPSG4326Projection('EPSG:4326', 'neu'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),\n  new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/OGC/1.3/CRS84'),\n  new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),\n  new EPSG4326Projection('http://www.opengis.net/def/crs/EPSG/0/4326', 'neu'),\n];\n", "/**\n * @module ol/proj/projections\n */\n\n/**\n * @type {Object<string, import(\"./Projection.js\").default>}\n */\nlet cache = {};\n\n/**\n * Clear the projections cache.\n */\nexport function clear() {\n  cache = {};\n}\n\n/**\n * Get a cached projection by code.\n * @param {string} code The code for the projection.\n * @return {import(\"./Projection.js\").default} The projection (if cached).\n */\nexport function get(code) {\n  return (\n    cache[code] ||\n    cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\\w+)$/, 'EPSG:$3')] ||\n    null\n  );\n}\n\n/**\n * Add a projection to the cache.\n * @param {string} code The projection code.\n * @param {import(\"./Projection.js\").default} projection The projection to cache.\n */\nexport function add(code, projection) {\n  cache[code] = projection;\n}\n", "/**\n * @module ol/proj/transforms\n */\nimport {isEmpty} from '../obj.js';\n\n/**\n * @private\n * @type {!Object<string, Object<string, import(\"../proj.js\").TransformFunction>>}\n */\nlet transforms = {};\n\n/**\n * Clear the transform cache.\n */\nexport function clear() {\n  transforms = {};\n}\n\n/**\n * Registers a conversion function to convert coordinates from the source\n * projection to the destination projection.\n *\n * @param {import(\"./Projection.js\").default} source Source.\n * @param {import(\"./Projection.js\").default} destination Destination.\n * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n */\nexport function add(source, destination, transformFn) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  if (!(sourceCode in transforms)) {\n    transforms[sourceCode] = {};\n  }\n  transforms[sourceCode][destinationCode] = transformFn;\n}\n\n/**\n * Unregisters the conversion function to convert coordinates from the source\n * projection to the destination projection.  This method is used to clean up\n * cached transforms during testing.\n *\n * @param {import(\"./Projection.js\").default} source Source projection.\n * @param {import(\"./Projection.js\").default} destination Destination projection.\n * @return {import(\"../proj.js\").TransformFunction} transformFn The unregistered transform.\n */\nexport function remove(source, destination) {\n  const sourceCode = source.getCode();\n  const destinationCode = destination.getCode();\n  const transform = transforms[sourceCode][destinationCode];\n  delete transforms[sourceCode][destinationCode];\n  if (isEmpty(transforms[sourceCode])) {\n    delete transforms[sourceCode];\n  }\n  return transform;\n}\n\n/**\n * Get a transform given a source code and a destination code.\n * @param {string} sourceCode The code for the source projection.\n * @param {string} destinationCode The code for the destination projection.\n * @return {import(\"../proj.js\").TransformFunction|undefined} The transform function (if found).\n */\nexport function get(sourceCode, destinationCode) {\n  let transform;\n  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {\n    transform = transforms[sourceCode][destinationCode];\n  }\n  return transform;\n}\n", "/**\n * @module ol/sphere\n */\nimport {toDegrees, toRadians} from './math.js';\n\n/**\n * Object literal with options for the {@link getLength} or {@link getArea}\n * functions.\n * @typedef {Object} SphereMetricOptions\n * @property {import(\"./proj.js\").ProjectionLike} [projection='EPSG:3857']\n * Projection of the  geometry.  By default, the geometry is assumed to be in\n * Web Mercator.\n * @property {number} [radius=6371008.8] Sphere radius.  By default, the\n * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)\n * for the WGS84 ellipsoid is used.\n */\n\n/**\n * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.\n * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius\n * @type {number}\n */\nexport const DEFAULT_RADIUS = 6371008.8;\n\n/**\n * Get the great circle distance (in meters) between two geographic coordinates.\n * @param {Array} c1 Starting coordinate.\n * @param {Array} c2 Ending coordinate.\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {number} The great circle distance between the points (in meters).\n * @api\n */\nexport function getDistance(c1, c2, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lat2 = toRadians(c2[1]);\n  const deltaLatBy2 = (lat2 - lat1) / 2;\n  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;\n  const a =\n    Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +\n    Math.sin(deltaLonBy2) *\n      Math.sin(deltaLonBy2) *\n      Math.cos(lat1) *\n      Math.cos(lat2);\n  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n}\n\n/**\n * Get the cumulative great circle length of linestring coordinates (geographic).\n * @param {Array} coordinates Linestring coordinates.\n * @param {number} radius The sphere radius to use.\n * @return {number} The length (in meters).\n */\nfunction getLengthInternal(coordinates, radius) {\n  let length = 0;\n  for (let i = 0, ii = coordinates.length; i < ii - 1; ++i) {\n    length += getDistance(coordinates[i], coordinates[i + 1], radius);\n  }\n  return length;\n}\n\n/**\n * Get the spherical length of a geometry.  This length is the sum of the\n * great circle distances between coordinates.  For polygons, the length is\n * the sum of all rings.  For points, the length is zero.  For multi-part\n * geometries, the length is the sum of the length of each part.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the\n * length calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n * You can change this by providing a `projection` option.\n * @return {number} The spherical length (in meters).\n * @api\n */\nexport function getLength(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let length = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint': {\n      break;\n    }\n    case 'LineString':\n    case 'LinearRing': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      length = getLengthInternal(coordinates, radius);\n      break;\n    }\n    case 'MultiLineString':\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        length += getLengthInternal(coordinates[i], radius);\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        for (j = 0, jj = coords.length; j < jj; ++j) {\n          length += getLengthInternal(coords[j], radius);\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        length += getLength(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return length;\n}\n\n/**\n * Returns the spherical area for a list of coordinates.\n *\n * [Reference](https://trs.jpl.nasa.gov/handle/2014/40409)\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for\n * Polygons on a Sphere\", JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007\n *\n * @param {Array<import(\"./coordinate.js\").Coordinate>} coordinates List of coordinates of a linear\n * ring. If the ring is oriented clockwise, the area will be positive,\n * otherwise it will be negative.\n * @param {number} radius The sphere radius.\n * @return {number} Area (in square meters).\n */\nfunction getAreaInternal(coordinates, radius) {\n  let area = 0;\n  const len = coordinates.length;\n  let x1 = coordinates[len - 1][0];\n  let y1 = coordinates[len - 1][1];\n  for (let i = 0; i < len; i++) {\n    const x2 = coordinates[i][0];\n    const y2 = coordinates[i][1];\n    area +=\n      toRadians(x2 - x1) *\n      (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));\n    x1 = x2;\n    y1 = y2;\n  }\n  return (area * radius * radius) / 2.0;\n}\n\n/**\n * Get the spherical area of a geometry.  This is the area (in meters) assuming\n * that polygon edges are segments of great circles on a sphere.\n * @param {import(\"./geom/Geometry.js\").default} geometry A geometry.\n * @param {SphereMetricOptions} [options] Options for the area\n *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.\n *     You can change this by providing a `projection` option.\n * @return {number} The spherical area (in square meters).\n * @api\n */\nexport function getArea(geometry, options) {\n  options = options || {};\n  const radius = options.radius || DEFAULT_RADIUS;\n  const projection = options.projection || 'EPSG:3857';\n  const type = geometry.getType();\n  if (type !== 'GeometryCollection') {\n    geometry = geometry.clone().transform(projection, 'EPSG:4326');\n  }\n  let area = 0;\n  let coordinates, coords, i, ii, j, jj;\n  switch (type) {\n    case 'Point':\n    case 'MultiPoint':\n    case 'LineString':\n    case 'MultiLineString':\n    case 'LinearRing': {\n      break;\n    }\n    case 'Polygon': {\n      coordinates = /** @type {import(\"./geom/Polygon.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      area = Math.abs(getAreaInternal(coordinates[0], radius));\n      for (i = 1, ii = coordinates.length; i < ii; ++i) {\n        area -= Math.abs(getAreaInternal(coordinates[i], radius));\n      }\n      break;\n    }\n    case 'MultiPolygon': {\n      coordinates = /** @type {import(\"./geom/SimpleGeometry.js\").default} */ (\n        geometry\n      ).getCoordinates();\n      for (i = 0, ii = coordinates.length; i < ii; ++i) {\n        coords = coordinates[i];\n        area += Math.abs(getAreaInternal(coords[0], radius));\n        for (j = 1, jj = coords.length; j < jj; ++j) {\n          area -= Math.abs(getAreaInternal(coords[j], radius));\n        }\n      }\n      break;\n    }\n    case 'GeometryCollection': {\n      const geometries =\n        /** @type {import(\"./geom/GeometryCollection.js\").default} */ (\n          geometry\n        ).getGeometries();\n      for (i = 0, ii = geometries.length; i < ii; ++i) {\n        area += getArea(geometries[i], options);\n      }\n      break;\n    }\n    default: {\n      throw new Error('Unsupported geometry type: ' + type);\n    }\n  }\n  return area;\n}\n\n/**\n * Returns the coordinate at the given distance and bearing from `c1`.\n *\n * @param {import(\"./coordinate.js\").Coordinate} c1 The origin point (`[lon, lat]` in degrees).\n * @param {number} distance The great-circle distance between the origin\n *     point and the target point.\n * @param {number} bearing The bearing (in radians).\n * @param {number} [radius] The sphere radius to use.  Defaults to the Earth's\n *     mean radius using the WGS84 ellipsoid.\n * @return {import(\"./coordinate.js\").Coordinate} The target point.\n */\nexport function offset(c1, distance, bearing, radius) {\n  radius = radius || DEFAULT_RADIUS;\n  const lat1 = toRadians(c1[1]);\n  const lon1 = toRadians(c1[0]);\n  const dByR = distance / radius;\n  const lat = Math.asin(\n    Math.sin(lat1) * Math.cos(dByR) +\n      Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing),\n  );\n  const lon =\n    lon1 +\n    Math.atan2(\n      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),\n      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat),\n    );\n  return [toDegrees(lon), toDegrees(lat)];\n}\n", "/**\n * @module ol/console\n */\n\n/**\n * @typedef {'info'|'warn'|'error'|'none'} Level\n */\n\n/**\n * @type {Object<Level, number>}\n */\nconst levels = {\n  info: 1,\n  warn: 2,\n  error: 3,\n  none: 4,\n};\n\n/**\n * @type {number}\n */\nlet level = levels.info;\n\n/**\n * Set the logging level.  By default, the level is set to 'info' and all\n * messages will be logged.  Set to 'warn' to only display warnings and errors.\n * Set to 'error' to only display errors.  Set to 'none' to silence all messages.\n *\n * @param {Level} l The new level.\n */\nexport function setLevel(l) {\n  level = levels[l];\n}\n\n/**\n * @param  {...any} args Arguments to log\n */\nexport function log(...args) {\n  if (level > levels.info) {\n    return;\n  }\n  console.log(...args); // eslint-disable-line no-console\n}\n\n/**\n * @param  {...any} args Arguments to log\n */\nexport function warn(...args) {\n  if (level > levels.warn) {\n    return;\n  }\n  console.warn(...args); // eslint-disable-line no-console\n}\n\n/**\n * @param  {...any} args Arguments to log\n */\nexport function error(...args) {\n  if (level > levels.error) {\n    return;\n  }\n  console.error(...args); // eslint-disable-line no-console\n}\n", "/**\n * @module ol/proj\n */\n\n/**\n * The ol/proj module stores:\n * * a list of {@link module:ol/proj/Projection~Projection}\n * objects, one for each projection supported by the application\n * * a list of transform functions needed to convert coordinates in one projection\n * into another.\n *\n * The static functions are the methods used to maintain these.\n * Each transform function can handle not only simple coordinate pairs, but also\n * large arrays of coordinates such as vector geometries.\n *\n * When loaded, the library adds projection objects for EPSG:4326 (WGS84\n * geographic coordinates) and EPSG:3857 (Web or Spherical Mercator, as used\n * for example by Bing Maps or OpenStreetMap), together with the relevant\n * transform functions.\n *\n * Additional transforms may be added by using the http://proj4js.org/\n * library (version 2.2 or later). You can use the full build supplied by\n * Proj4js, or create a custom build to support those projections you need; see\n * the Proj4js website for how to do this. You also need the Proj4js definitions\n * for the required projections. These definitions can be obtained from\n * https://epsg.io/, and are a JS function, so can be loaded in a script\n * tag (as in the examples) or pasted into your application.\n *\n * After all required projection definitions are added to proj4's registry (by\n * using `proj4.defs()`), simply call `register(proj4)` from the `ol/proj/proj4`\n * package. Existing transforms are not changed by this function. See\n * examples/wms-image-custom-proj for an example of this.\n *\n * Additional projection definitions can be registered with `proj4.defs()` any\n * time. Just make sure to call `register(proj4)` again; for example, with user-supplied data where you don't\n * know in advance what projections are needed, you can initially load minimal\n * support and then load whichever are requested.\n *\n * Note that Proj4js does not support projection extents. If you want to add\n * one for creating default tile grids, you can add it after the Projection\n * object has been created with `setExtent`, for example,\n * `get('EPSG:1234').setExtent(extent)`.\n *\n * In addition to Proj4js support, any transform functions can be added with\n * {@link module:ol/proj.addCoordinateTransforms}. To use this, you must first create\n * a {@link module:ol/proj/Projection~Projection} object for the new projection and add it with\n * {@link module:ol/proj.addProjection}. You can then add the forward and inverse\n * functions with {@link module:ol/proj.addCoordinateTransforms}. See\n * examples/wms-custom-proj for an example of this.\n *\n * Note that if no transforms are needed and you only need to define the\n * projection, just add a {@link module:ol/proj/Projection~Projection} with\n * {@link module:ol/proj.addProjection}. See examples/wms-no-proj for an example of\n * this.\n */\nimport Projection from './proj/Projection.js';\nimport {\n  PROJECTIONS as EPSG3857_PROJECTIONS,\n  fromEPSG4326,\n  toEPSG4326,\n} from './proj/epsg3857.js';\nimport {PROJECTIONS as EPSG4326_PROJECTIONS} from './proj/epsg4326.js';\nimport {METERS_PER_UNIT} from './proj/Units.js';\nimport {\n  add as addProj,\n  clear as clearProj,\n  get as getProj,\n} from './proj/projections.js';\nimport {\n  add as addTransformFunc,\n  clear as clearTransformFuncs,\n  get as getTransformFunc,\n} from './proj/transforms.js';\nimport {applyTransform, getWidth} from './extent.js';\nimport {clamp, modulo} from './math.js';\nimport {equals, getWorldsAway} from './coordinate.js';\nimport {getDistance} from './sphere.js';\nimport {warn} from './console.js';\n\n/**\n * A projection as {@link module:ol/proj/Projection~Projection}, SRS identifier\n * string or undefined.\n * @typedef {Projection|string|undefined} ProjectionLike\n * @api\n */\n\n/**\n * A transform function accepts an array of input coordinate values, an optional\n * output array, and an optional dimension (default should be 2).  The function\n * transforms the input coordinate values, populates the output array, and\n * returns the output array.\n *\n * @typedef {function(Array<number>, Array<number>=, number=): Array<number>} TransformFunction\n * @api\n */\n\nexport {METERS_PER_UNIT};\n\nexport {Projection};\n\nlet showCoordinateWarning = true;\n\n/**\n * @param {boolean} [disable = true] Disable console info about `useGeographic()`\n */\nexport function disableCoordinateWarning(disable) {\n  const hide = disable === undefined ? true : disable;\n  showCoordinateWarning = !hide;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Output coordinate array (new array, same coordinate\n *     values).\n */\nexport function cloneTransform(input, output) {\n  if (output !== undefined) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    output = output;\n  } else {\n    output = input.slice();\n  }\n  return output;\n}\n\n/**\n * @param {Array<number>} input Input coordinate array.\n * @param {Array<number>} [output] Output array of coordinate values.\n * @return {Array<number>} Input coordinate array (same array as input).\n */\nexport function identityTransform(input, output) {\n  if (output !== undefined && input !== output) {\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      output[i] = input[i];\n    }\n    input = output;\n  }\n  return input;\n}\n\n/**\n * Add a Projection object to the list of supported projections that can be\n * looked up by their code.\n *\n * @param {Projection} projection Projection instance.\n * @api\n */\nexport function addProjection(projection) {\n  addProj(projection.getCode(), projection);\n  addTransformFunc(projection, projection, cloneTransform);\n}\n\n/**\n * @param {Array<Projection>} projections Projections.\n */\nexport function addProjections(projections) {\n  projections.forEach(addProjection);\n}\n\n/**\n * Fetches a Projection object for the code specified.\n *\n * @param {ProjectionLike} projectionLike Either a code string which is\n *     a combination of authority and identifier such as \"EPSG:4326\", or an\n *     existing projection object, or undefined.\n * @return {Projection|null} Projection object, or null if not in list.\n * @api\n */\nexport function get(projectionLike) {\n  return typeof projectionLike === 'string'\n    ? getProj(/** @type {string} */ (projectionLike))\n    : /** @type {Projection} */ (projectionLike) || null;\n}\n\n/**\n * Get the resolution of the point in degrees or distance units.\n * For projections with degrees as the unit this will simply return the\n * provided resolution. For other projections the point resolution is\n * by default estimated by transforming the `point` pixel to EPSG:4326,\n * measuring its width and height on the normal sphere,\n * and taking the average of the width and height.\n * A custom function can be provided for a specific projection, either\n * by setting the `getPointResolution` option in the\n * {@link module:ol/proj/Projection~Projection} constructor or by using\n * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing\n * projection object.\n * @param {ProjectionLike} projection The projection.\n * @param {number} resolution Nominal resolution in projection units.\n * @param {import(\"./coordinate.js\").Coordinate} point Point to find adjusted resolution at.\n * @param {import(\"./proj/Units.js\").Units} [units] Units to get the point resolution in.\n * Default is the projection's units.\n * @return {number} Point resolution.\n * @api\n */\nexport function getPointResolution(projection, resolution, point, units) {\n  projection = get(projection);\n  let pointResolution;\n  const getter = projection.getPointResolutionFunc();\n  if (getter) {\n    pointResolution = getter(resolution, point);\n    if (units && units !== projection.getUnits()) {\n      const metersPerUnit = projection.getMetersPerUnit();\n      if (metersPerUnit) {\n        pointResolution =\n          (pointResolution * metersPerUnit) / METERS_PER_UNIT[units];\n      }\n    }\n  } else {\n    const projUnits = projection.getUnits();\n    if ((projUnits == 'degrees' && !units) || units == 'degrees') {\n      pointResolution = resolution;\n    } else {\n      // Estimate point resolution by transforming the center pixel to EPSG:4326,\n      // measuring its width and height on the normal sphere, and taking the\n      // average of the width and height.\n      const toEPSG4326 = getTransformFromProjections(\n        projection,\n        get('EPSG:4326'),\n      );\n      if (toEPSG4326 === identityTransform && projUnits !== 'degrees') {\n        // no transform is available\n        pointResolution = resolution * projection.getMetersPerUnit();\n      } else {\n        let vertices = [\n          point[0] - resolution / 2,\n          point[1],\n          point[0] + resolution / 2,\n          point[1],\n          point[0],\n          point[1] - resolution / 2,\n          point[0],\n          point[1] + resolution / 2,\n        ];\n        vertices = toEPSG4326(vertices, vertices, 2);\n        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));\n        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));\n        pointResolution = (width + height) / 2;\n      }\n      const metersPerUnit = units\n        ? METERS_PER_UNIT[units]\n        : projection.getMetersPerUnit();\n      if (metersPerUnit !== undefined) {\n        pointResolution /= metersPerUnit;\n      }\n    }\n  }\n  return pointResolution;\n}\n\n/**\n * Registers transformation functions that don't alter coordinates. Those allow\n * to transform between projections with equal meaning.\n *\n * @param {Array<Projection>} projections Projections.\n * @api\n */\nexport function addEquivalentProjections(projections) {\n  addProjections(projections);\n  projections.forEach(function (source) {\n    projections.forEach(function (destination) {\n      if (source !== destination) {\n        addTransformFunc(source, destination, cloneTransform);\n      }\n    });\n  });\n}\n\n/**\n * Registers transformation functions to convert coordinates in any projection\n * in projection1 to any projection in projection2.\n *\n * @param {Array<Projection>} projections1 Projections with equal\n *     meaning.\n * @param {Array<Projection>} projections2 Projections with equal\n *     meaning.\n * @param {TransformFunction} forwardTransform Transformation from any\n *   projection in projection1 to any projection in projection2.\n * @param {TransformFunction} inverseTransform Transform from any projection\n *   in projection2 to any projection in projection1..\n */\nexport function addEquivalentTransforms(\n  projections1,\n  projections2,\n  forwardTransform,\n  inverseTransform,\n) {\n  projections1.forEach(function (projection1) {\n    projections2.forEach(function (projection2) {\n      addTransformFunc(projection1, projection2, forwardTransform);\n      addTransformFunc(projection2, projection1, inverseTransform);\n    });\n  });\n}\n\n/**\n * Clear all cached projections and transforms.\n */\nexport function clearAllProjections() {\n  clearProj();\n  clearTransformFuncs();\n}\n\n/**\n * @param {Projection|string|undefined} projection Projection.\n * @param {string} defaultCode Default code.\n * @return {Projection} Projection.\n */\nexport function createProjection(projection, defaultCode) {\n  if (!projection) {\n    return get(defaultCode);\n  }\n  if (typeof projection === 'string') {\n    return get(projection);\n  }\n  return /** @type {Projection} */ (projection);\n}\n\n/**\n * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform\n * function.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} coordTransform Coordinate\n *     transform.\n * @return {TransformFunction} Transform function.\n */\nexport function createTransformFromCoordinateTransform(coordTransform) {\n  return (\n    /**\n     * @param {Array<number>} input Input.\n     * @param {Array<number>} [output] Output.\n     * @param {number} [dimension] Dimension.\n     * @return {Array<number>} Output.\n     */\n    function (input, output, dimension) {\n      const length = input.length;\n      dimension = dimension !== undefined ? dimension : 2;\n      output = output !== undefined ? output : new Array(length);\n      for (let i = 0; i < length; i += dimension) {\n        const point = coordTransform(input.slice(i, i + dimension));\n        const pointLength = point.length;\n        for (let j = 0, jj = dimension; j < jj; ++j) {\n          output[i + j] = j >= pointLength ? input[i + j] : point[j];\n        }\n      }\n      return output;\n    }\n  );\n}\n\n/**\n * Registers coordinate transform functions to convert coordinates between the\n * source projection and the destination projection.\n * The forward and inverse functions convert coordinate pairs; this function\n * converts these into the functions used internally which also handle\n * extents and coordinate arrays.\n *\n * @param {ProjectionLike} source Source projection.\n * @param {ProjectionLike} destination Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} forward The forward transform\n *     function (that is, from the source projection to the destination\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} inverse The inverse transform\n *     function (that is, from the destination projection to the source\n *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns\n *     the transformed {@link module:ol/coordinate~Coordinate}. If the transform function can only\n *     transform less dimensions than the input coordinate, it is supposeed to return a coordinate\n *     with only the length it can transform. The other dimensions will be taken unchanged from the\n *     source.\n * @api\n */\nexport function addCoordinateTransforms(source, destination, forward, inverse) {\n  const sourceProj = get(source);\n  const destProj = get(destination);\n  addTransformFunc(\n    sourceProj,\n    destProj,\n    createTransformFromCoordinateTransform(forward),\n  );\n  addTransformFunc(\n    destProj,\n    sourceProj,\n    createTransformFromCoordinateTransform(inverse),\n  );\n}\n\n/**\n * Transforms a coordinate from longitude/latitude to a different projection.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate as longitude and latitude, i.e.\n *     an array with longitude as 1st and latitude as 2nd element.\n * @param {ProjectionLike} [projection] Target projection. The\n *     default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate projected to the target projection.\n * @api\n */\nexport function fromLonLat(coordinate, projection) {\n  disableCoordinateWarning();\n  return transform(\n    coordinate,\n    'EPSG:4326',\n    projection !== undefined ? projection : 'EPSG:3857',\n  );\n}\n\n/**\n * Transforms a coordinate to longitude/latitude.\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Projected coordinate.\n * @param {ProjectionLike} [projection] Projection of the coordinate.\n *     The default is Web Mercator, i.e. 'EPSG:3857'.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate as longitude and latitude, i.e. an array\n *     with longitude as 1st and latitude as 2nd element.\n * @api\n */\nexport function toLonLat(coordinate, projection) {\n  const lonLat = transform(\n    coordinate,\n    projection !== undefined ? projection : 'EPSG:3857',\n    'EPSG:4326',\n  );\n  const lon = lonLat[0];\n  if (lon < -180 || lon > 180) {\n    lonLat[0] = modulo(lon + 180, 360) - 180;\n  }\n  return lonLat;\n}\n\n/**\n * Checks if two projections are the same, that is every coordinate in one\n * projection does represent the same geographic point as the same coordinate in\n * the other projection.\n *\n * @param {Projection} projection1 Projection 1.\n * @param {Projection} projection2 Projection 2.\n * @return {boolean} Equivalent.\n * @api\n */\nexport function equivalent(projection1, projection2) {\n  if (projection1 === projection2) {\n    return true;\n  }\n  const equalUnits = projection1.getUnits() === projection2.getUnits();\n  if (projection1.getCode() === projection2.getCode()) {\n    return equalUnits;\n  }\n  const transformFunc = getTransformFromProjections(projection1, projection2);\n  return transformFunc === cloneTransform && equalUnits;\n}\n\n/**\n * Searches in the list of transform functions for the function for converting\n * coordinates from the source projection to the destination projection.\n *\n * @param {Projection} sourceProjection Source Projection object.\n * @param {Projection} destinationProjection Destination Projection\n *     object.\n * @return {TransformFunction} Transform function.\n */\nexport function getTransformFromProjections(\n  sourceProjection,\n  destinationProjection,\n) {\n  const sourceCode = sourceProjection.getCode();\n  const destinationCode = destinationProjection.getCode();\n  let transformFunc = getTransformFunc(sourceCode, destinationCode);\n  if (!transformFunc) {\n    transformFunc = identityTransform;\n  }\n  return transformFunc;\n}\n\n/**\n * Given the projection-like objects, searches for a transformation\n * function to convert a coordinates array from the source projection to the\n * destination projection.\n *\n * @param {ProjectionLike} source Source.\n * @param {ProjectionLike} destination Destination.\n * @return {TransformFunction} Transform function.\n * @api\n */\nexport function getTransform(source, destination) {\n  const sourceProjection = get(source);\n  const destinationProjection = get(destination);\n  return getTransformFromProjections(sourceProjection, destinationProjection);\n}\n\n/**\n * Transforms a coordinate from source projection to destination projection.\n * This returns a new coordinate (and does not modify the original).\n *\n * See {@link module:ol/proj.transformExtent} for extent transformation.\n * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its\n * subclasses for geometry transforms.\n *\n * @param {import(\"./coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @return {import(\"./coordinate.js\").Coordinate} Coordinate.\n * @api\n */\nexport function transform(coordinate, source, destination) {\n  const transformFunc = getTransform(source, destination);\n  return transformFunc(coordinate, undefined, coordinate.length);\n}\n\n/**\n * Transforms an extent from source projection to destination projection.  This\n * returns a new extent (and does not modify the original).\n *\n * @param {import(\"./extent.js\").Extent} extent The extent to transform.\n * @param {ProjectionLike} source Source projection-like.\n * @param {ProjectionLike} destination Destination projection-like.\n * @param {number} [stops] Number of stops per side used for the transform.\n * By default only the corners are used.\n * @return {import(\"./extent.js\").Extent} The transformed extent.\n * @api\n */\nexport function transformExtent(extent, source, destination, stops) {\n  const transformFunc = getTransform(source, destination);\n  return applyTransform(extent, transformFunc, undefined, stops);\n}\n\n/**\n * Transforms the given point to the destination projection.\n *\n * @param {import(\"./coordinate.js\").Coordinate} point Point.\n * @param {Projection} sourceProjection Source projection.\n * @param {Projection} destinationProjection Destination projection.\n * @return {import(\"./coordinate.js\").Coordinate} Point.\n */\nexport function transformWithProjections(\n  point,\n  sourceProjection,\n  destinationProjection,\n) {\n  const transformFunc = getTransformFromProjections(\n    sourceProjection,\n    destinationProjection,\n  );\n  return transformFunc(point);\n}\n\n/**\n * @type {Projection|null}\n */\nlet userProjection = null;\n\n/**\n * Set the projection for coordinates supplied from and returned by API methods.\n * This includes all API methods except for those interacting with tile grids,\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\n * @param {ProjectionLike} projection The user projection.\n * @api\n */\nexport function setUserProjection(projection) {\n  userProjection = get(projection);\n}\n\n/**\n * Clear the user projection if set.\n * @api\n */\nexport function clearUserProjection() {\n  userProjection = null;\n}\n\n/**\n * Get the projection for coordinates supplied from and returned by API methods.\n * @return {Projection|null} The user projection (or null if not set).\n * @api\n */\nexport function getUserProjection() {\n  return userProjection;\n}\n\n/**\n * Use geographic coordinates (WGS-84 datum) in API methods.\n * This includes all API methods except for those interacting with tile grids,\n * plus {@link import(\"./Map.js\").FrameState} and {@link import(\"./View.js\").State}.\n * @api\n */\nexport function useGeographic() {\n  setUserProjection('EPSG:4326');\n}\n\n/**\n * Return a coordinate transformed into the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} sourceProjection The input coordinate projection.\n * @return {Array<number>} The input coordinate in the user projection.\n */\nexport function toUserCoordinate(coordinate, sourceProjection) {\n  if (!userProjection) {\n    return coordinate;\n  }\n  return transform(coordinate, sourceProjection, userProjection);\n}\n\n/**\n * Return a coordinate transformed from the user projection.  If no user projection\n * is set, the original coordinate is returned.\n * @param {Array<number>} coordinate Input coordinate.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {Array<number>} The input coordinate transformed.\n */\nexport function fromUserCoordinate(coordinate, destProjection) {\n  if (!userProjection) {\n    if (\n      showCoordinateWarning &&\n      !equals(coordinate, [0, 0]) &&\n      coordinate[0] >= -180 &&\n      coordinate[0] <= 180 &&\n      coordinate[1] >= -90 &&\n      coordinate[1] <= 90\n    ) {\n      showCoordinateWarning = false;\n      warn(\n        'Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.',\n      );\n    }\n    return coordinate;\n  }\n  return transform(coordinate, userProjection, destProjection);\n}\n\n/**\n * Return an extent transformed into the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} sourceProjection The input extent projection.\n * @return {import(\"./extent.js\").Extent} The input extent in the user projection.\n */\nexport function toUserExtent(extent, sourceProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, sourceProjection, userProjection);\n}\n\n/**\n * Return an extent transformed from the user projection.  If no user projection\n * is set, the original extent is returned.\n * @param {import(\"./extent.js\").Extent} extent Input extent.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {import(\"./extent.js\").Extent} The input extent transformed.\n */\nexport function fromUserExtent(extent, destProjection) {\n  if (!userProjection) {\n    return extent;\n  }\n  return transformExtent(extent, userProjection, destProjection);\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in input projection units per pixel.\n * @param {ProjectionLike} sourceProjection The input projection.\n * @return {number} Resolution in user projection units per pixel.\n */\nexport function toUserResolution(resolution, sourceProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const sourceMetersPerUnit = get(sourceProjection).getMetersPerUnit();\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\n  return sourceMetersPerUnit && userMetersPerUnit\n    ? (resolution * sourceMetersPerUnit) / userMetersPerUnit\n    : resolution;\n}\n\n/**\n * Return the resolution in user projection units per pixel. If no user projection\n * is set, or source or user projection are missing units, the original resolution\n * is returned.\n * @param {number} resolution Resolution in user projection units per pixel.\n * @param {ProjectionLike} destProjection The destination projection.\n * @return {number} Resolution in destination projection units per pixel.\n */\nexport function fromUserResolution(resolution, destProjection) {\n  if (!userProjection) {\n    return resolution;\n  }\n  const destMetersPerUnit = get(destProjection).getMetersPerUnit();\n  const userMetersPerUnit = userProjection.getMetersPerUnit();\n  return destMetersPerUnit && userMetersPerUnit\n    ? (resolution * userMetersPerUnit) / destMetersPerUnit\n    : resolution;\n}\n\n/**\n * Creates a safe coordinate transform function from a coordinate transform function.\n * \"Safe\" means that it can handle wrapping of x-coordinates for global projections,\n * and that coordinates exceeding the source projection validity extent's range will be\n * clamped to the validity range.\n * @param {Projection} sourceProj Source projection.\n * @param {Projection} destProj Destination projection.\n * @param {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} transform Transform function (source to destination).\n * @return {function(import(\"./coordinate.js\").Coordinate): import(\"./coordinate.js\").Coordinate} Safe transform function (source to destination).\n */\nexport function createSafeCoordinateTransform(sourceProj, destProj, transform) {\n  return function (coord) {\n    let transformed, worldsAway;\n    if (sourceProj.canWrapX()) {\n      const sourceExtent = sourceProj.getExtent();\n      const sourceExtentWidth = getWidth(sourceExtent);\n      coord = coord.slice(0);\n      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);\n      if (worldsAway) {\n        // Move x to the real world\n        coord[0] = coord[0] - worldsAway * sourceExtentWidth;\n      }\n      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);\n      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);\n      transformed = transform(coord);\n    } else {\n      transformed = transform(coord);\n    }\n    if (worldsAway && destProj.canWrapX()) {\n      // Move transformed coordinate back to the offset world\n      transformed[0] += worldsAway * getWidth(destProj.getExtent());\n    }\n    return transformed;\n  };\n}\n\n/**\n * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called\n * by when this module is executed and should only need to be called again after\n * `clearAllProjections()` is called (e.g. in tests).\n */\nexport function addCommon() {\n  // Add transformations that don't alter coordinates to convert within set of\n  // projections with equal meaning.\n  addEquivalentProjections(EPSG3857_PROJECTIONS);\n  addEquivalentProjections(EPSG4326_PROJECTIONS);\n  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like\n  // coordinates and back.\n  addEquivalentTransforms(\n    EPSG4326_PROJECTIONS,\n    EPSG3857_PROJECTIONS,\n    fromEPSG4326,\n    toEPSG4326,\n  );\n}\n\naddCommon();\n", "/**\n * @module ol/geom/flat/transform\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function transform2D(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  transform,\n  dest,\n) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const x = flatCoordinates[j];\n    const y = flatCoordinates[j + 1];\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function rotate(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  angle,\n  anchor,\n  dest,\n) {\n  dest = dest ? dest : [];\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function scale(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  sx,\n  sy,\n  anchor,\n  dest,\n) {\n  dest = dest ? dest : [];\n  const anchorX = anchor[0];\n  const anchorY = anchor[1];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    const deltaX = flatCoordinates[j] - anchorX;\n    const deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + sx * deltaX;\n    dest[i++] = anchorY + sy * deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function translate(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  deltaX,\n  deltaY,\n  dest,\n) {\n  dest = dest ? dest : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    dest[i++] = flatCoordinates[j] + deltaX;\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\n    for (let k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n", "/**\n * @module ol/geom/Geometry\n */\nimport BaseObject from '../Object.js';\nimport {abstract} from '../util.js';\nimport {\n  compose as composeTransform,\n  create as createTransform,\n} from '../transform.js';\nimport {\n  createEmpty,\n  createOrUpdateEmpty,\n  getHeight,\n  returnOrUpdate,\n} from '../extent.js';\nimport {get as getProjection, getTransform} from '../proj.js';\nimport {memoizeOne} from '../functions.js';\nimport {transform2D} from './flat/transform.js';\n\n/**\n * @typedef {'XY' | 'XYZ' | 'XYM' | 'XYZM'} GeometryLayout\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available.\n */\n\n/**\n * @typedef {'Point' | 'LineString' | 'LinearRing' | 'Polygon' | 'MultiPoint' | 'MultiLineString' | 'MultiPolygon' | 'GeometryCollection' | 'Circle'} Type\n * The geometry type.  One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, or `'Circle'`.\n */\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nconst tmpTransform = createTransform();\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nclass Geometry extends BaseObject {\n  constructor() {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.extentRevision_ = -1;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryRevision = 0;\n\n    /**\n     * Get a transformed and simplified version of the geometry.\n     * @abstract\n     * @param {number} revision The geometry revision.\n     * @param {number} squaredTolerance Squared tolerance.\n     * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n     * @return {Geometry} Simplified geometry.\n     */\n    this.simplifyTransformedInternal = memoizeOne(\n      (revision, squaredTolerance, transform) => {\n        if (!transform) {\n          return this.getSimplifiedGeometry(squaredTolerance);\n        }\n        const clone = this.clone();\n        clone.applyTransform(transform);\n        return clone.getSimplifiedGeometry(squaredTolerance);\n      },\n    );\n  }\n\n  /**\n   * Get a transformed and simplified version of the geometry.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n   * @return {Geometry} Simplified geometry.\n   */\n  simplifyTransformed(squaredTolerance, transform) {\n    return this.simplifyTransformedInternal(\n      this.getRevision(),\n      squaredTolerance,\n      transform,\n    );\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!Geometry} Clone.\n   */\n  clone() {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    return abstract();\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    const coord = this.getClosestPoint([x, y]);\n    return coord[0] === x && coord[1] === y;\n  }\n\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\n   * @param {import(\"../coordinate.js\").Coordinate} [closestPoint] Closest point.\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n   * @api\n   */\n  getClosestPoint(point, closestPoint) {\n    closestPoint = closestPoint ? closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  }\n\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  intersectsCoordinate(coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Get the extent of the geometry.\n   * @param {import(\"../extent.js\").Extent} [extent] Extent.\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  getExtent(extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      const extent = this.computeExtent(this.extent_);\n      if (isNaN(extent[0]) || isNaN(extent[1])) {\n        createOrUpdateEmpty(extent);\n      }\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, extent);\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    abstract();\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    abstract();\n  }\n\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)\n   * algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {Geometry} A new, simplified version of the original geometry.\n   * @api\n   */\n  simplify(tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Geometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    return abstract();\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {Type} Geometry type.\n   */\n  getType() {\n    return abstract();\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   */\n  applyTransform(transformFn) {\n    abstract();\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  intersectsExtent(extent) {\n    return abstract();\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    abstract();\n  }\n\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {this} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  transform(source, destination) {\n    /** @type {import(\"../proj/Projection.js\").default} */\n    const sourceProj = getProjection(source);\n    const transformFn =\n      sourceProj.getUnits() == 'tile-pixels'\n        ? function (inCoordinates, outCoordinates, stride) {\n            const pixelExtent = sourceProj.getExtent();\n            const projectedExtent = sourceProj.getWorldExtent();\n            const scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n            composeTransform(\n              tmpTransform,\n              projectedExtent[0],\n              projectedExtent[3],\n              scale,\n              -scale,\n              0,\n              0,\n              0,\n            );\n            transform2D(\n              inCoordinates,\n              0,\n              inCoordinates.length,\n              stride,\n              tmpTransform,\n              outCoordinates,\n            );\n            return getTransform(sourceProj, destination)(\n              inCoordinates,\n              outCoordinates,\n              stride,\n            );\n          }\n        : getTransform(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  }\n}\n\nexport default Geometry;\n", "/**\n * @module ol/geom/SimpleGeometry\n */\nimport Geometry from './Geometry.js';\nimport {abstract} from '../util.js';\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\nimport {rotate, scale, transform2D, translate} from './flat/transform.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nclass SimpleGeometry extends Geometry {\n  constructor() {\n    super();\n\n    /**\n     * @protected\n     * @type {import(\"./Geometry.js\").GeometryLayout}\n     */\n    this.layout = 'XY';\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.flatCoordinates;\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromFlatCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * @abstract\n   * @return {Array<*> | null} Coordinates.\n   */\n  getCoordinates() {\n    return abstract();\n  }\n\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n   * @api\n   */\n  getFirstCoordinate() {\n    return this.flatCoordinates.slice(0, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  getFlatCoordinates() {\n    return this.flatCoordinates;\n  }\n\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\n   * @api\n   */\n  getLastCoordinate() {\n    return this.flatCoordinates.slice(\n      this.flatCoordinates.length - this.stride,\n    );\n  }\n\n  /**\n   * Return the {@link import(\"./Geometry.js\").GeometryLayout layout} of the geometry.\n   * @return {import(\"./Geometry.js\").GeometryLayout} Layout.\n   * @api\n   */\n  getLayout() {\n    return this.layout;\n  }\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker algorithm.\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   */\n  getSimplifiedGeometry(squaredTolerance) {\n    if (this.simplifiedGeometryRevision !== this.getRevision()) {\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (\n      squaredTolerance < 0 ||\n      (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n        squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)\n    ) {\n      return this;\n    }\n\n    const simplifiedGeometry =\n      this.getSimplifiedGeometryInternal(squaredTolerance);\n    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n      return simplifiedGeometry;\n    }\n    // Simplification did not actually remove any coordinates.  We now know\n    // that any calls to getSimplifiedGeometry with a squaredTolerance less\n    // than or equal to the current squaredTolerance will also not have any\n    // effect.  This allows us to short circuit simplification (saving CPU\n    // cycles) and prevents the cache of simplified geometries from filling\n    // up with useless identical copies of this geometry (saving memory).\n    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n    return this;\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    return this;\n  }\n\n  /**\n   * @return {number} Stride.\n   */\n  getStride() {\n    return this.stride;\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n  setFlatCoordinates(layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  }\n\n  /**\n   * @abstract\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  setCoordinates(coordinates, layout) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"./Geometry.js\").GeometryLayout|undefined} layout Layout.\n   * @param {Array<*>} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  setLayout(layout, coordinates, nesting) {\n    let stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (let i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = 'XY';\n          this.stride = 2;\n          return;\n        }\n        coordinates = /** @type {Array<unknown>} */ (coordinates[0]);\n      }\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  }\n\n  /**\n   * Apply a transform function to the coordinates of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform function.\n   * Called with a flat array of geometry coordinates.\n   * @api\n   */\n  applyTransform(transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  }\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @param {number} angle Rotation angle in counter-clockwise radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  rotate(angle, anchor) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      rotate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        angle,\n        anchor,\n        flatCoordinates,\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).\n   * @param {import(\"../coordinate.js\").Coordinate} [anchor] The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  scale(sx, sy, anchor) {\n    if (sy === undefined) {\n      sy = sx;\n    }\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      scale(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        sx,\n        sy,\n        anchor,\n        flatCoordinates,\n      );\n      this.changed();\n    }\n  }\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  translate(deltaX, deltaY) {\n    const flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      const stride = this.getStride();\n      translate(\n        flatCoordinates,\n        0,\n        flatCoordinates.length,\n        stride,\n        deltaX,\n        deltaY,\n        flatCoordinates,\n      );\n      this.changed();\n    }\n  }\n}\n\n/**\n * @param {number} stride Stride.\n * @return {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n */\nexport function getLayoutForStride(stride) {\n  let layout;\n  if (stride == 2) {\n    layout = 'XY';\n  } else if (stride == 3) {\n    layout = 'XYZ';\n  } else if (stride == 4) {\n    layout = 'XYZM';\n  }\n  return /** @type {import(\"./Geometry.js\").GeometryLayout} */ (layout);\n}\n\n/**\n * @param {import(\"./Geometry.js\").GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  let stride;\n  if (layout == 'XY') {\n    stride = 2;\n  } else if (layout == 'XYZ' || layout == 'XYM') {\n    stride = 3;\n  } else if (layout == 'XYZM') {\n    stride = 4;\n  }\n  return /** @type {number} */ (stride);\n}\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, dest) {\n  const flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  }\n  const stride = simpleGeometry.getStride();\n  return transform2D(\n    flatCoordinates,\n    0,\n    flatCoordinates.length,\n    stride,\n    transform,\n    dest,\n  );\n}\n\nexport default SimpleGeometry;\n", "/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(\n  flatCoordinates,\n  offset1,\n  offset2,\n  stride,\n  x,\n  y,\n  closestPoint,\n) {\n  const x1 = flatCoordinates[offset1];\n  const y1 = flatCoordinates[offset1 + 1];\n  const dx = flatCoordinates[offset2] - x1;\n  const dy = flatCoordinates[offset2 + 1] - y1;\n  let offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(\n          flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i],\n          t,\n        );\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (let i = 0; i < stride; ++i) {\n    closestPoint[i] = flatCoordinates[offset + i];\n  }\n  closestPoint.length = stride;\n}\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    const squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  max,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  max,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  let i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[offset],\n      flatCoordinates[offset + 1],\n    );\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  let index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates,\n      index - stride,\n      index,\n      stride,\n      x,\n      y,\n      tmpPoint,\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index +=\n        stride *\n        Math.max(\n          ((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) /\n            maxDelta) |\n            0,\n          1,\n        );\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates,\n      end - stride,\n      offset,\n      stride,\n      x,\n      y,\n      tmpPoint,\n    );\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint,\n    );\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>} [tmpPoint] Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  maxDelta,\n  isRing,\n  x,\n  y,\n  closestPoint,\n  minSquaredDistance,\n  tmpPoint,\n) {\n  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      maxDelta,\n      isRing,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n      tmpPoint,\n    );\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n", "/**\n * @module ol/geom/flat/deflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n  for (let i = 0, ii = coordinate.length; i < ii; ++i) {\n    flatCoordinates[offset++] = coordinate[i];\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(\n  flatCoordinates,\n  offset,\n  coordinates,\n  stride,\n) {\n  for (let i = 0, ii = coordinates.length; i < ii; ++i) {\n    const coordinate = coordinates[i];\n    for (let j = 0; j < stride; ++j) {\n      flatCoordinates[offset++] = coordinate[j];\n    }\n  }\n  return offset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>} [ends] Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatess,\n  stride,\n  ends,\n) {\n  ends = ends ? ends : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {\n    const end = deflateCoordinates(\n      flatCoordinates,\n      offset,\n      coordinatess[j],\n      stride,\n    );\n    ends[i++] = end;\n    offset = end;\n  }\n  ends.length = i;\n  return ends;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>} [endss] Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  coordinatesss,\n  stride,\n  endss,\n) {\n  endss = endss ? endss : [];\n  let i = 0;\n  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {\n    const ends = deflateCoordinatesArray(\n      flatCoordinates,\n      offset,\n      coordinatesss[j],\n      stride,\n      endss[i],\n    );\n    if (ends.length === 0) {\n      ends[0] = offset;\n    }\n    endss[i++] = ends;\n    offset = ends[ends.length - 1];\n  }\n  endss.length = i;\n  return endss;\n}\n", "/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredDistance, squaredSegmentDistance} from '../../math.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>} [simplifiedFlatCoordinates] Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  highQuality,\n  simplifiedFlatCoordinates,\n) {\n  simplifiedFlatCoordinates =\n    simplifiedFlatCoordinates !== undefined ? simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    squaredTolerance,\n    simplifiedFlatCoordinates,\n    0,\n  );\n  return simplifiedFlatCoordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  const n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  const markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  const stack = [offset, end - stride];\n  let index = 0;\n  while (stack.length > 0) {\n    const last = stack.pop();\n    const first = stack.pop();\n    let maxSquaredDistance = 0;\n    const x1 = flatCoordinates[first];\n    const y1 = flatCoordinates[first + 1];\n    const x2 = flatCoordinates[last];\n    const y2 = flatCoordinates[last + 1];\n    for (let i = first + stride; i < last; i += stride) {\n      const x = flatCoordinates[i];\n      const y = flatCoordinates[i + 1];\n      const squaredDistance = squaredSegmentDistance(x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (let i = 0; i < n; ++i) {\n    if (markers[i]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + i * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds,\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  squaredTolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n        flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  let x1 = flatCoordinates[offset];\n  let y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  let x2 = x1;\n  let y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  let x1 = snap(flatCoordinates[offset], tolerance);\n  let y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  let x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    const x3 = snap(flatCoordinates[offset], tolerance);\n    const y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    const dx1 = x2 - x1;\n    const dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    const dx2 = x3 - x1;\n    const dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if (\n      dx1 * dy2 == dy1 * dx2 &&\n      ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n      ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))\n    ) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEnds,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n    );\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  tolerance,\n  simplifiedFlatCoordinates,\n  simplifiedOffset,\n  simplifiedEndss,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      tolerance,\n      simplifiedFlatCoordinates,\n      simplifiedOffset,\n      simplifiedEnds,\n    );\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n", "/**\n * @module ol/geom/flat/inflate\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} [coordinates] Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  coordinates,\n) {\n  coordinates = coordinates !== undefined ? coordinates : [];\n  let i = 0;\n  for (let j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n  coordinates.length = i;\n  return coordinates;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} [coordinatess] Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  coordinatess,\n) {\n  coordinatess = coordinatess !== undefined ? coordinatess : [];\n  let i = 0;\n  for (let j = 0, jj = ends.length; j < jj; ++j) {\n    const end = ends[j];\n    coordinatess[i++] = inflateCoordinates(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      coordinatess[i],\n    );\n    offset = end;\n  }\n  coordinatess.length = i;\n  return coordinatess;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} [coordinatesss]\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  coordinatesss,\n) {\n  coordinatesss = coordinatesss !== undefined ? coordinatesss : [];\n  let i = 0;\n  for (let j = 0, jj = endss.length; j < jj; ++j) {\n    const ends = endss[j];\n    coordinatesss[i++] =\n      ends.length === 1 && ends[0] === offset\n        ? []\n        : inflateCoordinatesArray(\n            flatCoordinates,\n            offset,\n            ends,\n            stride,\n            coordinatesss[i],\n          );\n    offset = ends[ends.length - 1];\n  }\n  coordinatesss.length = i;\n  return coordinatesss;\n}\n", "/**\n * @module ol/geom/flat/area\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRing(flatCoordinates, offset, end, stride) {\n  let twiceArea = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    twiceArea += y1 * x2 - x1 * y2;\n    x1 = x2;\n    y1 = y2;\n  }\n  return twiceArea / 2;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRings(flatCoordinates, offset, ends, stride) {\n  let area = 0;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    area += linearRing(flatCoordinates, offset, end, stride);\n    offset = end;\n  }\n  return area;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  let area = 0;\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    area += linearRings(flatCoordinates, offset, ends, stride);\n    offset = ends[ends.length - 1];\n  }\n  return area;\n}\n", "/**\n * @module ol/geom/LinearRing\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {linearRing as linearRingArea} from './flat/area.js';\n\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\nclass LinearRing extends SimpleGeometry {\n  /**\n   * @param {Array<import(\"../coordinate.js\").Coordinate>|Array<number>} coordinates Coordinates.\n   *     For internal use, flat coordinates in combination with `layout` are also accepted.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n    } else {\n      this.setCoordinates(\n        /** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LinearRing} Clone.\n   * @api\n   */\n  clone() {\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        maxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.flatCoordinates.length,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * Return the area of the linear ring on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingArea(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * Return the coordinates of the linear ring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return inflateCoordinates(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n    );\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {LinearRing} Simplified LinearRing.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates,\n      0,\n      this.flatCoordinates.length,\n      this.stride,\n      squaredTolerance,\n      simplifiedFlatCoordinates,\n      0,\n    );\n    return new LinearRing(simplifiedFlatCoordinates, 'XY');\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'LinearRing';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return false;\n  }\n\n  /**\n   * Set the coordinates of the linear ring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default LinearRing;\n", "/**\n * @module ol/geom/Point\n */\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {containsXY, createOrUpdateFromCoordinate} from '../extent.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nclass Point extends SimpleGeometry {\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   */\n  constructor(coordinates, layout) {\n    super();\n    this.setCoordinates(coordinates, layout);\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @api\n   */\n  clone() {\n    const point = new Point(this.flatCoordinates.slice(), this.layout);\n    point.applyProperties(this);\n    return point;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    const flatCoordinates = this.flatCoordinates;\n    const squaredDistance = squaredDx(\n      x,\n      y,\n      flatCoordinates[0],\n      flatCoordinates[1],\n    );\n    if (squaredDistance < minSquaredDistance) {\n      const stride = this.stride;\n      for (let i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    }\n    return minSquaredDistance;\n  }\n\n  /**\n   * Return the coordinate of the point.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n   * @api\n   */\n  getCoordinates() {\n    return this.flatCoordinates.slice();\n  }\n\n  /**\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  computeExtent(extent) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Point';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  }\n\n  /**\n   * @param {!Array<*>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinate(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n    );\n    this.changed();\n  }\n}\n\nexport default Point;\n", "/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const outside = forEachCorner(\n    extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function (coordinate) {\n      return !linearRingContainsXY(\n        flatCoordinates,\n        offset,\n        end,\n        stride,\n        coordinate[0],\n        coordinate[1],\n      );\n    },\n  );\n  return !outside;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  x,\n  y,\n) {\n  // https://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  let wn = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  x,\n  y,\n) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  x,\n  y,\n) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n", "/**\n * @module ol/geom/flat/interiorpoint\n */\nimport {ascending} from '../../array.js';\nimport {linearRingsContainsXY} from './contains.js';\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>} [dest] Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  flatCenters,\n  flatCentersOffset,\n  dest,\n) {\n  let i, ii, x, x1, x2, y1, y2;\n  const y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n  const intersections = [];\n  // Calculate intersections with the horizontal line\n  for (let r = 0, rr = ends.length; r < rr; ++r) {\n    const end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n        x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  let pointX = NaN;\n  let maxSegmentLength = -Infinity;\n  intersections.sort(ascending);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    const segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (dest) {\n    dest.push(pointX, y, maxSegmentLength);\n    return dest;\n  }\n  return [pointX, y, maxSegmentLength];\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  flatCenters,\n) {\n  /** @type {Array<number>} */\n  let interiorPoints = [];\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(\n      flatCoordinates,\n      offset,\n      ends,\n      stride,\n      flatCenters,\n      2 * i,\n      interiorPoints,\n    );\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}\n", "/**\n * @module ol/geom/flat/segments\n */\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @return {T|boolean} Value.\n * @template T\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback) {\n  let ret;\n  offset += stride;\n  for (; offset < end; offset += stride) {\n    ret = callback(\n      flatCoordinates.slice(offset - stride, offset),\n      flatCoordinates.slice(offset, offset + stride),\n    );\n    if (ret) {\n      return ret;\n    }\n  }\n  return false;\n}\n", "/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {\n  containsExtent,\n  createEmpty,\n  extendFlatCoordinates,\n  intersects,\n  intersectsSegment,\n} from '../../extent.js';\nimport {forEach as forEachSegment} from './segments.js';\nimport {linearRingContainsExtent, linearRingContainsXY} from './contains.js';\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  const coordinatesExtent = extendFlatCoordinates(\n    createEmpty(),\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n  );\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (containsExtent(extent, coordinatesExtent)) {\n    return true;\n  }\n  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n  return forEachSegment(\n    flatCoordinates,\n    offset,\n    end,\n    stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function (point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    },\n  );\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    if (\n      intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(\n  flatCoordinates,\n  offset,\n  end,\n  stride,\n  extent,\n) {\n  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[0],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[1],\n    )\n  ) {\n    return true;\n  }\n  if (\n    linearRingContainsXY(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n      extent[2],\n      extent[3],\n    )\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  extent,\n) {\n  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (let i = 1, ii = ends.length; i < ii; ++i) {\n    if (\n      linearRingContainsExtent(\n        flatCoordinates,\n        ends[i - 1],\n        ends[i],\n        stride,\n        extent,\n      )\n    ) {\n      if (\n        !intersectsLineString(\n          flatCoordinates,\n          ends[i - 1],\n          ends[i],\n          stride,\n          extent,\n        )\n      ) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  extent,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (\n      intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)\n    ) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n", "/**\n * @module ol/geom/flat/reverse\n */\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nexport function coordinates(flatCoordinates, offset, end, stride) {\n  while (offset < end - stride) {\n    for (let i = 0; i < stride; ++i) {\n      const tmp = flatCoordinates[offset + i];\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n      flatCoordinates[end - stride + i] = tmp;\n    }\n    offset += stride;\n    end -= stride;\n  }\n}\n", "/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from './reverse.js';\n\n/**\n * Is the linear ring oriented clockwise in a coordinate system with a bottom-left\n * coordinate origin? For a coordinate system with a top-left coordinate origin,\n * the ring's orientation is clockwise when this function returns false.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean|undefined} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // https://stackoverflow.com/q/1165647/clockwise-method#1165943\n  // https://github.com/OSGeo/gdal/blob/master/gdal/ogr/ogrlinearring.cpp\n  let edge = 0;\n  let x1 = flatCoordinates[end - stride];\n  let y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    const x2 = flatCoordinates[offset];\n    const y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge === 0 ? undefined : edge > 0;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right,\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n    );\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingssAreOriented(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    const ends = endss[i];\n    if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, right)) {\n      return false;\n    }\n    if (ends.length) {\n      offset = ends[ends.length - 1];\n    }\n  }\n  return true;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(\n  flatCoordinates,\n  offset,\n  ends,\n  stride,\n  right,\n) {\n  right = right !== undefined ? right : false;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    const isClockwise = linearRingIsClockwise(\n      flatCoordinates,\n      offset,\n      end,\n      stride,\n    );\n    const reverse =\n      i === 0\n        ? (right && isClockwise) || (!right && !isClockwise)\n        : (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean} [right] Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(\n  flatCoordinates,\n  offset,\n  endss,\n  stride,\n  right,\n) {\n  for (let i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates,\n      offset,\n      endss[i],\n      stride,\n      right,\n    );\n  }\n  return offset;\n}\n\n/**\n * Return a two-dimensional endss\n * @param {Array<number>} flatCoordinates Flat coordinates\n * @param {Array<number>} ends Linear ring end indexes\n * @return {Array<Array<number>>} Two dimensional endss array that can\n * be used to construct a MultiPolygon\n */\nexport function inflateEnds(flatCoordinates, ends) {\n  const endss = [];\n  let offset = 0;\n  let prevEndIndex = 0;\n  let startOrientation;\n  for (let i = 0, ii = ends.length; i < ii; ++i) {\n    const end = ends[i];\n    // classifies an array of rings into polygons with outer rings and holes\n    const orientation = linearRingIsClockwise(flatCoordinates, offset, end, 2);\n    if (startOrientation === undefined) {\n      startOrientation = orientation;\n    }\n    if (orientation === startOrientation) {\n      endss.push(ends.slice(prevEndIndex, i + 1));\n    } else {\n      if (endss.length === 0) {\n        continue;\n      }\n      endss[endss.length - 1].push(ends[prevEndIndex]);\n    }\n    prevEndIndex = i + 1;\n    offset = end;\n  }\n  return endss;\n}\n", "/**\n * @module ol/geom/Polygon\n */\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {arrayMaxSquaredDelta, assignClosestArrayPoint} from './flat/closest.js';\nimport {closestSquaredDistanceXY, getCenter, isEmpty} from '../extent.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {extend} from '../array.js';\nimport {getInteriorPointOfArray} from './flat/interiorpoint.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {intersectsLinearRingArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRings} from './flat/orient.js';\nimport {linearRings as linearRingsArea} from './flat/area.js';\nimport {linearRingsContainsXY} from './flat/contains.js';\nimport {modulo} from '../math.js';\nimport {quantizeArray} from './flat/simplify.js';\nimport {offset as sphereOffset} from '../sphere.js';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nclass Polygon extends SimpleGeometry {\n  /**\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>|!Array<number>} coordinates\n   *     Array of linear rings that define the polygon. The first linear ring of the\n   *     array defines the outer-boundary or surface of the polygon. Each subsequent\n   *     linear ring defines a hole in the surface of the polygon. A linear ring is\n   *     an array of vertices' coordinates where the first coordinate and the last are\n   *     equivalent. (For internal use, flat coordinates in combination with\n   *     `layout` and `ends` are also accepted.)\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).\n   */\n  constructor(coordinates, layout, ends) {\n    super();\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate|null}\n     */\n    this.flatInteriorPoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>|null}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (layout !== undefined && ends) {\n      this.setFlatCoordinates(\n        layout,\n        /** @type {Array<number>} */ (coordinates),\n      );\n      this.ends_ = ends;\n    } else {\n      this.setCoordinates(\n        /** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (\n          coordinates\n        ),\n        layout,\n      );\n    }\n  }\n\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {LinearRing} linearRing Linear ring.\n   * @api\n   */\n  appendLinearRing(linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  }\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Polygon} Clone.\n   * @api\n   */\n  clone() {\n    const polygon = new Polygon(\n      this.flatCoordinates.slice(),\n      this.layout,\n      this.ends_.slice(),\n    );\n    polygon.applyProperties(this);\n    return polygon;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  closestPointXY(x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(\n        arrayMaxSquaredDelta(\n          this.flatCoordinates,\n          0,\n          this.ends_,\n          this.stride,\n          0,\n        ),\n      );\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      this.maxDelta_,\n      true,\n      x,\n      y,\n      closestPoint,\n      minSquaredDistance,\n    );\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  containsXY(x, y) {\n    return linearRingsContainsXY(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      x,\n      y,\n    );\n  }\n\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  getArea() {\n    return linearRingsArea(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n    );\n  }\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean} [right] Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @api\n   */\n  getCoordinates(right) {\n    let flatCoordinates;\n    if (right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);\n  }\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  getEnds() {\n    return this.ends_;\n  }\n\n  /**\n   * @return {Array<number>} Interior point.\n   */\n  getFlatInteriorPoint() {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      const flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\n        this.getOrientedFlatCoordinates(),\n        0,\n        this.ends_,\n        this.stride,\n        flatCenter,\n        0,\n      );\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n    return /** @type {import(\"../coordinate.js\").Coordinate} */ (\n      this.flatInteriorPoint_\n    );\n  }\n\n  /**\n   * Return an interior point of the polygon.\n   * @return {Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  getInteriorPoint() {\n    return new Point(this.getFlatInteriorPoint(), 'XYM');\n  }\n\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n  getLinearRingCount() {\n    return this.ends_.length;\n  }\n\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {LinearRing|null} Linear ring.\n   * @api\n   */\n  getLinearRing(index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LinearRing(\n      this.flatCoordinates.slice(\n        index === 0 ? 0 : this.ends_[index - 1],\n        this.ends_[index],\n      ),\n      this.layout,\n    );\n  }\n\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array<LinearRing>} Linear rings.\n   * @api\n   */\n  getLinearRings() {\n    const layout = this.layout;\n    const flatCoordinates = this.flatCoordinates;\n    const ends = this.ends_;\n    const linearRings = [];\n    let offset = 0;\n    for (let i = 0, ii = ends.length; i < ii; ++i) {\n      const end = ends[i];\n      const linearRing = new LinearRing(\n        flatCoordinates.slice(offset, end),\n        layout,\n      );\n      linearRings.push(linearRing);\n      offset = end;\n    }\n    return linearRings;\n  }\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  getOrientedFlatCoordinates() {\n    if (this.orientedRevision_ != this.getRevision()) {\n      const flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length = orientLinearRings(\n          this.orientedFlatCoordinates_,\n          0,\n          this.ends_,\n          this.stride,\n        );\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return /** @type {Array<number>} */ (this.orientedFlatCoordinates_);\n  }\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Polygon} Simplified Polygon.\n   * @protected\n   */\n  getSimplifiedGeometryInternal(squaredTolerance) {\n    /** @type {Array<number>} */\n    const simplifiedFlatCoordinates = [];\n    /** @type {Array<number>} */\n    const simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(\n      this.flatCoordinates,\n      0,\n      this.ends_,\n      this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates,\n      0,\n      simplifiedEnds,\n    );\n    return new Polygon(simplifiedFlatCoordinates, 'XY', simplifiedEnds);\n  }\n\n  /**\n   * Get the type of this geometry.\n   * @return {import(\"./Geometry.js\").Type} Geometry type.\n   * @api\n   */\n  getType() {\n    return 'Polygon';\n  }\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   * @api\n   */\n  intersectsExtent(extent) {\n    return intersectsLinearRingArray(\n      this.getOrientedFlatCoordinates(),\n      0,\n      this.ends_,\n      this.stride,\n      extent,\n    );\n  }\n\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {import(\"./Geometry.js\").GeometryLayout} [layout] Layout.\n   * @api\n   */\n  setCoordinates(coordinates, layout) {\n    this.setLayout(layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    const ends = deflateCoordinatesArray(\n      this.flatCoordinates,\n      0,\n      coordinates,\n      this.stride,\n      this.ends_,\n    );\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  }\n}\n\nexport default Polygon;\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices in meters.\n * @param {number} [n] Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number} [sphereRadius] Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, n, sphereRadius) {\n  n = n ? n : 32;\n  /** @type {Array<number>} */\n  const flatCoordinates = [];\n  for (let i = 0; i < n; ++i) {\n    extend(\n      flatCoordinates,\n      sphereOffset(center, radius, (2 * Math.PI * i) / n, sphereRadius),\n    );\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\n}\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n  if (isEmpty(extent)) {\n    throw new Error('Cannot create polygon from empty extent');\n  }\n  const minX = extent[0];\n  const minY = extent[1];\n  const maxX = extent[2];\n  const maxY = extent[3];\n  const flatCoordinates = [\n    minX,\n    minY,\n    minX,\n    maxY,\n    maxX,\n    maxY,\n    maxX,\n    minY,\n    minX,\n    minY,\n  ];\n  return new Polygon(flatCoordinates, 'XY', [flatCoordinates.length]);\n}\n\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number} [sides] Number of sides of the polygon. Default is 32.\n * @param {number} [angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, sides, angle) {\n  sides = sides ? sides : 32;\n  const stride = circle.getStride();\n  const layout = circle.getLayout();\n  const center = circle.getCenter();\n  const arrayLength = stride * (sides + 1);\n  const flatCoordinates = new Array(arrayLength);\n  for (let i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n    for (let j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n  const ends = [flatCoordinates.length];\n  const polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), angle);\n  return polygon;\n}\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number} [angle] Start angle for the first vertex of the polygon in\n *     counter-clockwise radians. 0 means East. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, angle) {\n  const flatCoordinates = polygon.getFlatCoordinates();\n  const stride = polygon.getStride();\n  const sides = flatCoordinates.length / stride - 1;\n  const startAngle = angle ? angle : 0;\n  for (let i = 0; i <= sides; ++i) {\n    const offset = i * stride;\n    const angle = startAngle + (modulo(i, sides) * 2 * Math.PI) / sides;\n    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);\n    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);\n  }\n  polygon.changed();\n}\n", "/**\n * @module ol/render/Box\n */\n\nimport Disposable from '../Disposable.js';\nimport Polygon from '../geom/Polygon.js';\n\nclass RenderBox extends Disposable {\n  /**\n   * @param {string} className CSS class name.\n   */\n  constructor(className) {\n    super();\n\n    /**\n     * @type {import(\"../geom/Polygon.js\").default}\n     * @private\n     */\n    this.geometry_ = null;\n\n    /**\n     * @type {HTMLDivElement}\n     * @private\n     */\n    this.element_ = document.createElement('div');\n    this.element_.style.position = 'absolute';\n    this.element_.style.pointerEvents = 'auto';\n    this.element_.className = 'ol-box ' + className;\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default|null}\n     */\n    this.map_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../pixel.js\").Pixel}\n     */\n    this.startPixel_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../pixel.js\").Pixel}\n     */\n    this.endPixel_ = null;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.setMap(null);\n  }\n\n  /**\n   * @private\n   */\n  render_() {\n    const startPixel = this.startPixel_;\n    const endPixel = this.endPixel_;\n    const px = 'px';\n    const style = this.element_.style;\n    style.left = Math.min(startPixel[0], endPixel[0]) + px;\n    style.top = Math.min(startPixel[1], endPixel[1]) + px;\n    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;\n    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;\n  }\n\n  /**\n   * @param {import(\"../Map.js\").default|null} map Map.\n   */\n  setMap(map) {\n    if (this.map_) {\n      this.map_.getOverlayContainer().removeChild(this.element_);\n      const style = this.element_.style;\n      style.left = 'inherit';\n      style.top = 'inherit';\n      style.width = 'inherit';\n      style.height = 'inherit';\n    }\n    this.map_ = map;\n    if (this.map_) {\n      this.map_.getOverlayContainer().appendChild(this.element_);\n    }\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} startPixel Start pixel.\n   * @param {import(\"../pixel.js\").Pixel} endPixel End pixel.\n   */\n  setPixels(startPixel, endPixel) {\n    this.startPixel_ = startPixel;\n    this.endPixel_ = endPixel;\n    this.createOrUpdateGeometry();\n    this.render_();\n  }\n\n  /**\n   * Creates or updates the cached geometry.\n   */\n  createOrUpdateGeometry() {\n    const startPixel = this.startPixel_;\n    const endPixel = this.endPixel_;\n    const pixels = [\n      startPixel,\n      [startPixel[0], endPixel[1]],\n      endPixel,\n      [endPixel[0], startPixel[1]],\n    ];\n    const coordinates = pixels.map(\n      this.map_.getCoordinateFromPixelInternal,\n      this.map_,\n    );\n    // close the polygon\n    coordinates[4] = coordinates[0].slice();\n    if (!this.geometry_) {\n      this.geometry_ = new Polygon([coordinates]);\n    } else {\n      this.geometry_.setCoordinates([coordinates]);\n    }\n  }\n\n  /**\n   * @return {import(\"../geom/Polygon.js\").default} Geometry.\n   */\n  getGeometry() {\n    return this.geometry_;\n  }\n}\n\nexport default RenderBox;\n", "/**\n * @module ol/interaction/DragBox\n */\n// FIXME draw drag box\nimport Event from '../events/Event.js';\nimport PointerInteraction from './Pointer.js';\nimport RenderBox from '../render/Box.js';\nimport {mouseActionButton} from '../events/condition.js';\n\n/**\n * A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,\n * true should be returned.\n * @typedef {function(this: ?, import(\"../MapBrowserEvent.js\").default, import(\"../pixel.js\").Pixel, import(\"../pixel.js\").Pixel):boolean} EndCondition\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragbox'] CSS class name for styling the box.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean\n * to indicate whether that event should be handled.\n * Default is {@link ol/events/condition~mouseActionButton}.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default\n * `boxEndCondition` function.\n * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two\n * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.\n * Default is `true` if the area of the box is bigger than the `minArea` option.\n * @property {function(this:DragBox, import(\"../MapBrowserEvent.js\").default):void} [onBoxEnd] Code to execute just\n * before `boxend` is fired.\n */\n\n/**\n * @enum {string}\n */\nconst DragBoxEventType = {\n  /**\n   * Triggered upon drag box start.\n   * @event DragBoxEvent#boxstart\n   * @api\n   */\n  BOXSTART: 'boxstart',\n\n  /**\n   * Triggered on drag when box is active.\n   * @event DragBoxEvent#boxdrag\n   * @api\n   */\n  BOXDRAG: 'boxdrag',\n\n  /**\n   * Triggered upon drag box end.\n   * @event DragBoxEvent#boxend\n   * @api\n   */\n  BOXEND: 'boxend',\n\n  /**\n   * Triggered upon drag box canceled.\n   * @event DragBoxEvent#boxcancel\n   * @api\n   */\n  BOXCANCEL: 'boxcancel',\n};\n\n/**\n * @classdesc\n * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of\n * this type.\n */\nexport class DragBoxEvent extends Event {\n  /**\n   * @param {string} type The event type.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate The event coordinate.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Originating event.\n   */\n  constructor(type, coordinate, mapBrowserEvent) {\n    super(type);\n\n    /**\n     * The coordinate of the drag event.\n     * @const\n     * @type {import(\"../coordinate.js\").Coordinate}\n     * @api\n     */\n    this.coordinate = coordinate;\n\n    /**\n     * @const\n     * @type {import(\"../MapBrowserEvent.js\").default}\n     * @api\n     */\n    this.mapBrowserEvent = mapBrowserEvent;\n  }\n}\n\n/***\n * @template Return\n * @typedef {import(\"../Observable\").OnSignature<import(\"../Observable\").EventTypes, import(\"../events/Event.js\").default, Return> &\n *   import(\"../Observable\").OnSignature<import(\"../ObjectEventType\").Types|\n *     'change:active', import(\"../Object\").ObjectEvent, Return> &\n *   import(\"../Observable\").OnSignature<'boxcancel'|'boxdrag'|'boxend'|'boxstart', DragBoxEvent, Return> &\n *   import(\"../Observable\").CombinedOnSignature<import(\"../Observable\").EventTypes|import(\"../ObjectEventType\").Types|\n *     'change:active'|'boxcancel'|'boxdrag'|'boxend', Return>} DragBoxOnSignature\n */\n\n/**\n * @classdesc\n * Allows the user to draw a vector box by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when the shift or other key is held down. This is used, for example,\n * for zooming to a specific area of the map\n * (see {@link module:ol/interaction/DragZoom~DragZoom} and\n * {@link module:ol/interaction/DragRotateAndZoom~DragRotateAndZoom}).\n *\n * @fires DragBoxEvent\n * @api\n */\nclass DragBox extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    /***\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.on;\n\n    /***\n     * @type {DragBoxOnSignature<import(\"../events\").EventsKey>}\n     */\n    this.once;\n\n    /***\n     * @type {DragBoxOnSignature<void>}\n     */\n    this.un;\n\n    options = options ? options : {};\n\n    /**\n     * @type {import(\"../render/Box.js\").default}\n     * @private\n     */\n    this.box_ = new RenderBox(options.className || 'ol-dragbox');\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.minArea_ = options.minArea !== undefined ? options.minArea : 64;\n\n    if (options.onBoxEnd) {\n      this.onBoxEnd = options.onBoxEnd;\n    }\n\n    /**\n     * @type {import(\"../pixel.js\").Pixel}\n     * @private\n     */\n    this.startPixel_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition ? options.condition : mouseActionButton;\n\n    /**\n     * @private\n     * @type {EndCondition}\n     */\n    this.boxEndCondition_ = options.boxEndCondition\n      ? options.boxEndCondition\n      : this.defaultBoxEndCondition;\n  }\n\n  /**\n   * The default condition for determining whether the boxend event\n   * should fire.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent The originating MapBrowserEvent\n   *     leading to the box end.\n   * @param {import(\"../pixel.js\").Pixel} startPixel The starting pixel of the box.\n   * @param {import(\"../pixel.js\").Pixel} endPixel The end pixel of the box.\n   * @return {boolean} Whether or not the boxend condition should be fired.\n   */\n  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {\n    const width = endPixel[0] - startPixel[0];\n    const height = endPixel[1] - startPixel[1];\n    return width * width + height * height >= this.minArea_;\n  }\n\n  /**\n   * Returns geometry of last drawn box.\n   * @return {import(\"../geom/Polygon.js\").default} Geometry.\n   * @api\n   */\n  getGeometry() {\n    return this.box_.getGeometry();\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);\n\n    this.dispatchEvent(\n      new DragBoxEvent(\n        DragBoxEventType.BOXDRAG,\n        mapBrowserEvent.coordinate,\n        mapBrowserEvent,\n      ),\n    );\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    this.box_.setMap(null);\n\n    const completeBox = this.boxEndCondition_(\n      mapBrowserEvent,\n      this.startPixel_,\n      mapBrowserEvent.pixel,\n    );\n    if (completeBox) {\n      this.onBoxEnd(mapBrowserEvent);\n    }\n    this.dispatchEvent(\n      new DragBoxEvent(\n        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,\n        mapBrowserEvent.coordinate,\n        mapBrowserEvent,\n      ),\n    );\n    return false;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.condition_(mapBrowserEvent)) {\n      this.startPixel_ = mapBrowserEvent.pixel;\n      this.box_.setMap(mapBrowserEvent.map);\n      this.box_.setPixels(this.startPixel_, this.startPixel_);\n      this.dispatchEvent(\n        new DragBoxEvent(\n          DragBoxEventType.BOXSTART,\n          mapBrowserEvent.coordinate,\n          mapBrowserEvent,\n        ),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Function to execute just before `onboxend` is fired\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  onBoxEnd(event) {}\n}\n\nexport default DragBox;\n", "/**\n * @module ol/interaction/DragZoom\n */\nimport DragBox from './DragBox.js';\nimport {easeOut} from '../easing.js';\nimport {shiftKeyOnly} from '../events/condition.js';\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-dragzoom'] CSS class name for styling the\n * box.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled.\n * Default is {@link module:ol/events/condition.shiftKeyOnly}.\n * @property {number} [duration=200] Animation duration in milliseconds.\n * @property {boolean} [out=false] Use interaction for zooming out.\n * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default\n * `boxEndCondition` function.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by clicking and dragging on the map,\n * normally combined with an {@link module:ol/events/condition} that limits\n * it to when a key, shift by default, is held down.\n *\n * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or\n * your custom one configured with `className`.\n * @api\n */\nclass DragZoom extends DragBox {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const condition = options.condition ? options.condition : shiftKeyOnly;\n\n    super({\n      condition: condition,\n      className: options.className || 'ol-dragzoom',\n      minArea: options.minArea,\n    });\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 200;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.out_ = options.out !== undefined ? options.out : false;\n  }\n\n  /**\n   * Function to execute just before `onboxend` is fired\n   * @param {import(\"../MapBrowserEvent.js\").default} event Event.\n   */\n  onBoxEnd(event) {\n    const map = this.getMap();\n    const view = /** @type {!import(\"../View.js\").default} */ (map.getView());\n    let geometry = this.getGeometry();\n\n    if (this.out_) {\n      const rotatedExtent = view.rotatedExtentForGeometry(geometry);\n      const resolution = view.getResolutionForExtentInternal(rotatedExtent);\n      const factor = view.getResolution() / resolution;\n      geometry = geometry.clone();\n      geometry.scale(factor * factor);\n    }\n\n    view.fitInternal(geometry, {\n      duration: this.duration_,\n      easing: easeOut,\n    });\n  }\n}\n\nexport default DragZoom;\n", "/**\n * @module ol/events/Key\n */\n\n/**\n * @enum {string}\n * @const\n */\nexport default {\n  LEFT: 'ArrowLeft',\n  UP: 'ArrowUp',\n  RIGHT: 'ArrowRight',\n  DOWN: 'ArrowDown',\n};\n", "/**\n * @module ol/interaction/KeyboardPan\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, {pan} from './Interaction.js';\nimport Key from '../events/Key.js';\nimport {noModifierKeys, targetNotEditable} from '../events/condition.js';\nimport {rotate as rotateCoordinate} from '../coordinate.js';\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.noModifierKeys} and\n * {@link module:ol/events/condition.targetNotEditable}.\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {number} [pixelDelta=128] The amount of pixels to pan on each key\n * press.\n */\n\n/**\n * @classdesc\n * Allows the user to pan the map using keyboard arrows.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.\n * @api\n */\nclass KeyboardPan extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * @private\n     * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Browser event.\n     * @return {boolean} Combined condition result.\n     */\n    this.defaultCondition_ = function (mapBrowserEvent) {\n      return (\n        noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent)\n      );\n    };\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ =\n      options.condition !== undefined\n        ? options.condition\n        : this.defaultCondition_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelDelta_ =\n      options.pixelDelta !== undefined ? options.pixelDelta : 128;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides the direction to pan to (if an arrow key was\n   * pressed).\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (mapBrowserEvent.type == EventType.KEYDOWN) {\n      const keyEvent = /** @type {KeyboardEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const key = keyEvent.key;\n      if (\n        this.condition_(mapBrowserEvent) &&\n        (key == Key.DOWN ||\n          key == Key.LEFT ||\n          key == Key.RIGHT ||\n          key == Key.UP)\n      ) {\n        const map = mapBrowserEvent.map;\n        const view = map.getView();\n        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;\n        let deltaX = 0,\n          deltaY = 0;\n        if (key == Key.DOWN) {\n          deltaY = -mapUnitsDelta;\n        } else if (key == Key.LEFT) {\n          deltaX = -mapUnitsDelta;\n        } else if (key == Key.RIGHT) {\n          deltaX = mapUnitsDelta;\n        } else {\n          deltaY = mapUnitsDelta;\n        }\n        const delta = [deltaX, deltaY];\n        rotateCoordinate(delta, view.getRotation());\n        pan(view, delta, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\n\nexport default KeyboardPan;\n", "/**\n * @module ol/interaction/KeyboardZoom\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, {zoomByDelta} from './Interaction.js';\nimport {platformModifierKey, targetNotEditable} from '../events/condition.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=100] Animation duration in milliseconds.\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. The default condition is\n * that {@link module:ol/events/condition.targetNotEditable} is fulfilled and that\n * the platform modifier key isn't pressed\n * (!{@link module:ol/events/condition.platformModifierKey}).\n * @property {number} [delta=1] The zoom level delta on each key press.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map using keyboard + and -.\n * Note that, although this interaction is by default included in maps,\n * the keys can only be used when browser focus is on the element to which\n * the keyboard events are attached. By default, this is the map div,\n * though you can change this with the `keyboardEventTarget` in\n * {@link module:ol/Map~Map}. `document` never loses focus but, for any other\n * element, focus will have to be on, and returned to, this element if the keys\n * are to function.\n * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.\n * @api\n */\nclass KeyboardZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.condition\n      ? options.condition\n      : function (mapBrowserEvent) {\n          return (\n            !platformModifierKey(mapBrowserEvent) &&\n            targetNotEditable(mapBrowserEvent)\n          );\n        };\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.delta_ = options.delta ? options.delta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 100;\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a\n   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the\n   * key pressed was '+' or '-').\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    let stopEvent = false;\n    if (\n      mapBrowserEvent.type == EventType.KEYDOWN ||\n      mapBrowserEvent.type == EventType.KEYPRESS\n    ) {\n      const keyEvent = /** @type {KeyboardEvent} */ (\n        mapBrowserEvent.originalEvent\n      );\n      const key = keyEvent.key;\n      if (this.condition_(mapBrowserEvent) && (key === '+' || key === '-')) {\n        const map = mapBrowserEvent.map;\n        const delta = key === '+' ? this.delta_ : -this.delta_;\n        const view = map.getView();\n        zoomByDelta(view, delta, undefined, this.duration_);\n        keyEvent.preventDefault();\n        stopEvent = true;\n      }\n    }\n    return !stopEvent;\n  }\n}\n\nexport default KeyboardZoom;\n", "/**\n * @module ol/Kinetic\n */\n\n/**\n * @classdesc\n * Implementation of inertial deceleration for map movement.\n *\n * @api\n */\nclass Kinetic {\n  /**\n   * @param {number} decay Rate of decay (must be negative).\n   * @param {number} minVelocity Minimum velocity (pixels/millisecond).\n   * @param {number} delay Delay to consider to calculate the kinetic\n   *     initial values (milliseconds).\n   */\n  constructor(decay, minVelocity, delay) {\n    /**\n     * @private\n     * @type {number}\n     */\n    this.decay_ = decay;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.minVelocity_ = minVelocity;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.delay_ = delay;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.points_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.angle_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.initialVelocity_ = 0;\n  }\n\n  /**\n   * FIXME empty description for jsdoc\n   */\n  begin() {\n    this.points_.length = 0;\n    this.angle_ = 0;\n    this.initialVelocity_ = 0;\n  }\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   */\n  update(x, y) {\n    this.points_.push(x, y, Date.now());\n  }\n\n  /**\n   * @return {boolean} Whether we should do kinetic animation.\n   */\n  end() {\n    if (this.points_.length < 6) {\n      // at least 2 points are required (i.e. there must be at least 6 elements\n      // in the array)\n      return false;\n    }\n    const delay = Date.now() - this.delay_;\n    const lastIndex = this.points_.length - 3;\n    if (this.points_[lastIndex + 2] < delay) {\n      // the last tracked point is too old, which means that the user stopped\n      // panning before releasing the map\n      return false;\n    }\n\n    // get the first point which still falls into the delay time\n    let firstIndex = lastIndex - 3;\n    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {\n      firstIndex -= 3;\n    }\n\n    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];\n    // we don't want a duration of 0 (divide by zero)\n    // we also make sure the user panned for a duration of at least one frame\n    // (1/60s) to compute sane displacement values\n    if (duration < 1000 / 60) {\n      return false;\n    }\n\n    const dx = this.points_[lastIndex] - this.points_[firstIndex];\n    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];\n    this.angle_ = Math.atan2(dy, dx);\n    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;\n    return this.initialVelocity_ > this.minVelocity_;\n  }\n\n  /**\n   * @return {number} Total distance travelled (pixels).\n   */\n  getDistance() {\n    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;\n  }\n\n  /**\n   * @return {number} Angle of the kinetic panning animation (radians).\n   */\n  getAngle() {\n    return this.angle_;\n  }\n}\n\nexport default Kinetic;\n", "/**\n * @module ol/interaction/MouseWheelZoom\n */\nimport EventType from '../events/EventType.js';\nimport Interaction, {zoomByDelta} from './Interaction.js';\nimport {DEVICE_PIXEL_RATIO, FIREFOX} from '../has.js';\nimport {all, always, focusWithTabindex} from '../events/condition.js';\nimport {clamp} from '../math.js';\n\n/**\n * @typedef {'trackpad' | 'wheel'} Mode\n */\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../events/condition.js\").Condition} [condition] A function that\n * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a\n * boolean to indicate whether that event should be handled. Default is\n * {@link module:ol/events/condition.always}.\n * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,\n * the interaction will only handle events when the map has the focus.\n * @property {number} [maxDelta=1] Maximum mouse wheel delta.\n * @property {number} [duration=250] Animation duration in milliseconds.\n * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.\n * @property {boolean} [useAnchor=true] Enable zooming using the mouse's\n * location as the anchor. When set to `false`, zooming in and out will zoom to\n * the center of the screen instead of zooming on the mouse's location.\n * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom\n * event will always animate to the closest zoom level after an interaction;\n * false means intermediary zoom levels are allowed.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by scrolling the mouse wheel.\n * @api\n */\nclass MouseWheelZoom extends Interaction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    super(\n      /** @type {import(\"./Interaction.js\").InteractionOptions} */ (options),\n    );\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.totalDelta_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastDelta_ = 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.timeout_ = options.timeout !== undefined ? options.timeout : 80;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.useAnchor_ =\n      options.useAnchor !== undefined ? options.useAnchor : true;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.constrainResolution_ =\n      options.constrainResolution !== undefined\n        ? options.constrainResolution\n        : false;\n\n    const condition = options.condition ? options.condition : always;\n\n    /**\n     * @private\n     * @type {import(\"../events/condition.js\").Condition}\n     */\n    this.condition_ = options.onFocusOnly\n      ? all(focusWithTabindex, condition)\n      : condition;\n\n    /**\n     * @private\n     * @type {?import(\"../coordinate.js\").Coordinate}\n     */\n    this.lastAnchor_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.startTime_ = undefined;\n\n    /**\n     * @private\n     * @type {ReturnType<typeof setTimeout>}\n     */\n    this.timeoutId_;\n\n    /**\n     * @private\n     * @type {Mode|undefined}\n     */\n    this.mode_ = undefined;\n\n    /**\n     * Trackpad events separated by this delay will be considered separate\n     * interactions.\n     * @private\n     * @type {number}\n     */\n    this.trackpadEventGap_ = 400;\n\n    /**\n     * @private\n     * @type {ReturnType<typeof setTimeout>}\n     */\n    this.trackpadTimeoutId_;\n\n    /**\n     * The number of delta values per zoom level\n     * @private\n     * @type {number}\n     */\n    this.deltaPerZoom_ = 300;\n  }\n\n  /**\n   * @private\n   */\n  endInteraction_() {\n    this.trackpadTimeoutId_ = undefined;\n    const map = this.getMap();\n    if (!map) {\n      return;\n    }\n    const view = map.getView();\n    view.endInteraction(\n      undefined,\n      this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0,\n      this.lastAnchor_,\n    );\n  }\n\n  /**\n   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually\n   * zooms the map.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Map browser event.\n   * @return {boolean} `false` to stop event propagation.\n   */\n  handleEvent(mapBrowserEvent) {\n    if (!this.condition_(mapBrowserEvent)) {\n      return true;\n    }\n    const type = mapBrowserEvent.type;\n    if (type !== EventType.WHEEL) {\n      return true;\n    }\n\n    const map = mapBrowserEvent.map;\n    const wheelEvent = /** @type {WheelEvent} */ (\n      mapBrowserEvent.originalEvent\n    );\n    wheelEvent.preventDefault();\n\n    if (this.useAnchor_) {\n      this.lastAnchor_ = mapBrowserEvent.coordinate;\n    }\n\n    // Delta normalisation inspired by\n    // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js\n    let delta;\n    if (mapBrowserEvent.type == EventType.WHEEL) {\n      delta = wheelEvent.deltaY;\n      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {\n        delta /= DEVICE_PIXEL_RATIO;\n      }\n      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {\n        delta *= 40;\n      }\n    }\n\n    if (delta === 0) {\n      return false;\n    }\n    this.lastDelta_ = delta;\n\n    const now = Date.now();\n\n    if (this.startTime_ === undefined) {\n      this.startTime_ = now;\n    }\n\n    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {\n      this.mode_ = Math.abs(delta) < 4 ? 'trackpad' : 'wheel';\n    }\n\n    const view = map.getView();\n    if (\n      this.mode_ === 'trackpad' &&\n      !(view.getConstrainResolution() || this.constrainResolution_)\n    ) {\n      if (this.trackpadTimeoutId_) {\n        clearTimeout(this.trackpadTimeoutId_);\n      } else {\n        if (view.getAnimating()) {\n          view.cancelAnimations();\n        }\n        view.beginInteraction();\n      }\n      this.trackpadTimeoutId_ = setTimeout(\n        this.endInteraction_.bind(this),\n        this.timeout_,\n      );\n      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);\n      this.startTime_ = now;\n      return false;\n    }\n\n    this.totalDelta_ += delta;\n\n    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);\n\n    clearTimeout(this.timeoutId_);\n    this.timeoutId_ = setTimeout(\n      this.handleWheelZoom_.bind(this, map),\n      timeLeft,\n    );\n\n    return false;\n  }\n\n  /**\n   * @private\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  handleWheelZoom_(map) {\n    const view = map.getView();\n    if (view.getAnimating()) {\n      view.cancelAnimations();\n    }\n    let delta =\n      -clamp(\n        this.totalDelta_,\n        -this.maxDelta_ * this.deltaPerZoom_,\n        this.maxDelta_ * this.deltaPerZoom_,\n      ) / this.deltaPerZoom_;\n    if (view.getConstrainResolution() || this.constrainResolution_) {\n      // view has a zoom constraint, zoom by 1\n      delta = delta ? (delta > 0 ? 1 : -1) : 0;\n    }\n    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);\n\n    this.mode_ = undefined;\n    this.totalDelta_ = 0;\n    this.lastAnchor_ = null;\n    this.startTime_ = undefined;\n    this.timeoutId_ = undefined;\n  }\n\n  /**\n   * Enable or disable using the mouse's location as an anchor when zooming\n   * @param {boolean} useAnchor true to zoom to the mouse's location, false\n   * to zoom to the center of the map\n   * @api\n   */\n  setMouseAnchor(useAnchor) {\n    this.useAnchor_ = useAnchor;\n    if (!useAnchor) {\n      this.lastAnchor_ = null;\n    }\n  }\n}\n\nexport default MouseWheelZoom;\n", "/**\n * @module ol/interaction/PinchRotate\n */\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\nimport {FALSE} from '../functions.js';\nimport {disable} from '../rotationconstraint.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=250] The duration of the animation in\n * milliseconds.\n * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.\n */\n\n/**\n * @classdesc\n * Allows the user to rotate the map by twisting with two fingers\n * on a touch screen.\n * @api\n */\nclass PinchRotate extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastAngle_ = undefined;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.rotating_ = false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.rotationDelta_ = 0.0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 250;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let rotationDelta = 0.0;\n\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n\n    // angle between touches\n    const angle = Math.atan2(\n      touch1.clientY - touch0.clientY,\n      touch1.clientX - touch0.clientX,\n    );\n\n    if (this.lastAngle_ !== undefined) {\n      const delta = angle - this.lastAngle_;\n      this.rotationDelta_ += delta;\n      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {\n        this.rotating_ = true;\n      }\n      rotationDelta = delta;\n    }\n    this.lastAngle_ = angle;\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n    if (view.getConstraints().rotation === disable) {\n      return;\n    }\n\n    // rotate anchor point.\n    // FIXME: should be the intersection point between the lines:\n    //     touch0,touch1 and previousTouch0,previousTouch1\n    this.anchor_ = map.getCoordinateFromPixelInternal(\n      map.getEventPixel(centroidFromPointers(this.targetPointers)),\n    );\n\n    // rotate\n    if (this.rotating_) {\n      map.render();\n      view.adjustRotationInternal(rotationDelta, this.anchor_);\n    }\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      view.endInteraction(this.duration_);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastAngle_ = undefined;\n      this.rotating_ = false;\n      this.rotationDelta_ = 0.0;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default PinchRotate;\n", "/**\n * @module ol/interaction/PinchZoom\n */\nimport PointerInteraction, {\n  centroid as centroidFromPointers,\n} from './Pointer.js';\nimport {FALSE} from '../functions.js';\n\n/**\n * @typedef {Object} Options\n * @property {number} [duration=400] Animation duration in milliseconds.\n */\n\n/**\n * @classdesc\n * Allows the user to zoom the map by pinching with two fingers\n * on a touch screen.\n * @api\n */\nclass PinchZoom extends PointerInteraction {\n  /**\n   * @param {Options} [options] Options.\n   */\n  constructor(options) {\n    options = options ? options : {};\n\n    const pointerOptions = /** @type {import(\"./Pointer.js\").Options} */ (\n      options\n    );\n\n    if (!pointerOptions.stopDown) {\n      pointerOptions.stopDown = FALSE;\n    }\n\n    super(pointerOptions);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.anchor_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.duration_ = options.duration !== undefined ? options.duration : 400;\n\n    /**\n     * @private\n     * @type {number|undefined}\n     */\n    this.lastDistance_ = undefined;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.lastScaleDelta_ = 1;\n  }\n\n  /**\n   * Handle pointer drag events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   */\n  handleDragEvent(mapBrowserEvent) {\n    let scaleDelta = 1.0;\n\n    const touch0 = this.targetPointers[0];\n    const touch1 = this.targetPointers[1];\n    const dx = touch0.clientX - touch1.clientX;\n    const dy = touch0.clientY - touch1.clientY;\n\n    // distance between touches\n    const distance = Math.sqrt(dx * dx + dy * dy);\n\n    if (this.lastDistance_ !== undefined) {\n      scaleDelta = this.lastDistance_ / distance;\n    }\n    this.lastDistance_ = distance;\n\n    const map = mapBrowserEvent.map;\n    const view = map.getView();\n\n    if (scaleDelta != 1.0) {\n      this.lastScaleDelta_ = scaleDelta;\n    }\n\n    // scale anchor point.\n    this.anchor_ = map.getCoordinateFromPixelInternal(\n      map.getEventPixel(centroidFromPointers(this.targetPointers)),\n    );\n\n    // scale, bypass the resolution constraint\n    map.render();\n    view.adjustResolutionInternal(scaleDelta, this.anchor_);\n  }\n\n  /**\n   * Handle pointer up events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleUpEvent(mapBrowserEvent) {\n    if (this.targetPointers.length < 2) {\n      const map = mapBrowserEvent.map;\n      const view = map.getView();\n      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;\n      view.endInteraction(this.duration_, direction);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Handle pointer down events.\n   * @param {import(\"../MapBrowserEvent.js\").default} mapBrowserEvent Event.\n   * @return {boolean} If the event was consumed.\n   */\n  handleDownEvent(mapBrowserEvent) {\n    if (this.targetPointers.length >= 2) {\n      const map = mapBrowserEvent.map;\n      this.anchor_ = null;\n      this.lastDistance_ = undefined;\n      this.lastScaleDelta_ = 1;\n      if (!this.handlingDownUpSequence) {\n        map.getView().beginInteraction();\n      }\n      return true;\n    }\n    return false;\n  }\n}\n\nexport default PinchZoom;\n", "/**\n * @module ol/interaction/defaults\n */\nimport Collection from '../Collection.js';\nimport DoubleClickZoom from './DoubleClickZoom.js';\nimport DragPan from './DragPan.js';\nimport DragRotate from './DragRotate.js';\nimport DragZoom from './DragZoom.js';\nimport KeyboardPan from './KeyboardPan.js';\nimport KeyboardZoom from './KeyboardZoom.js';\nimport Kinetic from '../Kinetic.js';\nimport MouseWheelZoom from './MouseWheelZoom.js';\nimport PinchRotate from './PinchRotate.js';\nimport PinchZoom from './PinchZoom.js';\n\n/**\n * @typedef {Object} DefaultsOptions\n * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is\n * desired.\n * @property {boolean} [onFocusOnly=false] Interact only when the map has the\n * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is\n * useful when page scroll is desired for maps that do not have the browser's\n * focus.\n * @property {boolean} [doubleClickZoom=true] Whether double click zoom is\n * desired.\n * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.\n * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.\n * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.\n * @property {boolean} [dragPan=true] Whether drag pan is desired.\n * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.\n * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.\n * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.\n * @property {number} [zoomDuration] Duration of the zoom animation in\n * milliseconds.\n */\n\n/**\n * Set of interactions included in maps by default. Specific interactions can be\n * excluded by setting the appropriate option to false in the constructor\n * options, but the order of the interactions is fixed.  If you want to specify\n * a different order for interactions, you will need to create your own\n * {@link module:ol/interaction/Interaction~Interaction} instances and insert\n * them into a {@link module:ol/Collection~Collection} in the order you want\n * before creating your {@link module:ol/Map~Map} instance. Changing the order can\n * be of interest if the event propagation needs to be stopped at a point.\n * The default set of interactions, in sequence, is:\n * * {@link module:ol/interaction/DragRotate~DragRotate}\n * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}\n * * {@link module:ol/interaction/DragPan~DragPan}\n * * {@link module:ol/interaction/PinchRotate~PinchRotate}\n * * {@link module:ol/interaction/PinchZoom~PinchZoom}\n * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}\n * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}\n * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}\n * * {@link module:ol/interaction/DragZoom~DragZoom}\n *\n * @param {DefaultsOptions} [options] Defaults options.\n * @return {Collection<import(\"./Interaction.js\").default>}\n * A collection of interactions to be used with the {@link module:ol/Map~Map}\n * constructor's `interactions` option.\n * @api\n */\nexport function defaults(options) {\n  options = options ? options : {};\n\n  /** @type {Collection<import(\"./Interaction.js\").default>} */\n  const interactions = new Collection();\n\n  const kinetic = new Kinetic(-0.005, 0.05, 100);\n\n  const altShiftDragRotate =\n    options.altShiftDragRotate !== undefined\n      ? options.altShiftDragRotate\n      : true;\n  if (altShiftDragRotate) {\n    interactions.push(new DragRotate());\n  }\n\n  const doubleClickZoom =\n    options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;\n  if (doubleClickZoom) {\n    interactions.push(\n      new DoubleClickZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  const dragPan = options.dragPan !== undefined ? options.dragPan : true;\n  if (dragPan) {\n    interactions.push(\n      new DragPan({\n        onFocusOnly: options.onFocusOnly,\n        kinetic: kinetic,\n      }),\n    );\n  }\n\n  const pinchRotate =\n    options.pinchRotate !== undefined ? options.pinchRotate : true;\n  if (pinchRotate) {\n    interactions.push(new PinchRotate());\n  }\n\n  const pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;\n  if (pinchZoom) {\n    interactions.push(\n      new PinchZoom({\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  const keyboard = options.keyboard !== undefined ? options.keyboard : true;\n  if (keyboard) {\n    interactions.push(new KeyboardPan());\n    interactions.push(\n      new KeyboardZoom({\n        delta: options.zoomDelta,\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  const mouseWheelZoom =\n    options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;\n  if (mouseWheelZoom) {\n    interactions.push(\n      new MouseWheelZoom({\n        onFocusOnly: options.onFocusOnly,\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  const shiftDragZoom =\n    options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;\n  if (shiftDragZoom) {\n    interactions.push(\n      new DragZoom({\n        duration: options.zoomDuration,\n      }),\n    );\n  }\n\n  return interactions;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,IAAO,mBAAQ;AAAA,EACb,QAAQ;AACV;;;AC+BA,IAAM,cAAN,cAA0B,eAAW;AAAA;AAAA;AAAA;AAAA,EAInC,YAAY,SAAS;AACnB,UAAM;AAKN,SAAK;AAKL,SAAK;AAKL,SAAK;AAEL,QAAI,WAAW,QAAQ,aAAa;AAClC,WAAK,cAAc,QAAQ;AAAA,IAC7B;AAMA,SAAK,OAAO;AAEZ,SAAK,UAAU,IAAI;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY;AACV;AAAA;AAAA,MAA+B,KAAK,IAAI,iBAAoB,MAAM;AAAA;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS;AACP,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,iBAAiB;AAC3B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,QAAQ;AAChB,SAAK,IAAI,iBAAoB,QAAQ,MAAM;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,KAAK;AACV,SAAK,OAAO;AAAA,EACd;AACF;AAOO,SAAS,IAAI,MAAM,OAAO,UAAU;AACzC,QAAM,gBAAgB,KAAK,kBAAkB;AAC7C,MAAI,eAAe;AACjB,UAAM,SAAS,CAAC,cAAc,CAAC,IAAI,MAAM,CAAC,GAAG,cAAc,CAAC,IAAI,MAAM,CAAC,CAAC;AACxE,SAAK,gBAAgB;AAAA,MACnB,UAAU,aAAa,SAAY,WAAW;AAAA,MAC9C,QAAQ;AAAA,MACR,QAAQ,KAAK,qBAAqB,MAAM;AAAA,IAC1C,CAAC;AAAA,EACH;AACF;AAQO,SAAS,YAAY,MAAM,OAAO,QAAQ,UAAU;AACzD,QAAM,cAAc,KAAK,QAAQ;AAEjC,MAAI,gBAAgB,QAAW;AAC7B;AAAA,EACF;AAEA,QAAM,UAAU,KAAK,mBAAmB,cAAc,KAAK;AAC3D,QAAM,gBAAgB,KAAK,qBAAqB,OAAO;AAEvD,MAAI,KAAK,aAAa,GAAG;AACvB,SAAK,iBAAiB;AAAA,EACxB;AACA,OAAK,QAAQ;AAAA,IACX,YAAY;AAAA,IACZ;AAAA,IACA,UAAU,aAAa,SAAY,WAAW;AAAA,IAC9C,QAAQ;AAAA,EACV,CAAC;AACH;AAEA,IAAO,sBAAQ;;;AChKf,IAAO,8BAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOb,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOb,OAAO,kBAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOjB,UAAU,kBAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOpB,aAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQb,aAAa;AAAA,EAEb,aAAa;AAAA,EACb,WAAW;AAAA,EACX,aAAa;AAAA,EACb,YAAY;AAAA,EACZ,cAAc;AAAA,EACd,cAAc;AAAA,EACd,eAAe;AACjB;;;ACrCA,IAAM,kBAAN,cAA8B,oBAAY;AAAA;AAAA;AAAA;AAAA,EAIxC,YAAY,SAAS;AACnB,UAAM;AAEN,cAAU,UAAU,UAAU,CAAC;AAM/B,SAAK,SAAS,QAAQ,QAAQ,QAAQ,QAAQ;AAM9C,SAAK,YAAY,QAAQ,aAAa,SAAY,QAAQ,WAAW;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,iBAAiB;AAC3B,QAAI,YAAY;AAChB,QAAI,gBAAgB,QAAQ,4BAAoB,UAAU;AACxD,YAAM;AAAA;AAAA,QACJ,gBAAgB;AAAA;AAElB,YAAM,MAAM,gBAAgB;AAC5B,YAAM,SAAS,gBAAgB;AAC/B,YAAM,QAAQ,aAAa,WAAW,CAAC,KAAK,SAAS,KAAK;AAC1D,YAAM,OAAO,IAAI,QAAQ;AACzB,kBAAY,MAAM,OAAO,QAAQ,KAAK,SAAS;AAC/C,mBAAa,eAAe;AAC5B,kBAAY;AAAA,IACd;AACA,WAAO,CAAC;AAAA,EACV;AACF;AAEA,IAAO,0BAAQ;;;ACnBf,IAAM,qBAAN,cAAiC,oBAAY;AAAA;AAAA;AAAA;AAAA,EAI3C,YAAY,SAAS;AACnB,cAAU,UAAU,UAAU,CAAC;AAE/B;AAAA;AAAA,MACgE;AAAA,IAChE;AAEA,QAAI,QAAQ,iBAAiB;AAC3B,WAAK,kBAAkB,QAAQ;AAAA,IACjC;AAEA,QAAI,QAAQ,iBAAiB;AAC3B,WAAK,kBAAkB,QAAQ;AAAA,IACjC;AAEA,QAAI,QAAQ,iBAAiB;AAC3B,WAAK,kBAAkB,QAAQ;AAAA,IACjC;AAEA,QAAI,QAAQ,eAAe;AACzB,WAAK,gBAAgB,QAAQ;AAAA,IAC/B;AAEA,QAAI,QAAQ,UAAU;AACpB,WAAK,WAAW,QAAQ;AAAA,IAC1B;AAMA,SAAK,yBAAyB;AAM9B,SAAK,iBAAiB,CAAC;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAkB;AAChB,WAAO,KAAK,eAAe;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,gBAAgB,iBAAiB;AAC/B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,iBAAiB;AAAA,EAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUlC,YAAY,iBAAiB;AAC3B,QAAI,CAAC,gBAAgB,eAAe;AAClC,aAAO;AAAA,IACT;AAEA,QAAI,YAAY;AAChB,SAAK,uBAAuB,eAAe;AAC3C,QAAI,KAAK,wBAAwB;AAC/B,UAAI,gBAAgB,QAAQ,4BAAoB,aAAa;AAC3D,aAAK,gBAAgB,eAAe;AAEpC,wBAAgB,cAAc,eAAe;AAAA,MAC/C,WAAW,gBAAgB,QAAQ,4BAAoB,WAAW;AAChE,cAAM,YAAY,KAAK,cAAc,eAAe;AACpD,aAAK,yBACH,aAAa,KAAK,eAAe,SAAS;AAAA,MAC9C;AAAA,IACF,OAAO;AACL,UAAI,gBAAgB,QAAQ,4BAAoB,aAAa;AAC3D,cAAM,UAAU,KAAK,gBAAgB,eAAe;AACpD,aAAK,yBAAyB;AAC9B,oBAAY,KAAK,SAAS,OAAO;AAAA,MACnC,WAAW,gBAAgB,QAAQ,4BAAoB,aAAa;AAClE,aAAK,gBAAgB,eAAe;AAAA,MACtC;AAAA,IACF;AACA,WAAO,CAAC;AAAA,EACV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,iBAAiB;AAAA,EAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQlC,cAAc,iBAAiB;AAC7B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,SAAS,SAAS;AAChB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,uBAAuB,iBAAiB;AACtC,QAAI,gBAAgB,gBAAgB;AAClC,WAAK,iBAAiB,gBAAgB;AAAA,IACxC;AAAA,EACF;AACF;AAMO,SAAS,SAAS,eAAe;AACtC,QAAM,SAAS,cAAc;AAC7B,MAAI,UAAU;AACd,MAAI,UAAU;AACd,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,eAAW,cAAc,CAAC,EAAE;AAC5B,eAAW,cAAc,CAAC,EAAE;AAAA,EAC9B;AACA,SAAO,EAAC,SAAS,UAAU,QAAQ,SAAS,UAAU,OAAM;AAC9D;AAEA,IAAO,kBAAQ;;;AC7Mf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBO,SAAS,IAAI,UAAU;AAC5B,QAAM,aAAa;AAKnB,SAAO,SAAU,OAAO;AACtB,QAAI,OAAO;AACX,aAAS,IAAI,GAAG,KAAK,WAAW,QAAQ,IAAI,IAAI,EAAE,GAAG;AACnD,aAAO,QAAQ,WAAW,CAAC,EAAE,KAAK;AAClC,UAAI,CAAC,MAAM;AACT;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACF;AAUO,IAAM,aAAa,SAAU,iBAAiB;AACnD,QAAM;AAAA;AAAA,IACJ,gBAAgB;AAAA;AAElB,SACE,cAAc,UACd,EAAE,cAAc,WAAW,cAAc,YACzC,CAAC,cAAc;AAEnB;AAUO,IAAM,mBAAmB,SAAU,iBAAiB;AACzD,QAAM;AAAA;AAAA,IACJ,gBAAgB;AAAA;AAElB,SACE,cAAc,UACd,EAAE,cAAc,WAAW,cAAc,YACzC,cAAc;AAElB;AAUO,IAAM,QAAQ,SAAU,OAAO;AACpC,QAAM,gBAAgB,MAAM,IAAI,iBAAiB;AACjD,QAAM,gBAAgB,MAAM,IAAI,iBAAiB,EAAE;AACnD,SAAO,cAAc,SAAS,aAAa;AAC7C;AAQO,IAAM,oBAAoB,SAAU,OAAO;AAChD,SAAO,MAAM,IAAI,iBAAiB,EAAE,aAAa,UAAU,IACvD,MAAM,KAAK,IACX;AACN;AASO,IAAM,SAAS;AASf,IAAM,QAAQ,SAAU,iBAAiB;AAC9C,SAAO,gBAAgB,QAAQ,4BAAoB;AACrD;AAWO,IAAM,oBAAoB,SAAU,iBAAiB;AAC1D,QAAM;AAAA;AAAA,IACJ,gBAAgB;AAAA;AAElB,SAAO,cAAc,UAAU,KAAK,EAAE,UAAU,OAAO,cAAc;AACvE;AASO,IAAM,QAAQ;AAUd,IAAM,cAAc,SAAU,iBAAiB;AACpD,SAAO,gBAAgB,QAAQ;AACjC;AASO,IAAM,cAAc,SAAU,iBAAiB;AACpD,SAAO,gBAAgB,QAAQ,4BAAoB;AACrD;AASO,IAAM,cAAc,SAAU,iBAAiB;AACpD,SAAO,gBAAgB,QAAQ,4BAAoB;AACrD;AAUO,IAAM,iBAAiB,SAAU,iBAAiB;AACvD,QAAM;AAAA;AAAA,IACJ,gBAAgB;AAAA;AAElB,SACE,CAAC,cAAc,UACf,EAAE,cAAc,WAAW,cAAc,YACzC,CAAC,cAAc;AAEnB;AAWO,IAAM,0BAA0B,SAAU,iBAAiB;AAChE,QAAM;AAAA;AAAA,IACJ,gBAAgB;AAAA;AAElB,SACE,CAAC,cAAc,WACd,MAAM,cAAc,UAAU,cAAc,YAC7C,CAAC,cAAc;AAEnB;AAUO,IAAM,sBAAsB,SAAU,iBAAiB;AAC5D,QAAM;AAAA;AAAA,IACJ,gBAAgB;AAAA;AAElB,SAAO,MAAM,cAAc,UAAU,cAAc;AACrD;AAUO,IAAM,eAAe,SAAU,iBAAiB;AACrD,QAAM;AAAA;AAAA,IACJ,gBAAgB;AAAA;AAElB,SACE,CAAC,cAAc,UACf,EAAE,cAAc,WAAW,cAAc,YACzC,cAAc;AAElB;AAWO,IAAM,oBAAoB,SAAU,iBAAiB;AAC1D,QAAM;AAAA;AAAA,IACJ,gBAAgB;AAAA;AAElB,QAAM;AAAA;AAAA,IAAkC,cAAc,OAAQ;AAAA;AAC9D,SACE,YAAY,WACZ,YAAY,YACZ,YAAY;AAAA;AAAA;AAAA,EAIZ,CAAC,cAAc,OAAO;AAE1B;AASO,IAAM,YAAY,SAAU,iBAAiB;AAClD,QAAM;AAAA;AAAA,IACJ,gBACA;AAAA;AACF;AAAA,IACE,iBAAiB;AAAA,IACjB;AAAA,EACF;AAEA,SAAO,aAAa,eAAe;AACrC;AASO,IAAM,YAAY,SAAU,iBAAiB;AAClD,QAAM;AAAA;AAAA,IACJ,gBACA;AAAA;AACF;AAAA,IACE,eAAe;AAAA,IACf;AAAA,EACF;AAEA,SAAO,WAAW,gBAAgB;AACpC;AASO,IAAM,UAAU,SAAU,iBAAiB;AAChD,QAAM;AAAA;AAAA,IACJ,gBACA;AAAA;AACF;AAAA,IACE,eAAe;AAAA,IACf;AAAA,EACF;AAEA,SAAO,WAAW,gBAAgB;AACpC;AAWO,IAAM,gBAAgB,SAAU,iBAAiB;AACtD,QAAM;AAAA;AAAA,IACJ,gBACA;AAAA;AACF;AAAA,IACE,iBAAiB;AAAA,IACjB;AAAA,EACF;AACA,SAAO,aAAa,aAAa,aAAa,WAAW;AAC3D;;;AClWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAAAA;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACQA,IAAO,uBAAQ;AAAA,EACb,SAAS;AAAA,EACT,cAAc;AAAA,EACd,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAAA,EACP,MAAM;AACR;;;ADQO,SAAS,eAAeC,cAAa;AAC1C,QAAM,SAAS,YAAY;AAC3B,WAAS,IAAI,GAAG,KAAKA,aAAY,QAAQ,IAAI,IAAI,EAAE,GAAG;AACpD,qBAAiB,QAAQA,aAAY,CAAC,CAAC;AAAA,EACzC;AACA,SAAO;AACT;AASA,SAAS,mBAAmB,IAAI,IAAI,MAAM;AACxC,QAAM,OAAO,KAAK,IAAI,MAAM,MAAM,EAAE;AACpC,QAAM,OAAO,KAAK,IAAI,MAAM,MAAM,EAAE;AACpC,QAAM,OAAO,KAAK,IAAI,MAAM,MAAM,EAAE;AACpC,QAAM,OAAO,KAAK,IAAI,MAAM,MAAM,EAAE;AACpC,SAAO,eAAe,MAAM,MAAM,MAAM,MAAM,IAAI;AACpD;AAUO,SAAS,OAAO,QAAQ,OAAO,MAAM;AAC1C,MAAI,MAAM;AACR,SAAK,CAAC,IAAI,OAAO,CAAC,IAAI;AACtB,SAAK,CAAC,IAAI,OAAO,CAAC,IAAI;AACtB,SAAK,CAAC,IAAI,OAAO,CAAC,IAAI;AACtB,SAAK,CAAC,IAAI,OAAO,CAAC,IAAI;AACtB,WAAO;AAAA,EACT;AACA,SAAO;AAAA,IACL,OAAO,CAAC,IAAI;AAAA,IACZ,OAAO,CAAC,IAAI;AAAA,IACZ,OAAO,CAAC,IAAI;AAAA,IACZ,OAAO,CAAC,IAAI;AAAA,EACd;AACF;AASO,SAAS,MAAM,QAAQ,MAAM;AAClC,MAAI,MAAM;AACR,SAAK,CAAC,IAAI,OAAO,CAAC;AAClB,SAAK,CAAC,IAAI,OAAO,CAAC;AAClB,SAAK,CAAC,IAAI,OAAO,CAAC;AAClB,SAAK,CAAC,IAAI,OAAO,CAAC;AAClB,WAAO;AAAA,EACT;AACA,SAAO,OAAO,MAAM;AACtB;AAQO,SAAS,yBAAyB,QAAQ,GAAG,GAAG;AACrD,MAAI,IAAI;AACR,MAAI,IAAI,OAAO,CAAC,GAAG;AACjB,SAAK,OAAO,CAAC,IAAI;AAAA,EACnB,WAAW,OAAO,CAAC,IAAI,GAAG;AACxB,SAAK,IAAI,OAAO,CAAC;AAAA,EACnB,OAAO;AACL,SAAK;AAAA,EACP;AACA,MAAI,IAAI,OAAO,CAAC,GAAG;AACjB,SAAK,OAAO,CAAC,IAAI;AAAA,EACnB,WAAW,OAAO,CAAC,IAAI,GAAG;AACxB,SAAK,IAAI,OAAO,CAAC;AAAA,EACnB,OAAO;AACL,SAAK;AAAA,EACP;AACA,SAAO,KAAK,KAAK,KAAK;AACxB;AAUO,SAAS,mBAAmB,QAAQ,YAAY;AACrD,SAAO,WAAW,QAAQ,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AACxD;AAcO,SAAS,eAAe,SAAS,SAAS;AAC/C,SACE,QAAQ,CAAC,KAAK,QAAQ,CAAC,KACvB,QAAQ,CAAC,KAAK,QAAQ,CAAC,KACvB,QAAQ,CAAC,KAAK,QAAQ,CAAC,KACvB,QAAQ,CAAC,KAAK,QAAQ,CAAC;AAE3B;AAWO,SAAS,WAAW,QAAQ,GAAG,GAAG;AACvC,SAAO,OAAO,CAAC,KAAK,KAAK,KAAK,OAAO,CAAC,KAAK,OAAO,CAAC,KAAK,KAAK,KAAK,OAAO,CAAC;AAC5E;AASO,SAAS,uBAAuB,QAAQ,YAAY;AACzD,QAAM,OAAO,OAAO,CAAC;AACrB,QAAM,OAAO,OAAO,CAAC;AACrB,QAAM,OAAO,OAAO,CAAC;AACrB,QAAM,OAAO,OAAO,CAAC;AACrB,QAAM,IAAI,WAAW,CAAC;AACtB,QAAM,IAAI,WAAW,CAAC;AACtB,MAAI,eAAe,qBAAa;AAChC,MAAI,IAAI,MAAM;AACZ,mBAAe,eAAe,qBAAa;AAAA,EAC7C,WAAW,IAAI,MAAM;AACnB,mBAAe,eAAe,qBAAa;AAAA,EAC7C;AACA,MAAI,IAAI,MAAM;AACZ,mBAAe,eAAe,qBAAa;AAAA,EAC7C,WAAW,IAAI,MAAM;AACnB,mBAAe,eAAe,qBAAa;AAAA,EAC7C;AACA,MAAI,iBAAiB,qBAAa,SAAS;AACzC,mBAAe,qBAAa;AAAA,EAC9B;AACA,SAAO;AACT;AAOO,SAAS,cAAc;AAC5B,SAAO,CAAC,UAAU,UAAU,WAAW,SAAS;AAClD;AAWO,SAAS,eAAe,MAAM,MAAM,MAAM,MAAM,MAAM;AAC3D,MAAI,MAAM;AACR,SAAK,CAAC,IAAI;AACV,SAAK,CAAC,IAAI;AACV,SAAK,CAAC,IAAI;AACV,SAAK,CAAC,IAAI;AACV,WAAO;AAAA,EACT;AACA,SAAO,CAAC,MAAM,MAAM,MAAM,IAAI;AAChC;AAOO,SAAS,oBAAoB,MAAM;AACxC,SAAO,eAAe,UAAU,UAAU,WAAW,WAAW,IAAI;AACtE;AAOO,SAAS,6BAA6B,YAAY,MAAM;AAC7D,QAAM,IAAI,WAAW,CAAC;AACtB,QAAM,IAAI,WAAW,CAAC;AACtB,SAAO,eAAe,GAAG,GAAG,GAAG,GAAG,IAAI;AACxC;AAOO,SAAS,8BAA8BA,cAAa,MAAM;AAC/D,QAAM,SAAS,oBAAoB,IAAI;AACvC,SAAO,kBAAkB,QAAQA,YAAW;AAC9C;AAUO,SAAS,kCACd,iBACAC,SACA,KACA,QACA,MACA;AACA,QAAM,SAAS,oBAAoB,IAAI;AACvC,SAAO,sBAAsB,QAAQ,iBAAiBA,SAAQ,KAAK,MAAM;AAC3E;AAOO,SAAS,wBAAwB,OAAO,MAAM;AACnD,QAAM,SAAS,oBAAoB,IAAI;AACvC,SAAO,YAAY,QAAQ,KAAK;AAClC;AASO,SAAS,OAAO,SAAS,SAAS;AACvC,SACE,QAAQ,CAAC,KAAK,QAAQ,CAAC,KACvB,QAAQ,CAAC,KAAK,QAAQ,CAAC,KACvB,QAAQ,CAAC,KAAK,QAAQ,CAAC,KACvB,QAAQ,CAAC,KAAK,QAAQ,CAAC;AAE3B;AASO,SAAS,oBAAoB,SAAS,SAAS,WAAW;AAC/D,SACE,KAAK,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,CAAC,IAAI,aACpC,KAAK,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,CAAC,IAAI,aACpC,KAAK,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,CAAC,IAAI,aACpC,KAAK,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,CAAC,IAAI;AAExC;AASO,SAASC,QAAO,SAAS,SAAS;AACvC,MAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;AAC3B,YAAQ,CAAC,IAAI,QAAQ,CAAC;AAAA,EACxB;AACA,MAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;AAC3B,YAAQ,CAAC,IAAI,QAAQ,CAAC;AAAA,EACxB;AACA,MAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;AAC3B,YAAQ,CAAC,IAAI,QAAQ,CAAC;AAAA,EACxB;AACA,MAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;AAC3B,YAAQ,CAAC,IAAI,QAAQ,CAAC;AAAA,EACxB;AACA,SAAO;AACT;AAMO,SAAS,iBAAiB,QAAQ,YAAY;AACnD,MAAI,WAAW,CAAC,IAAI,OAAO,CAAC,GAAG;AAC7B,WAAO,CAAC,IAAI,WAAW,CAAC;AAAA,EAC1B;AACA,MAAI,WAAW,CAAC,IAAI,OAAO,CAAC,GAAG;AAC7B,WAAO,CAAC,IAAI,WAAW,CAAC;AAAA,EAC1B;AACA,MAAI,WAAW,CAAC,IAAI,OAAO,CAAC,GAAG;AAC7B,WAAO,CAAC,IAAI,WAAW,CAAC;AAAA,EAC1B;AACA,MAAI,WAAW,CAAC,IAAI,OAAO,CAAC,GAAG;AAC7B,WAAO,CAAC,IAAI,WAAW,CAAC;AAAA,EAC1B;AACF;AAOO,SAAS,kBAAkB,QAAQF,cAAa;AACrD,WAAS,IAAI,GAAG,KAAKA,aAAY,QAAQ,IAAI,IAAI,EAAE,GAAG;AACpD,qBAAiB,QAAQA,aAAY,CAAC,CAAC;AAAA,EACzC;AACA,SAAO;AACT;AAUO,SAAS,sBACd,QACA,iBACAC,SACA,KACA,QACA;AACA,SAAOA,UAAS,KAAKA,WAAU,QAAQ;AACrC,aAAS,QAAQ,gBAAgBA,OAAM,GAAG,gBAAgBA,UAAS,CAAC,CAAC;AAAA,EACvE;AACA,SAAO;AACT;AAOO,SAAS,YAAY,QAAQ,OAAO;AACzC,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,sBAAkB,QAAQ,MAAM,CAAC,CAAC;AAAA,EACpC;AACA,SAAO;AACT;AAOO,SAAS,SAAS,QAAQ,GAAG,GAAG;AACrC,SAAO,CAAC,IAAI,KAAK,IAAI,OAAO,CAAC,GAAG,CAAC;AACjC,SAAO,CAAC,IAAI,KAAK,IAAI,OAAO,CAAC,GAAG,CAAC;AACjC,SAAO,CAAC,IAAI,KAAK,IAAI,OAAO,CAAC,GAAG,CAAC;AACjC,SAAO,CAAC,IAAI,KAAK,IAAI,OAAO,CAAC,GAAG,CAAC;AACnC;AAWO,SAAS,cAAc,QAAQ,UAAU;AAC9C,MAAI;AACJ,QAAM,SAAS,cAAc,MAAM,CAAC;AACpC,MAAI,KAAK;AACP,WAAO;AAAA,EACT;AACA,QAAM,SAAS,eAAe,MAAM,CAAC;AACrC,MAAI,KAAK;AACP,WAAO;AAAA,EACT;AACA,QAAM,SAAS,YAAY,MAAM,CAAC;AAClC,MAAI,KAAK;AACP,WAAO;AAAA,EACT;AACA,QAAM,SAAS,WAAW,MAAM,CAAC;AACjC,MAAI,KAAK;AACP,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAQO,SAAS,QAAQ,QAAQ;AAC9B,MAAI,OAAO;AACX,MAAI,CAAC,QAAQ,MAAM,GAAG;AACpB,WAAO,SAAS,MAAM,IAAI,UAAU,MAAM;AAAA,EAC5C;AACA,SAAO;AACT;AAQO,SAAS,cAAc,QAAQ;AACpC,SAAO,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAC9B;AAQO,SAAS,eAAe,QAAQ;AACrC,SAAO,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAC9B;AAQO,SAAS,UAAU,QAAQ;AAChC,SAAO,EAAE,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,IAAI,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC;AAClE;AAQO,SAAS,UAAU,QAAQ,QAAQ;AACxC,MAAI;AACJ,MAAI,WAAW,eAAe;AAC5B,iBAAa,cAAc,MAAM;AAAA,EACnC,WAAW,WAAW,gBAAgB;AACpC,iBAAa,eAAe,MAAM;AAAA,EACpC,WAAW,WAAW,YAAY;AAChC,iBAAa,WAAW,MAAM;AAAA,EAChC,WAAW,WAAW,aAAa;AACjC,iBAAa,YAAY,MAAM;AAAA,EACjC,OAAO;AACL,UAAM,IAAI,MAAM,gBAAgB;AAAA,EAClC;AACA,SAAO;AACT;AAOO,SAAS,gBAAgB,SAAS,SAAS;AAChD,QAAM,OAAO,KAAK,IAAI,QAAQ,CAAC,GAAG,QAAQ,CAAC,CAAC;AAC5C,QAAM,OAAO,KAAK,IAAI,QAAQ,CAAC,GAAG,QAAQ,CAAC,CAAC;AAC5C,QAAM,OAAO,KAAK,IAAI,QAAQ,CAAC,GAAG,QAAQ,CAAC,CAAC;AAC5C,QAAM,OAAO,KAAK,IAAI,QAAQ,CAAC,GAAG,QAAQ,CAAC,CAAC;AAC5C,UAAQ,OAAO,SAAS,OAAO;AACjC;AAUO,SAAS,kBAAkB,QAAQ,YAAY,UAAU,MAAM,MAAM;AAC1E,QAAM,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE,IAAI;AAAA,IACvC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO;AAAA,IACL,KAAK,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,IACvB,KAAK,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,IACvB,KAAK,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,IACvB,KAAK,IAAI,IAAI,IAAI,IAAI,EAAE;AAAA,IACvB;AAAA,EACF;AACF;AASO,SAAS,mBAAmB,QAAQ,YAAY,UAAU,MAAM;AACrE,QAAM,KAAM,aAAa,KAAK,CAAC,IAAK;AACpC,QAAM,KAAM,aAAa,KAAK,CAAC,IAAK;AACpC,QAAM,cAAc,KAAK,IAAI,QAAQ;AACrC,QAAM,cAAc,KAAK,IAAI,QAAQ;AACrC,QAAM,OAAO,KAAK;AAClB,QAAM,OAAO,KAAK;AAClB,QAAM,OAAO,KAAK;AAClB,QAAM,OAAO,KAAK;AAClB,QAAM,IAAI,OAAO,CAAC;AAClB,QAAM,IAAI,OAAO,CAAC;AAClB,SAAO;AAAA,IACL,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,IACX,IAAI,OAAO;AAAA,EACb;AACF;AAQO,SAAS,UAAU,QAAQ;AAChC,SAAO,OAAO,CAAC,IAAI,OAAO,CAAC;AAC7B;AAOO,SAAS,oBAAoB,SAAS,SAAS;AACpD,QAAM,eAAe,gBAAgB,SAAS,OAAO;AACrD,SAAO,QAAQ,YAAY;AAC7B;AAUO,SAAS,gBAAgB,SAAS,SAAS,MAAM;AACtD,QAAM,eAAe,OAAO,OAAO,YAAY;AAC/C,MAAI,WAAW,SAAS,OAAO,GAAG;AAChC,QAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;AAC3B,mBAAa,CAAC,IAAI,QAAQ,CAAC;AAAA,IAC7B,OAAO;AACL,mBAAa,CAAC,IAAI,QAAQ,CAAC;AAAA,IAC7B;AACA,QAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;AAC3B,mBAAa,CAAC,IAAI,QAAQ,CAAC;AAAA,IAC7B,OAAO;AACL,mBAAa,CAAC,IAAI,QAAQ,CAAC;AAAA,IAC7B;AACA,QAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;AAC3B,mBAAa,CAAC,IAAI,QAAQ,CAAC;AAAA,IAC7B,OAAO;AACL,mBAAa,CAAC,IAAI,QAAQ,CAAC;AAAA,IAC7B;AACA,QAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,GAAG;AAC3B,mBAAa,CAAC,IAAI,QAAQ,CAAC;AAAA,IAC7B,OAAO;AACL,mBAAa,CAAC,IAAI,QAAQ,CAAC;AAAA,IAC7B;AAAA,EACF,OAAO;AACL,wBAAoB,YAAY;AAAA,EAClC;AACA,SAAO;AACT;AAMO,SAAS,UAAU,QAAQ;AAChC,SAAO,SAAS,MAAM,IAAI,UAAU,MAAM;AAC5C;AAQO,SAAS,QAAQ,QAAQ;AAC9B,SAAO,CAAC,OAAO,CAAC,IAAI,OAAO,CAAC,GAAG,OAAO,CAAC,IAAI,OAAO,CAAC,CAAC;AACtD;AAQO,SAAS,WAAW,QAAQ;AACjC,SAAO,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAC9B;AAQO,SAAS,YAAY,QAAQ;AAClC,SAAO,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAC9B;AAQO,SAAS,SAAS,QAAQ;AAC/B,SAAO,OAAO,CAAC,IAAI,OAAO,CAAC;AAC7B;AASO,SAAS,WAAW,SAAS,SAAS;AAC3C,SACE,QAAQ,CAAC,KAAK,QAAQ,CAAC,KACvB,QAAQ,CAAC,KAAK,QAAQ,CAAC,KACvB,QAAQ,CAAC,KAAK,QAAQ,CAAC,KACvB,QAAQ,CAAC,KAAK,QAAQ,CAAC;AAE3B;AAQO,SAAS,QAAQ,QAAQ;AAC9B,SAAO,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,OAAO,CAAC,IAAI,OAAO,CAAC;AACtD;AAOO,SAAS,eAAe,QAAQ,MAAM;AAC3C,MAAI,MAAM;AACR,SAAK,CAAC,IAAI,OAAO,CAAC;AAClB,SAAK,CAAC,IAAI,OAAO,CAAC;AAClB,SAAK,CAAC,IAAI,OAAO,CAAC;AAClB,SAAK,CAAC,IAAI,OAAO,CAAC;AAClB,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAMO,SAAS,gBAAgB,QAAQ,OAAO;AAC7C,QAAM,UAAW,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,KAAM,QAAQ;AACxD,QAAM,UAAW,OAAO,CAAC,IAAI,OAAO,CAAC,KAAK,KAAM,QAAQ;AACxD,SAAO,CAAC,KAAK;AACb,SAAO,CAAC,KAAK;AACb,SAAO,CAAC,KAAK;AACb,SAAO,CAAC,KAAK;AACf;AAUO,SAAS,kBAAkB,QAAQ,OAAO,KAAK;AACpD,MAAIE,cAAa;AACjB,QAAM,WAAW,uBAAuB,QAAQ,KAAK;AACrD,QAAM,SAAS,uBAAuB,QAAQ,GAAG;AACjD,MACE,aAAa,qBAAa,gBAC1B,WAAW,qBAAa,cACxB;AACA,IAAAA,cAAa;AAAA,EACf,OAAO;AACL,UAAM,OAAO,OAAO,CAAC;AACrB,UAAM,OAAO,OAAO,CAAC;AACrB,UAAM,OAAO,OAAO,CAAC;AACrB,UAAM,OAAO,OAAO,CAAC;AACrB,UAAM,SAAS,MAAM,CAAC;AACtB,UAAM,SAAS,MAAM,CAAC;AACtB,UAAM,OAAO,IAAI,CAAC;AAClB,UAAM,OAAO,IAAI,CAAC;AAClB,UAAM,SAAS,OAAO,WAAW,OAAO;AACxC,QAAI,GAAG;AACP,QAAI,CAAC,EAAE,SAAS,qBAAa,UAAU,EAAE,WAAW,qBAAa,QAAQ;AAEvE,UAAI,QAAQ,OAAO,QAAQ;AAC3B,MAAAA,cAAa,KAAK,QAAQ,KAAK;AAAA,IACjC;AACA,QACE,CAACA,eACD,CAAC,EAAE,SAAS,qBAAa,UACzB,EAAE,WAAW,qBAAa,QAC1B;AAEA,UAAI,QAAQ,OAAO,QAAQ;AAC3B,MAAAA,cAAa,KAAK,QAAQ,KAAK;AAAA,IACjC;AACA,QACE,CAACA,eACD,CAAC,EAAE,SAAS,qBAAa,UACzB,EAAE,WAAW,qBAAa,QAC1B;AAEA,UAAI,QAAQ,OAAO,QAAQ;AAC3B,MAAAA,cAAa,KAAK,QAAQ,KAAK;AAAA,IACjC;AACA,QACE,CAACA,eACD,CAAC,EAAE,SAAS,qBAAa,SACzB,EAAE,WAAW,qBAAa,OAC1B;AAEA,UAAI,QAAQ,OAAO,QAAQ;AAC3B,MAAAA,cAAa,KAAK,QAAQ,KAAK;AAAA,IACjC;AAAA,EACF;AACA,SAAOA;AACT;AAaO,SAAS,eAAe,QAAQ,aAAa,MAAM,OAAO;AAC/D,MAAI,QAAQ,MAAM,GAAG;AACnB,WAAO,oBAAoB,IAAI;AAAA,EACjC;AACA,MAAIH,eAAc,CAAC;AACnB,MAAI,QAAQ,GAAG;AACb,UAAM,QAAQ,OAAO,CAAC,IAAI,OAAO,CAAC;AAClC,UAAM,SAAS,OAAO,CAAC,IAAI,OAAO,CAAC;AACnC,aAAS,IAAI,GAAG,IAAI,OAAO,EAAE,GAAG;AAC9B,MAAAA,aAAY;AAAA,QACV,OAAO,CAAC,IAAK,QAAQ,IAAK;AAAA,QAC1B,OAAO,CAAC;AAAA,QACR,OAAO,CAAC;AAAA,QACR,OAAO,CAAC,IAAK,SAAS,IAAK;AAAA,QAC3B,OAAO,CAAC,IAAK,QAAQ,IAAK;AAAA,QAC1B,OAAO,CAAC;AAAA,QACR,OAAO,CAAC;AAAA,QACR,OAAO,CAAC,IAAK,SAAS,IAAK;AAAA,MAC7B;AAAA,IACF;AAAA,EACF,OAAO;AACL,IAAAA,eAAc;AAAA,MACZ,OAAO,CAAC;AAAA,MACR,OAAO,CAAC;AAAA,MACR,OAAO,CAAC;AAAA,MACR,OAAO,CAAC;AAAA,MACR,OAAO,CAAC;AAAA,MACR,OAAO,CAAC;AAAA,MACR,OAAO,CAAC;AAAA,MACR,OAAO,CAAC;AAAA,IACV;AAAA,EACF;AACA,cAAYA,cAAaA,cAAa,CAAC;AACvC,QAAM,KAAK,CAAC;AACZ,QAAM,KAAK,CAAC;AACZ,WAAS,IAAI,GAAG,IAAIA,aAAY,QAAQ,IAAI,GAAG,KAAK,GAAG;AACrD,OAAG,KAAKA,aAAY,CAAC,CAAC;AACtB,OAAG,KAAKA,aAAY,IAAI,CAAC,CAAC;AAAA,EAC5B;AACA,SAAO,mBAAmB,IAAI,IAAI,IAAI;AACxC;AAUO,SAAS,MAAM,QAAQ,YAAY;AACxC,QAAM,mBAAmB,WAAW,UAAU;AAC9C,QAAM,SAAS,UAAU,MAAM;AAC/B,MACE,WAAW,SAAS,MACnB,OAAO,CAAC,IAAI,iBAAiB,CAAC,KAAK,OAAO,CAAC,KAAK,iBAAiB,CAAC,IACnE;AACA,UAAM,aAAa,SAAS,gBAAgB;AAC5C,UAAM,aAAa,KAAK;AAAA,OACrB,OAAO,CAAC,IAAI,iBAAiB,CAAC,KAAK;AAAA,IACtC;AACA,UAAMC,UAAS,aAAa;AAC5B,WAAO,CAAC,KAAKA;AACb,WAAO,CAAC,KAAKA;AAAA,EACf;AACA,SAAO;AACT;AAcO,SAAS,cAAc,QAAQ,YAAY;AAChD,MAAI,WAAW,SAAS,GAAG;AACzB,UAAM,mBAAmB,WAAW,UAAU;AAE9C,QAAI,CAAC,SAAS,OAAO,CAAC,CAAC,KAAK,CAAC,SAAS,OAAO,CAAC,CAAC,GAAG;AAChD,aAAO,CAAC,CAAC,iBAAiB,CAAC,GAAG,OAAO,CAAC,GAAG,iBAAiB,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;AAAA,IAC1E;AAEA,UAAM,QAAQ,UAAU;AACxB,UAAM,aAAa,SAAS,gBAAgB;AAE5C,QAAI,SAAS,MAAM,IAAI,YAAY;AAEjC,aAAO,CAAC,CAAC,iBAAiB,CAAC,GAAG,OAAO,CAAC,GAAG,iBAAiB,CAAC,GAAG,OAAO,CAAC,CAAC,CAAC;AAAA,IAC1E;AACA,QAAI,OAAO,CAAC,IAAI,iBAAiB,CAAC,GAAG;AAEnC,aAAO;AAAA,QACL,CAAC,OAAO,CAAC,IAAI,YAAY,OAAO,CAAC,GAAG,iBAAiB,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,QAClE,CAAC,iBAAiB,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,MACvD;AAAA,IACF;AACA,QAAI,OAAO,CAAC,IAAI,iBAAiB,CAAC,GAAG;AAEnC,aAAO;AAAA,QACL,CAAC,OAAO,CAAC,GAAG,OAAO,CAAC,GAAG,iBAAiB,CAAC,GAAG,OAAO,CAAC,CAAC;AAAA,QACrD,CAAC,iBAAiB,CAAC,GAAG,OAAO,CAAC,GAAG,OAAO,CAAC,IAAI,YAAY,OAAO,CAAC,CAAC;AAAA,MACpE;AAAA,IACF;AAAA,EACF;AAEA,SAAO,CAAC,MAAM;AAChB;;;AE/4BO,SAAS,UAAU,QAAQ,OAAO,WAAW;AAClD,QAAM,eACJ,cAAc,SAAY,OAAO,QAAQ,SAAS,IAAI,KAAK;AAC7D,MAAI,UAAU,aAAa,QAAQ,GAAG;AACtC,YAAU,YAAY,KAAK,aAAa,SAAS;AACjD,SAAO,UAAU,QACb,eACA,IAAI,MAAM,IAAI,QAAQ,OAAO,EAAE,KAAK,GAAG,IAAI;AACjD;AAQO,SAAS,gBAAgB,IAAI,IAAI;AACtC,QAAM,MAAM,KAAK,IAAI,MAAM,GAAG;AAC9B,QAAM,MAAM,KAAK,IAAI,MAAM,GAAG;AAE9B,WAAS,IAAI,GAAG,IAAI,KAAK,IAAI,GAAG,QAAQ,GAAG,MAAM,GAAG,KAAK;AACvD,UAAM,KAAK,SAAS,GAAG,CAAC,KAAK,KAAK,EAAE;AACpC,UAAM,KAAK,SAAS,GAAG,CAAC,KAAK,KAAK,EAAE;AAEpC,QAAI,KAAK,IAAI;AACX,aAAO;AAAA,IACT;AACA,QAAI,KAAK,IAAI;AACX,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;;;ACHO,SAAS,IAAI,YAAY,OAAO;AACrC,aAAW,CAAC,KAAK,CAAC,MAAM,CAAC;AACzB,aAAW,CAAC,KAAK,CAAC,MAAM,CAAC;AACzB,SAAO;AACT;AASO,SAAS,gBAAgB,YAAY,QAAQ;AAClD,QAAM,IAAI,OAAO,UAAU;AAC3B,QAAM,SAAS,OAAO,UAAU;AAChC,QAAM,KAAK,OAAO,CAAC;AACnB,QAAM,KAAK,OAAO,CAAC;AACnB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AAEvB,MAAI,KAAK,KAAK;AACd,QAAM,KAAK,KAAK;AAChB,MAAI,OAAO,KAAK,OAAO,GAAG;AACxB,SAAK;AAAA,EACP;AACA,QAAM,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAErC,QAAM,IAAI,KAAM,IAAI,KAAM;AAC1B,QAAM,IAAI,KAAM,IAAI,KAAM;AAE1B,SAAO,CAAC,GAAG,CAAC;AACd;AAcO,SAAS,iBAAiB,YAAY,SAAS;AACpD,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,QAAQ,QAAQ,CAAC;AACvB,QAAM,MAAM,QAAQ,CAAC;AACrB,QAAM,KAAK,MAAM,CAAC;AAClB,QAAM,KAAK,MAAM,CAAC;AAClB,QAAM,KAAK,IAAI,CAAC;AAChB,QAAM,KAAK,IAAI,CAAC;AAChB,QAAM,KAAK,KAAK;AAChB,QAAM,KAAK,KAAK;AAChB,QAAM,QACJ,OAAO,KAAK,OAAO,IACf,KACC,MAAM,KAAK,MAAM,MAAM,KAAK,QAAQ,KAAK,KAAK,KAAK,MAAM;AAChE,MAAI,GAAG;AACP,MAAI,SAAS,GAAG;AACd,QAAI;AACJ,QAAI;AAAA,EACN,WAAW,SAAS,GAAG;AACrB,QAAI;AACJ,QAAI;AAAA,EACN,OAAO;AACL,QAAI,KAAK,QAAQ;AACjB,QAAI,KAAK,QAAQ;AAAA,EACnB;AACA,SAAO,CAAC,GAAG,CAAC;AACd;AA+HO,SAASG,QAAO,aAAa,aAAa;AAC/C,MAAIA,UAAS;AACb,WAAS,IAAI,YAAY,SAAS,GAAG,KAAK,GAAG,EAAE,GAAG;AAChD,QAAI,YAAY,CAAC,KAAK,YAAY,CAAC,GAAG;AACpC,MAAAA,UAAS;AACT;AAAA,IACF;AAAA,EACF;AACA,SAAOA;AACT;AAoBO,SAAS,OAAO,YAAY,OAAO;AACxC,QAAM,WAAW,KAAK,IAAI,KAAK;AAC/B,QAAM,WAAW,KAAK,IAAI,KAAK;AAC/B,QAAM,IAAI,WAAW,CAAC,IAAI,WAAW,WAAW,CAAC,IAAI;AACrD,QAAM,IAAI,WAAW,CAAC,IAAI,WAAW,WAAW,CAAC,IAAI;AACrD,aAAW,CAAC,IAAI;AAChB,aAAW,CAAC,IAAI;AAChB,SAAO;AACT;AAmBO,SAAS,MAAM,YAAYC,QAAO;AACvC,aAAW,CAAC,KAAKA;AACjB,aAAW,CAAC,KAAKA;AACjB,SAAO;AACT;AAOO,SAASC,iBAAgB,QAAQ,QAAQ;AAC9C,QAAM,KAAK,OAAO,CAAC,IAAI,OAAO,CAAC;AAC/B,QAAM,KAAK,OAAO,CAAC,IAAI,OAAO,CAAC;AAC/B,SAAO,KAAK,KAAK,KAAK;AACxB;AAOO,SAAS,SAAS,QAAQ,QAAQ;AACvC,SAAO,KAAK,KAAKA,iBAAgB,QAAQ,MAAM,CAAC;AAClD;AAUO,SAAS,yBAAyB,YAAY,SAAS;AAC5D,SAAOA,iBAAgB,YAAY,iBAAiB,YAAY,OAAO,CAAC;AAC1E;AA6EO,SAASC,OAAM,YAAY,YAAY;AAC5C,MAAI,WAAW,SAAS,GAAG;AACzB,UAAM,aAAa,SAAS,WAAW,UAAU,CAAC;AAClD,UAAM,aAAa,cAAc,YAAY,YAAY,UAAU;AACnE,QAAI,YAAY;AACd,iBAAW,CAAC,KAAK,aAAa;AAAA,IAChC;AAAA,EACF;AACA,SAAO;AACT;AAOO,SAAS,cAAc,YAAY,YAAY,mBAAmB;AACvE,QAAM,mBAAmB,WAAW,UAAU;AAC9C,MAAI,aAAa;AACjB,MACE,WAAW,SAAS,MACnB,WAAW,CAAC,IAAI,iBAAiB,CAAC,KAAK,WAAW,CAAC,IAAI,iBAAiB,CAAC,IAC1E;AACA,wBAAoB,qBAAqB,SAAS,gBAAgB;AAClE,iBAAa,KAAK;AAAA,OACf,WAAW,CAAC,IAAI,iBAAiB,CAAC,KAAK;AAAA,IAC1C;AAAA,EACF;AACA,SAAO;AACT;;;ACpZA,IAAM,UAAN,cAAsB,gBAAmB;AAAA;AAAA;AAAA;AAAA,EAIvC,YAAY,SAAS;AACnB,UAAM;AAAA,MACJ,UAAU;AAAA,IACZ,CAAC;AAED,cAAU,UAAU,UAAU,CAAC;AAM/B,SAAK,WAAW,QAAQ;AAKxB,SAAK,eAAe;AAKpB,SAAK;AAKL,SAAK,WAAW;AAEhB,UAAM,YAAY,QAAQ,YACtB,QAAQ,YACR,IAAI,gBAAgB,aAAa;AAMrC,SAAK,aAAa,QAAQ,cACtB,IAAI,mBAAmB,SAAS,IAChC;AAMJ,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,iBAAiB;AAC/B,UAAM,MAAM,gBAAgB;AAC5B,QAAI,CAAC,KAAK,UAAU;AAClB,WAAK,WAAW;AAChB,UAAI,QAAQ,EAAE,iBAAiB;AAAA,IACjC;AACA,UAAM,iBAAiB,KAAK;AAC5B,UAAMC,YAAW,IAAI,cAAc,SAAqB,cAAc,CAAC;AACvE,QAAI,eAAe,UAAU,KAAK,oBAAoB;AACpD,UAAI,KAAK,UAAU;AACjB,aAAK,SAAS,OAAOA,UAAS,CAAC,GAAGA,UAAS,CAAC,CAAC;AAAA,MAC/C;AACA,UAAI,KAAK,cAAc;AACrB,cAAM,QAAQ;AAAA,UACZ,KAAK,aAAa,CAAC,IAAIA,UAAS,CAAC;AAAA,UACjCA,UAAS,CAAC,IAAI,KAAK,aAAa,CAAC;AAAA,QACnC;AACA,cAAMC,OAAM,gBAAgB;AAC5B,cAAM,OAAOA,KAAI,QAAQ;AACzB,cAAgB,OAAO,KAAK,cAAc,CAAC;AAC3C,eAAiB,OAAO,KAAK,YAAY,CAAC;AAC1C,aAAK,qBAAqB,KAAK;AAAA,MACjC;AAAA,IACF,WAAW,KAAK,UAAU;AAGxB,WAAK,SAAS,MAAM;AAAA,IACtB;AACA,SAAK,eAAeD;AACpB,SAAK,qBAAqB,eAAe;AACzC,oBAAgB,cAAc,eAAe;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,iBAAiB;AAC7B,UAAM,MAAM,gBAAgB;AAC5B,UAAM,OAAO,IAAI,QAAQ;AACzB,QAAI,KAAK,eAAe,WAAW,GAAG;AACpC,UAAI,CAAC,KAAK,cAAc,KAAK,YAAY,KAAK,SAAS,IAAI,GAAG;AAC5D,cAAME,YAAW,KAAK,SAAS,YAAY;AAC3C,cAAM,QAAQ,KAAK,SAAS,SAAS;AACrC,cAAM,SAAS,KAAK,kBAAkB;AACtC,cAAM,WAAW,IAAI,+BAA+B,MAAM;AAC1D,cAAM,OAAO,IAAI,+BAA+B;AAAA,UAC9C,SAAS,CAAC,IAAIA,YAAW,KAAK,IAAI,KAAK;AAAA,UACvC,SAAS,CAAC,IAAIA,YAAW,KAAK,IAAI,KAAK;AAAA,QACzC,CAAC;AACD,aAAK,gBAAgB;AAAA,UACnB,QAAQ,KAAK,qBAAqB,IAAI;AAAA,UACtC,UAAU;AAAA,UACV,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AACA,UAAI,KAAK,UAAU;AACjB,aAAK,WAAW;AAChB,aAAK,eAAe;AAAA,MACtB;AACA,aAAO;AAAA,IACT;AACA,QAAI,KAAK,UAAU;AAGjB,WAAK,SAAS,MAAM;AAAA,IACtB;AACA,SAAK,eAAe;AACpB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,iBAAiB;AAC/B,QAAI,KAAK,eAAe,SAAS,KAAK,KAAK,WAAW,eAAe,GAAG;AACtE,YAAM,MAAM,gBAAgB;AAC5B,YAAM,OAAO,IAAI,QAAQ;AACzB,WAAK,eAAe;AAEpB,UAAI,KAAK,aAAa,GAAG;AACvB,aAAK,iBAAiB;AAAA,MACxB;AACA,UAAI,KAAK,UAAU;AACjB,aAAK,SAAS,MAAM;AAAA,MACtB;AAGA,WAAK,aAAa,KAAK,eAAe,SAAS;AAC/C,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACF;AAEA,IAAO,kBAAQ;;;AC9KR,SAAS,QAAQ,UAAU;AAChC,MAAI,aAAa,QAAW;AAC1B,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAMO,SAAS,KAAK,UAAU;AAC7B,MAAI,aAAa,QAAW;AAC1B,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAMO,SAAS,cAAc,GAAG;AAC/B,QAAM,QAAS,IAAI,KAAK,KAAM;AAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAME,SAAU,UAAU,UAAU;AAC5B,UAAI,UAAU;AACZ,eAAO;AAAA,MACT;AAEA,UAAI,aAAa,QAAW;AAC1B,mBAAW,KAAK,MAAM,WAAW,QAAQ,GAAG,IAAI;AAChD,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAAA;AAEJ;AAMO,SAAS,iBAAiB,WAAW;AAC1C,QAAM,IAAI,cAAc,SAAY,UAAU,CAAC,IAAI;AACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAME,SAAU,UAAU,UAAU;AAC5B,UAAI,YAAY,aAAa,QAAW;AACtC,eAAO;AAAA,MACT;AAEA,UAAI,KAAK,IAAI,QAAQ,KAAK,GAAG;AAC3B,eAAO;AAAA,MACT;AACA,aAAO;AAAA,IACT;AAAA;AAEJ;;;AClDA,IAAM,aAAN,cAAyB,gBAAmB;AAAA;AAAA;AAAA;AAAA,EAI1C,YAAY,SAAS;AACnB,cAAU,UAAU,UAAU,CAAC;AAE/B,UAAM;AAAA,MACJ,UAAU;AAAA,IACZ,CAAC;AAMD,SAAK,aAAa,QAAQ,YAAY,QAAQ,YAAY;AAM1D,SAAK,aAAa;AAMlB,SAAK,YAAY,QAAQ,aAAa,SAAY,QAAQ,WAAW;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,iBAAiB;AAC/B,QAAI,CAAC,UAAU,eAAe,GAAG;AAC/B;AAAA,IACF;AAEA,UAAM,MAAM,gBAAgB;AAC5B,UAAM,OAAO,IAAI,QAAQ;AACzB,QAAI,KAAK,eAAe,EAAE,aAAa,SAAS;AAC9C;AAAA,IACF;AACA,UAAM,OAAO,IAAI,QAAQ;AACzB,UAAMC,UAAS,gBAAgB;AAC/B,UAAM,QAAQ,KAAK,MAAM,KAAK,CAAC,IAAI,IAAIA,QAAO,CAAC,GAAGA,QAAO,CAAC,IAAI,KAAK,CAAC,IAAI,CAAC;AACzE,QAAI,KAAK,eAAe,QAAW;AACjC,YAAM,QAAQ,QAAQ,KAAK;AAC3B,WAAK,uBAAuB,CAAC,KAAK;AAAA,IACpC;AACA,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,iBAAiB;AAC7B,QAAI,CAAC,UAAU,eAAe,GAAG;AAC/B,aAAO;AAAA,IACT;AAEA,UAAM,MAAM,gBAAgB;AAC5B,UAAM,OAAO,IAAI,QAAQ;AACzB,SAAK,eAAe,KAAK,SAAS;AAClC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,iBAAiB;AAC/B,QAAI,CAAC,UAAU,eAAe,GAAG;AAC/B,aAAO;AAAA,IACT;AAEA,QACE,kBAAkB,eAAe,KACjC,KAAK,WAAW,eAAe,GAC/B;AACA,YAAM,MAAM,gBAAgB;AAC5B,UAAI,QAAQ,EAAE,iBAAiB;AAC/B,WAAK,aAAa;AAClB,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACF;AAEA,IAAO,qBAAQ;;;AC/Ff,IAAM,OAAO,IAAI,MAAM,CAAC;AAMjB,SAAS,SAAS;AACvB,SAAO,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC1B;AAOO,SAAS,MAAMC,YAAW;AAC/B,SAAO,IAAIA,YAAW,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACxC;AASO,SAAS,SAAS,YAAY,YAAY;AAC/C,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AACvB,QAAM,KAAK,WAAW,CAAC;AAEvB,aAAW,CAAC,IAAI,KAAK,KAAK,KAAK;AAC/B,aAAW,CAAC,IAAI,KAAK,KAAK,KAAK;AAC/B,aAAW,CAAC,IAAI,KAAK,KAAK,KAAK;AAC/B,aAAW,CAAC,IAAI,KAAK,KAAK,KAAK;AAC/B,aAAW,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK;AACpC,aAAW,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK;AAEpC,SAAO;AACT;AAaO,SAAS,IAAIA,YAAW,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAC/C,EAAAA,WAAU,CAAC,IAAI;AACf,EAAAA,WAAU,CAAC,IAAI;AACf,EAAAA,WAAU,CAAC,IAAI;AACf,EAAAA,WAAU,CAAC,IAAI;AACf,EAAAA,WAAU,CAAC,IAAI;AACf,EAAAA,WAAU,CAAC,IAAI;AACf,SAAOA;AACT;AAQO,SAAS,aAAa,YAAY,YAAY;AACnD,aAAW,CAAC,IAAI,WAAW,CAAC;AAC5B,aAAW,CAAC,IAAI,WAAW,CAAC;AAC5B,aAAW,CAAC,IAAI,WAAW,CAAC;AAC5B,aAAW,CAAC,IAAI,WAAW,CAAC;AAC5B,aAAW,CAAC,IAAI,WAAW,CAAC;AAC5B,aAAW,CAAC,IAAI,WAAW,CAAC;AAC5B,SAAO;AACT;AAWO,SAAS,MAAMA,YAAW,YAAY;AAC3C,QAAM,IAAI,WAAW,CAAC;AACtB,QAAM,IAAI,WAAW,CAAC;AACtB,aAAW,CAAC,IAAIA,WAAU,CAAC,IAAI,IAAIA,WAAU,CAAC,IAAI,IAAIA,WAAU,CAAC;AACjE,aAAW,CAAC,IAAIA,WAAU,CAAC,IAAI,IAAIA,WAAU,CAAC,IAAI,IAAIA,WAAU,CAAC;AACjE,SAAO;AACT;AAQO,SAASC,QAAOD,YAAW,OAAO;AACvC,QAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,QAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,SAAO,SAASA,YAAW,IAAI,MAAM,KAAK,KAAK,CAAC,KAAK,KAAK,GAAG,CAAC,CAAC;AACjE;AASO,SAASE,OAAMF,YAAW,GAAG,GAAG;AACrC,SAAO,SAASA,YAAW,IAAI,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC,CAAC;AACxD;AAoBO,SAAS,UAAUG,YAAW,IAAI,IAAI;AAC3C,SAAO,SAASA,YAAW,IAAI,MAAM,GAAG,GAAG,GAAG,GAAG,IAAI,EAAE,CAAC;AAC1D;AAeO,SAAS,QAAQA,YAAW,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK;AACpE,QAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,QAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,EAAAA,WAAU,CAAC,IAAI,KAAK;AACpB,EAAAA,WAAU,CAAC,IAAI,KAAK;AACpB,EAAAA,WAAU,CAAC,IAAI,CAAC,KAAK;AACrB,EAAAA,WAAU,CAAC,IAAI,KAAK;AACpB,EAAAA,WAAU,CAAC,IAAI,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM;AACjD,EAAAA,WAAU,CAAC,IAAI,MAAM,KAAK,MAAM,MAAM,KAAK,MAAM;AACjD,SAAOA;AACT;AAoCO,SAAS,YAAY,QAAQ,QAAQ;AAC1C,QAAM,MAAM,YAAY,MAAM;AAC9B,SAAO,QAAQ,GAAG,0CAA0C;AAE5D,QAAM,IAAI,OAAO,CAAC;AAClB,QAAM,IAAI,OAAO,CAAC;AAClB,QAAM,IAAI,OAAO,CAAC;AAClB,QAAM,IAAI,OAAO,CAAC;AAClB,QAAM,IAAI,OAAO,CAAC;AAClB,QAAM,IAAI,OAAO,CAAC;AAElB,SAAO,CAAC,IAAI,IAAI;AAChB,SAAO,CAAC,IAAI,CAAC,IAAI;AACjB,SAAO,CAAC,IAAI,CAAC,IAAI;AACjB,SAAO,CAAC,IAAI,IAAI;AAChB,SAAO,CAAC,KAAK,IAAI,IAAI,IAAI,KAAK;AAC9B,SAAO,CAAC,IAAI,EAAE,IAAI,IAAI,IAAI,KAAK;AAE/B,SAAO;AACT;AAOO,SAAS,YAAY,KAAK;AAC/B,SAAO,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,IAAI,CAAC;AACzC;AAKA,IAAM,kBAAkB,CAAC,KAAK,KAAK,KAAK,KAAK,GAAG,CAAC;AAQ1C,SAAS,SAAS,KAAK;AAC5B,QAAM,kBACJ,YACA,IACG;AAAA,IACC,CAAC,OAAO,MACN,KAAK,MAAM,QAAQ,gBAAgB,CAAC,CAAC,IAAI,gBAAgB,CAAC;AAAA,EAC9D,EACC,KAAK,IAAI,IACZ;AACF,SAAO;AACT;;;ACnRA,IAAM,aAAa;AAAA,EACjB,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AACV;AAMO,SAAS,SAAS,MAAM;AAC7B,SAAO,WAAW,IAAI;AACxB;AAiBO,IAAM,kBAAkB;AAAA;AAAA,EAE7B,WAAW,WAAW,IAAI,KAAK;AAAA,EAC/B,WAAY,IAAI,KAAK,KAAK,UAAW;AAAA,EACrC,MAAM;AAAA,EACN,KAAK;AAAA,EACL,SAAS,OAAO;AAClB;;;ACAA,IAAM,aAAN,MAAiB;AAAA;AAAA;AAAA;AAAA,EAIf,YAAY,SAAS;AAKnB,SAAK,QAAQ,QAAQ;AASrB,SAAK;AAAA,IAAoD,QAAQ;AASjE,SAAK,UAAU,QAAQ,WAAW,SAAY,QAAQ,SAAS;AAS/D,SAAK,eACH,QAAQ,gBAAgB,SAAY,QAAQ,cAAc;AAM5D,SAAK,mBACH,QAAQ,oBAAoB,SAAY,QAAQ,kBAAkB;AAMpE,SAAK,UAAU,QAAQ,WAAW,SAAY,QAAQ,SAAS;AAM/D,SAAK,YAAY,CAAC,EAAE,KAAK,WAAW,KAAK;AAMzC,SAAK,0BAA0B,QAAQ;AAMvC,SAAK,mBAAmB;AAMxB,SAAK,iBAAiB,QAAQ;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY;AACV,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,mBAAmB;AACjB,WAAO,KAAK,kBAAkB,gBAAgB,KAAK,MAAM;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiB;AACf,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,qBAAqB;AACnB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU,QAAQ;AAChB,SAAK,UAAU;AACf,SAAK,YAAY,CAAC,EAAE,UAAU,KAAK;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB;AACnB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,UAAU;AAC3B,SAAK,mBAAmB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU,QAAQ;AAChB,SAAK,UAAU;AACf,SAAK,YAAY,CAAC,EAAE,KAAK,WAAW;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,eAAe,aAAa;AAC1B,SAAK,eAAe;AAAA,EACtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,sBAAsB,MAAM;AAC1B,SAAK,0BAA0B;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,yBAAyB;AACvB,WAAO,KAAK;AAAA,EACd;AACF;AAEA,IAAO,qBAAQ;;;ACnQR,IAAM,SAAS;AAMf,IAAM,YAAY,KAAK,KAAK;AAM5B,IAAM,SAAS,CAAC,CAAC,WAAW,CAAC,WAAW,WAAW,SAAS;AAM5D,IAAM,eAAe,CAAC,MAAM,KAAK,KAAK,EAAE;AAOxC,IAAM,aAAa,SAAS,KAAK,IAAI,KAAK,IAAI,KAAK,KAAK,CAAC,CAAC;AAMjE,IAAM,qBAAN,cAAiC,mBAAW;AAAA;AAAA;AAAA;AAAA,EAI1C,YAAY,MAAM;AAChB,UAAM;AAAA,MACJ;AAAA,MACA,OAAO;AAAA,MACP,QAAQ;AAAA,MACR,QAAQ;AAAA,MACR,aAAa;AAAA,MACb,oBAAoB,SAAU,YAAY,OAAO;AAC/C,eAAO,aAAa,KAAK,KAAK,MAAM,CAAC,IAAI,MAAM;AAAA,MACjD;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAQO,IAAM,cAAc;AAAA,EACzB,IAAI,mBAAmB,WAAW;AAAA,EAClC,IAAI,mBAAmB,aAAa;AAAA,EACpC,IAAI,mBAAmB,aAAa;AAAA,EACpC,IAAI,mBAAmB,aAAa;AAAA,EACpC,IAAI,mBAAmB,4CAA4C;AAAA,EACnE,IAAI,mBAAmB,8CAA8C;AACvE;AAUO,SAAS,aAAa,OAAO,QAAQ,WAAW;AACrD,QAAM,SAAS,MAAM;AACrB,cAAY,YAAY,IAAI,YAAY;AACxC,MAAI,WAAW,QAAW;AACxB,QAAI,YAAY,GAAG;AAEjB,eAAS,MAAM,MAAM;AAAA,IACvB,OAAO;AACL,eAAS,IAAI,MAAM,MAAM;AAAA,IAC3B;AAAA,EACF;AACA,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,WAAW;AAC1C,WAAO,CAAC,IAAK,YAAY,MAAM,CAAC,IAAK;AACrC,QAAI,IAAI,SAAS,KAAK,IAAI,KAAK,IAAK,KAAK,MAAM,CAAC,MAAM,IAAI,CAAC,IAAI,MAAO,GAAG,CAAC;AAC1E,QAAI,IAAI,YAAY;AAClB,UAAI;AAAA,IACN,WAAW,IAAI,CAAC,YAAY;AAC1B,UAAI,CAAC;AAAA,IACP;AACA,WAAO,IAAI,CAAC,IAAI;AAAA,EAClB;AACA,SAAO;AACT;AAUO,SAAS,WAAW,OAAO,QAAQ,WAAW;AACnD,QAAM,SAAS,MAAM;AACrB,cAAY,YAAY,IAAI,YAAY;AACxC,MAAI,WAAW,QAAW;AACxB,QAAI,YAAY,GAAG;AAEjB,eAAS,MAAM,MAAM;AAAA,IACvB,OAAO;AACL,eAAS,IAAI,MAAM,MAAM;AAAA,IAC3B;AAAA,EACF;AACA,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,WAAW;AAC1C,WAAO,CAAC,IAAK,MAAM,MAAM,CAAC,IAAK;AAC/B,WAAO,IAAI,CAAC,IACT,MAAM,KAAK,KAAK,KAAK,IAAI,MAAM,IAAI,CAAC,IAAI,MAAM,CAAC,IAAK,KAAK,KAAK;AAAA,EACnE;AACA,SAAO;AACT;;;ACzHO,IAAMC,UAAS;AAQf,IAAMC,UAAS,CAAC,MAAM,KAAK,KAAK,EAAE;AAMlC,IAAMC,mBAAmB,KAAK,KAAKF,UAAU;AAUpD,IAAM,qBAAN,cAAiC,mBAAW;AAAA;AAAA;AAAA;AAAA;AAAA,EAK1C,YAAY,MAAM,iBAAiB;AACjC,UAAM;AAAA,MACJ;AAAA,MACA,OAAO;AAAA,MACP,QAAQC;AAAA,MACR;AAAA,MACA,QAAQ;AAAA,MACR,eAAeC;AAAA,MACf,aAAaD;AAAA,IACf,CAAC;AAAA,EACH;AACF;AAQO,IAAME,eAAc;AAAA,EACzB,IAAI,mBAAmB,QAAQ;AAAA,EAC/B,IAAI,mBAAmB,aAAa,KAAK;AAAA,EACzC,IAAI,mBAAmB,+BAA+B;AAAA,EACtD,IAAI,mBAAmB,0BAA0B;AAAA,EACjD,IAAI,mBAAmB,8CAA8C;AAAA,EACrE,IAAI,mBAAmB,gDAAgD,KAAK;AAAA,EAC5E,IAAI,mBAAmB,8CAA8C,KAAK;AAC5E;;;AC5DA,IAAI,QAAQ,CAAC;AAcN,SAAS,IAAI,MAAM;AACxB,SACE,MAAM,IAAI,KACV,MAAM,KAAK,QAAQ,0CAA0C,SAAS,CAAC,KACvE;AAEJ;AAOO,SAASC,KAAI,MAAM,YAAY;AACpC,QAAM,IAAI,IAAI;AAChB;;;AC3BA,IAAI,aAAa,CAAC;AAiBX,SAASC,KAAI,QAAQ,aAAa,aAAa;AACpD,QAAM,aAAa,OAAO,QAAQ;AAClC,QAAM,kBAAkB,YAAY,QAAQ;AAC5C,MAAI,EAAE,cAAc,aAAa;AAC/B,eAAW,UAAU,IAAI,CAAC;AAAA,EAC5B;AACA,aAAW,UAAU,EAAE,eAAe,IAAI;AAC5C;AA4BO,SAASC,KAAI,YAAY,iBAAiB;AAC/C,MAAIC;AACJ,MAAI,cAAc,cAAc,mBAAmB,WAAW,UAAU,GAAG;AACzE,IAAAA,aAAY,WAAW,UAAU,EAAE,eAAe;AAAA,EACpD;AACA,SAAOA;AACT;;;AC7CO,IAAM,iBAAiB;AAWvB,SAAS,YAAY,IAAI,IAAI,QAAQ;AAC1C,WAAS,UAAU;AACnB,QAAM,OAAO,UAAU,GAAG,CAAC,CAAC;AAC5B,QAAM,OAAO,UAAU,GAAG,CAAC,CAAC;AAC5B,QAAM,eAAe,OAAO,QAAQ;AACpC,QAAM,cAAc,UAAU,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI;AAC/C,QAAM,IACJ,KAAK,IAAI,WAAW,IAAI,KAAK,IAAI,WAAW,IAC5C,KAAK,IAAI,WAAW,IAClB,KAAK,IAAI,WAAW,IACpB,KAAK,IAAI,IAAI,IACb,KAAK,IAAI,IAAI;AACjB,SAAO,IAAI,SAAS,KAAK,MAAM,KAAK,KAAK,CAAC,GAAG,KAAK,KAAK,IAAI,CAAC,CAAC;AAC/D;AAwMO,SAAS,OAAO,IAAIC,WAAU,SAAS,QAAQ;AACpD,WAAS,UAAU;AACnB,QAAM,OAAO,UAAU,GAAG,CAAC,CAAC;AAC5B,QAAM,OAAO,UAAU,GAAG,CAAC,CAAC;AAC5B,QAAM,OAAOA,YAAW;AACxB,QAAM,MAAM,KAAK;AAAA,IACf,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAC5B,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,OAAO;AAAA,EACtD;AACA,QAAM,MACJ,OACA,KAAK;AAAA,IACH,KAAK,IAAI,OAAO,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI;AAAA,IAClD,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,GAAG;AAAA,EAChD;AACF,SAAO,CAAC,UAAU,GAAG,GAAG,UAAU,GAAG,CAAC;AACxC;;;AC3PA,IAAM,SAAS;AAAA,EACb,MAAM;AAAA,EACN,MAAM;AAAA,EACN,OAAO;AAAA,EACP,MAAM;AACR;AAKA,IAAI,QAAQ,OAAO;AA0BZ,SAAS,QAAQ,MAAM;AAC5B,MAAI,QAAQ,OAAO,MAAM;AACvB;AAAA,EACF;AACA,UAAQ,KAAK,GAAG,IAAI;AACtB;AAKO,SAAS,SAAS,MAAM;AAC7B,MAAI,QAAQ,OAAO,OAAO;AACxB;AAAA,EACF;AACA,UAAQ,MAAM,GAAG,IAAI;AACvB;;;ACsCA,IAAI,wBAAwB;AAKrB,SAAS,yBAAyBC,UAAS;AAChD,QAAM,OAAOA,aAAY,SAAY,OAAOA;AAC5C,0BAAwB,CAAC;AAC3B;AAQO,SAAS,eAAe,OAAO,QAAQ;AAC5C,MAAI,WAAW,QAAW;AACxB,aAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,aAAO,CAAC,IAAI,MAAM,CAAC;AAAA,IACrB;AACA,aAAS;AAAA,EACX,OAAO;AACL,aAAS,MAAM,MAAM;AAAA,EACvB;AACA,SAAO;AACT;AAOO,SAAS,kBAAkB,OAAO,QAAQ;AAC/C,MAAI,WAAW,UAAa,UAAU,QAAQ;AAC5C,aAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,aAAO,CAAC,IAAI,MAAM,CAAC;AAAA,IACrB;AACA,YAAQ;AAAA,EACV;AACA,SAAO;AACT;AASO,SAAS,cAAc,YAAY;AACxC,EAAAC,KAAQ,WAAW,QAAQ,GAAG,UAAU;AACxC,EAAAA,KAAiB,YAAY,YAAY,cAAc;AACzD;AAKO,SAAS,eAAe,aAAa;AAC1C,cAAY,QAAQ,aAAa;AACnC;AAWO,SAASC,KAAI,gBAAgB;AAClC,SAAO,OAAO,mBAAmB,WAC7B;AAAA;AAAA,IAA+B;AAAA,EAAe;AAAA;AAAA,IACnB,kBAAmB;AAAA;AACpD;AAsBO,SAAS,mBAAmB,YAAY,YAAY,OAAO,OAAO;AACvE,eAAaA,KAAI,UAAU;AAC3B,MAAI;AACJ,QAAM,SAAS,WAAW,uBAAuB;AACjD,MAAI,QAAQ;AACV,sBAAkB,OAAO,YAAY,KAAK;AAC1C,QAAI,SAAS,UAAU,WAAW,SAAS,GAAG;AAC5C,YAAM,gBAAgB,WAAW,iBAAiB;AAClD,UAAI,eAAe;AACjB,0BACG,kBAAkB,gBAAiB,gBAAgB,KAAK;AAAA,MAC7D;AAAA,IACF;AAAA,EACF,OAAO;AACL,UAAM,YAAY,WAAW,SAAS;AACtC,QAAK,aAAa,aAAa,CAAC,SAAU,SAAS,WAAW;AAC5D,wBAAkB;AAAA,IACpB,OAAO;AAIL,YAAMC,cAAa;AAAA,QACjB;AAAA,QACAD,KAAI,WAAW;AAAA,MACjB;AACA,UAAIC,gBAAe,qBAAqB,cAAc,WAAW;AAE/D,0BAAkB,aAAa,WAAW,iBAAiB;AAAA,MAC7D,OAAO;AACL,YAAI,WAAW;AAAA,UACb,MAAM,CAAC,IAAI,aAAa;AAAA,UACxB,MAAM,CAAC;AAAA,UACP,MAAM,CAAC,IAAI,aAAa;AAAA,UACxB,MAAM,CAAC;AAAA,UACP,MAAM,CAAC;AAAA,UACP,MAAM,CAAC,IAAI,aAAa;AAAA,UACxB,MAAM,CAAC;AAAA,UACP,MAAM,CAAC,IAAI,aAAa;AAAA,QAC1B;AACA,mBAAWA,YAAW,UAAU,UAAU,CAAC;AAC3C,cAAM,QAAQ,YAAY,SAAS,MAAM,GAAG,CAAC,GAAG,SAAS,MAAM,GAAG,CAAC,CAAC;AACpE,cAAM,SAAS,YAAY,SAAS,MAAM,GAAG,CAAC,GAAG,SAAS,MAAM,GAAG,CAAC,CAAC;AACrE,2BAAmB,QAAQ,UAAU;AAAA,MACvC;AACA,YAAM,gBAAgB,QAClB,gBAAgB,KAAK,IACrB,WAAW,iBAAiB;AAChC,UAAI,kBAAkB,QAAW;AAC/B,2BAAmB;AAAA,MACrB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AASO,SAAS,yBAAyB,aAAa;AACpD,iBAAe,WAAW;AAC1B,cAAY,QAAQ,SAAU,QAAQ;AACpC,gBAAY,QAAQ,SAAU,aAAa;AACzC,UAAI,WAAW,aAAa;AAC1B,QAAAF,KAAiB,QAAQ,aAAa,cAAc;AAAA,MACtD;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACH;AAeO,SAAS,wBACd,cACA,cACA,kBACA,kBACA;AACA,eAAa,QAAQ,SAAU,aAAa;AAC1C,iBAAa,QAAQ,SAAU,aAAa;AAC1C,MAAAA,KAAiB,aAAa,aAAa,gBAAgB;AAC3D,MAAAA,KAAiB,aAAa,aAAa,gBAAgB;AAAA,IAC7D,CAAC;AAAA,EACH,CAAC;AACH;AAeO,SAAS,iBAAiB,YAAY,aAAa;AACxD,MAAI,CAAC,YAAY;AACf,WAAOG,KAAI,WAAW;AAAA,EACxB;AACA,MAAI,OAAO,eAAe,UAAU;AAClC,WAAOA,KAAI,UAAU;AAAA,EACvB;AACA;AAAA;AAAA,IAAkC;AAAA;AACpC;AASO,SAAS,uCAAuC,gBAAgB;AACrE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOE,SAAU,OAAO,QAAQ,WAAW;AAClC,YAAM,SAAS,MAAM;AACrB,kBAAY,cAAc,SAAY,YAAY;AAClD,eAAS,WAAW,SAAY,SAAS,IAAI,MAAM,MAAM;AACzD,eAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,WAAW;AAC1C,cAAM,QAAQ,eAAe,MAAM,MAAM,GAAG,IAAI,SAAS,CAAC;AAC1D,cAAM,cAAc,MAAM;AAC1B,iBAAS,IAAI,GAAG,KAAK,WAAW,IAAI,IAAI,EAAE,GAAG;AAC3C,iBAAO,IAAI,CAAC,IAAI,KAAK,cAAc,MAAM,IAAI,CAAC,IAAI,MAAM,CAAC;AAAA,QAC3D;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA;AAEJ;AAwBO,SAAS,wBAAwB,QAAQ,aAAa,SAAS,SAAS;AAC7E,QAAM,aAAaA,KAAI,MAAM;AAC7B,QAAM,WAAWA,KAAI,WAAW;AAChC,EAAAC;AAAA,IACE;AAAA,IACA;AAAA,IACA,uCAAuC,OAAO;AAAA,EAChD;AACA,EAAAA;AAAA,IACE;AAAA,IACA;AAAA,IACA,uCAAuC,OAAO;AAAA,EAChD;AACF;AAoDO,SAAS,WAAW,aAAa,aAAa;AACnD,MAAI,gBAAgB,aAAa;AAC/B,WAAO;AAAA,EACT;AACA,QAAM,aAAa,YAAY,SAAS,MAAM,YAAY,SAAS;AACnE,MAAI,YAAY,QAAQ,MAAM,YAAY,QAAQ,GAAG;AACnD,WAAO;AAAA,EACT;AACA,QAAM,gBAAgB,4BAA4B,aAAa,WAAW;AAC1E,SAAO,kBAAkB,kBAAkB;AAC7C;AAWO,SAAS,4BACd,kBACA,uBACA;AACA,QAAM,aAAa,iBAAiB,QAAQ;AAC5C,QAAM,kBAAkB,sBAAsB,QAAQ;AACtD,MAAI,gBAAgBC,KAAiB,YAAY,eAAe;AAChE,MAAI,CAAC,eAAe;AAClB,oBAAgB;AAAA,EAClB;AACA,SAAO;AACT;AAYO,SAAS,aAAa,QAAQ,aAAa;AAChD,QAAM,mBAAmBA,KAAI,MAAM;AACnC,QAAM,wBAAwBA,KAAI,WAAW;AAC7C,SAAO,4BAA4B,kBAAkB,qBAAqB;AAC5E;AAgBO,SAAS,UAAU,YAAY,QAAQ,aAAa;AACzD,QAAM,gBAAgB,aAAa,QAAQ,WAAW;AACtD,SAAO,cAAc,YAAY,QAAW,WAAW,MAAM;AAC/D;AAcO,SAAS,gBAAgB,QAAQ,QAAQ,aAAa,OAAO;AAClE,QAAM,gBAAgB,aAAa,QAAQ,WAAW;AACtD,SAAO,eAAe,QAAQ,eAAe,QAAW,KAAK;AAC/D;AAyBA,IAAI,iBAAiB;AA0Bd,SAAS,oBAAoB;AAClC,SAAO;AACT;AAmBO,SAAS,iBAAiB,YAAY,kBAAkB;AAC7D,MAAI,CAAC,gBAAgB;AACnB,WAAO;AAAA,EACT;AACA,SAAO,UAAU,YAAY,kBAAkB,cAAc;AAC/D;AASO,SAAS,mBAAmB,YAAY,gBAAgB;AAC7D,MAAI,CAAC,gBAAgB;AACnB,QACE,yBACA,CAACC,QAAO,YAAY,CAAC,GAAG,CAAC,CAAC,KAC1B,WAAW,CAAC,KAAK,QACjB,WAAW,CAAC,KAAK,OACjB,WAAW,CAAC,KAAK,OACjB,WAAW,CAAC,KAAK,IACjB;AACA,8BAAwB;AACxB;AAAA,QACE;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO,UAAU,YAAY,gBAAgB,cAAc;AAC7D;AASO,SAAS,aAAa,QAAQ,kBAAkB;AACrD,MAAI,CAAC,gBAAgB;AACnB,WAAO;AAAA,EACT;AACA,SAAO,gBAAgB,QAAQ,kBAAkB,cAAc;AACjE;AASO,SAAS,eAAe,QAAQ,gBAAgB;AACrD,MAAI,CAAC,gBAAgB;AACnB,WAAO;AAAA,EACT;AACA,SAAO,gBAAgB,QAAQ,gBAAgB,cAAc;AAC/D;AAUO,SAAS,iBAAiB,YAAY,kBAAkB;AAC7D,MAAI,CAAC,gBAAgB;AACnB,WAAO;AAAA,EACT;AACA,QAAM,sBAAsBC,KAAI,gBAAgB,EAAE,iBAAiB;AACnE,QAAM,oBAAoB,eAAe,iBAAiB;AAC1D,SAAO,uBAAuB,oBACzB,aAAa,sBAAuB,oBACrC;AACN;AAUO,SAAS,mBAAmB,YAAY,gBAAgB;AAC7D,MAAI,CAAC,gBAAgB;AACnB,WAAO;AAAA,EACT;AACA,QAAM,oBAAoBA,KAAI,cAAc,EAAE,iBAAiB;AAC/D,QAAM,oBAAoB,eAAe,iBAAiB;AAC1D,SAAO,qBAAqB,oBACvB,aAAa,oBAAqB,oBACnC;AACN;AAYO,SAAS,8BAA8B,YAAY,UAAUC,YAAW;AAC7E,SAAO,SAAU,OAAO;AACtB,QAAI,aAAa;AACjB,QAAI,WAAW,SAAS,GAAG;AACzB,YAAM,eAAe,WAAW,UAAU;AAC1C,YAAM,oBAAoB,SAAS,YAAY;AAC/C,cAAQ,MAAM,MAAM,CAAC;AACrB,mBAAa,cAAc,OAAO,YAAY,iBAAiB;AAC/D,UAAI,YAAY;AAEd,cAAM,CAAC,IAAI,MAAM,CAAC,IAAI,aAAa;AAAA,MACrC;AACA,YAAM,CAAC,IAAI,MAAM,MAAM,CAAC,GAAG,aAAa,CAAC,GAAG,aAAa,CAAC,CAAC;AAC3D,YAAM,CAAC,IAAI,MAAM,MAAM,CAAC,GAAG,aAAa,CAAC,GAAG,aAAa,CAAC,CAAC;AAC3D,oBAAcA,WAAU,KAAK;AAAA,IAC/B,OAAO;AACL,oBAAcA,WAAU,KAAK;AAAA,IAC/B;AACA,QAAI,cAAc,SAAS,SAAS,GAAG;AAErC,kBAAY,CAAC,KAAK,aAAa,SAAS,SAAS,UAAU,CAAC;AAAA,IAC9D;AACA,WAAO;AAAA,EACT;AACF;AAOO,SAAS,YAAY;AAG1B,2BAAyB,WAAoB;AAC7C,2BAAyBC,YAAoB;AAG7C;AAAA,IACEA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAEA,UAAU;;;ACjuBH,SAAS,YACd,iBACAC,SACA,KACA,QACAC,YACA,MACA;AACA,SAAO,OAAO,OAAO,CAAC;AACtB,MAAI,IAAI;AACR,WAAS,IAAID,SAAQ,IAAI,KAAK,KAAK,QAAQ;AACzC,UAAM,IAAI,gBAAgB,CAAC;AAC3B,UAAM,IAAI,gBAAgB,IAAI,CAAC;AAC/B,SAAK,GAAG,IAAIC,WAAU,CAAC,IAAI,IAAIA,WAAU,CAAC,IAAI,IAAIA,WAAU,CAAC;AAC7D,SAAK,GAAG,IAAIA,WAAU,CAAC,IAAI,IAAIA,WAAU,CAAC,IAAI,IAAIA,WAAU,CAAC;AAAA,EAC/D;AACA,MAAI,QAAQ,KAAK,UAAU,GAAG;AAC5B,SAAK,SAAS;AAAA,EAChB;AACA,SAAO;AACT;AAYO,SAASC,QACd,iBACAF,SACA,KACA,QACA,OACA,QACA,MACA;AACA,SAAO,OAAO,OAAO,CAAC;AACtB,QAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,QAAM,MAAM,KAAK,IAAI,KAAK;AAC1B,QAAM,UAAU,OAAO,CAAC;AACxB,QAAM,UAAU,OAAO,CAAC;AACxB,MAAI,IAAI;AACR,WAAS,IAAIA,SAAQ,IAAI,KAAK,KAAK,QAAQ;AACzC,UAAM,SAAS,gBAAgB,CAAC,IAAI;AACpC,UAAM,SAAS,gBAAgB,IAAI,CAAC,IAAI;AACxC,SAAK,GAAG,IAAI,UAAU,SAAS,MAAM,SAAS;AAC9C,SAAK,GAAG,IAAI,UAAU,SAAS,MAAM,SAAS;AAC9C,aAAS,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,EAAE,GAAG;AACvC,WAAK,GAAG,IAAI,gBAAgB,CAAC;AAAA,IAC/B;AAAA,EACF;AACA,MAAI,QAAQ,KAAK,UAAU,GAAG;AAC5B,SAAK,SAAS;AAAA,EAChB;AACA,SAAO;AACT;AAcO,SAASG,OACd,iBACAH,SACA,KACA,QACA,IACA,IACA,QACA,MACA;AACA,SAAO,OAAO,OAAO,CAAC;AACtB,QAAM,UAAU,OAAO,CAAC;AACxB,QAAM,UAAU,OAAO,CAAC;AACxB,MAAI,IAAI;AACR,WAAS,IAAIA,SAAQ,IAAI,KAAK,KAAK,QAAQ;AACzC,UAAM,SAAS,gBAAgB,CAAC,IAAI;AACpC,UAAM,SAAS,gBAAgB,IAAI,CAAC,IAAI;AACxC,SAAK,GAAG,IAAI,UAAU,KAAK;AAC3B,SAAK,GAAG,IAAI,UAAU,KAAK;AAC3B,aAAS,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,EAAE,GAAG;AACvC,WAAK,GAAG,IAAI,gBAAgB,CAAC;AAAA,IAC/B;AAAA,EACF;AACA,MAAI,QAAQ,KAAK,UAAU,GAAG;AAC5B,SAAK,SAAS;AAAA,EAChB;AACA,SAAO;AACT;AAYO,SAASI,WACd,iBACAJ,SACA,KACA,QACA,QACA,QACA,MACA;AACA,SAAO,OAAO,OAAO,CAAC;AACtB,MAAI,IAAI;AACR,WAAS,IAAIA,SAAQ,IAAI,KAAK,KAAK,QAAQ;AACzC,SAAK,GAAG,IAAI,gBAAgB,CAAC,IAAI;AACjC,SAAK,GAAG,IAAI,gBAAgB,IAAI,CAAC,IAAI;AACrC,aAAS,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,EAAE,GAAG;AACvC,WAAK,GAAG,IAAI,gBAAgB,CAAC;AAAA,IAC/B;AAAA,EACF;AACA,MAAI,QAAQ,KAAK,UAAU,GAAG;AAC5B,SAAK,SAAS;AAAA,EAChB;AACA,SAAO;AACT;;;ACjHA,IAAM,eAAe,OAAgB;AAcrC,IAAM,WAAN,cAAuB,eAAW;AAAA,EAChC,cAAc;AACZ,UAAM;AAMN,SAAK,UAAU,YAAY;AAM3B,SAAK,kBAAkB;AAMvB,SAAK,2CAA2C;AAMhD,SAAK,6BAA6B;AAUlC,SAAK,8BAA8B;AAAA,MACjC,CAAC,UAAU,kBAAkBK,eAAc;AACzC,YAAI,CAACA,YAAW;AACd,iBAAO,KAAK,sBAAsB,gBAAgB;AAAA,QACpD;AACA,cAAMC,SAAQ,KAAK,MAAM;AACzB,QAAAA,OAAM,eAAeD,UAAS;AAC9B,eAAOC,OAAM,sBAAsB,gBAAgB;AAAA,MACrD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,oBAAoB,kBAAkBD,YAAW;AAC/C,WAAO,KAAK;AAAA,MACV,KAAK,YAAY;AAAA,MACjB;AAAA,MACAA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ;AACN,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,eAAe,GAAG,GAAG,cAAc,oBAAoB;AACrD,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,GAAG,GAAG;AACf,UAAM,QAAQ,KAAK,gBAAgB,CAAC,GAAG,CAAC,CAAC;AACzC,WAAO,MAAM,CAAC,MAAM,KAAK,MAAM,CAAC,MAAM;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,gBAAgB,OAAO,cAAc;AACnC,mBAAe,eAAe,eAAe,CAAC,KAAK,GAAG;AACtD,SAAK,eAAe,MAAM,CAAC,GAAG,MAAM,CAAC,GAAG,cAAc,QAAQ;AAC9D,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,qBAAqB,YAAY;AAC/B,WAAO,KAAK,WAAW,WAAW,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,cAAc,QAAQ;AACpB,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,QAAQ;AAChB,QAAI,KAAK,mBAAmB,KAAK,YAAY,GAAG;AAC9C,YAAME,UAAS,KAAK,cAAc,KAAK,OAAO;AAC9C,UAAI,MAAMA,QAAO,CAAC,CAAC,KAAK,MAAMA,QAAO,CAAC,CAAC,GAAG;AACxC,4BAAoBA,OAAM;AAAA,MAC5B;AACA,WAAK,kBAAkB,KAAK,YAAY;AAAA,IAC1C;AACA,WAAO,eAAe,KAAK,SAAS,MAAM;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,OAAO,OAAO,QAAQ;AACpB,aAAS;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAM,IAAI,IAAI,QAAQ;AACpB,aAAS;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,SAAS,WAAW;AAClB,WAAO,KAAK,sBAAsB,YAAY,SAAS;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,sBAAsB,kBAAkB;AACtC,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,eAAe,aAAa;AAC1B,aAAS;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiB,QAAQ;AACvB,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAU,QAAQ,QAAQ;AACxB,aAAS;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiBA,UAAU,QAAQ,aAAa;AAE7B,UAAM,aAAaC,KAAc,MAAM;AACvC,UAAM,cACJ,WAAW,SAAS,KAAK,gBACrB,SAAU,eAAe,gBAAgB,QAAQ;AAC/C,YAAM,cAAc,WAAW,UAAU;AACzC,YAAM,kBAAkB,WAAW,eAAe;AAClD,YAAMC,SAAQ,UAAU,eAAe,IAAI,UAAU,WAAW;AAChE;AAAA,QACE;AAAA,QACA,gBAAgB,CAAC;AAAA,QACjB,gBAAgB,CAAC;AAAA,QACjBA;AAAA,QACA,CAACA;AAAA,QACD;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA;AAAA,QACE;AAAA,QACA;AAAA,QACA,cAAc;AAAA,QACd;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,aAAO,aAAa,YAAY,WAAW;AAAA,QACzC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,IACA,aAAa,YAAY,WAAW;AAC1C,SAAK,eAAe,WAAW;AAC/B,WAAO;AAAA,EACT;AACF;AAEA,IAAO,mBAAQ;;;ACxUf,IAAM,iBAAN,cAA6B,iBAAS;AAAA,EACpC,cAAc;AACZ,UAAM;AAMN,SAAK,SAAS;AAMd,SAAK,SAAS;AAMd,SAAK;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,QAAQ;AACpB,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA,KAAK,gBAAgB;AAAA,MACrB,KAAK;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB;AACf,WAAO,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,qBAAqB;AACnB,WAAO,KAAK,gBAAgB,MAAM,GAAG,KAAK,MAAM;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAqB;AACnB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,oBAAoB;AAClB,WAAO,KAAK,gBAAgB;AAAA,MAC1B,KAAK,gBAAgB,SAAS,KAAK;AAAA,IACrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY;AACV,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,sBAAsB,kBAAkB;AACtC,QAAI,KAAK,+BAA+B,KAAK,YAAY,GAAG;AAC1D,WAAK,2CAA2C;AAChD,WAAK,6BAA6B,KAAK,YAAY;AAAA,IACrD;AAGA,QACE,mBAAmB,KAClB,KAAK,6CAA6C,KACjD,oBAAoB,KAAK,0CAC3B;AACA,aAAO;AAAA,IACT;AAEA,UAAM,qBACJ,KAAK,8BAA8B,gBAAgB;AACrD,UAAM,4BAA4B,mBAAmB,mBAAmB;AACxE,QAAI,0BAA0B,SAAS,KAAK,gBAAgB,QAAQ;AAClE,aAAO;AAAA,IACT;AAOA,SAAK,2CAA2C;AAChD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,8BAA8B,kBAAkB;AAC9C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY;AACV,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,mBAAmB,QAAQ,iBAAiB;AAC1C,SAAK,SAAS,mBAAmB,MAAM;AACvC,SAAK,SAAS;AACd,SAAK,kBAAkB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAeC,cAAa,QAAQ;AAClC,aAAS;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,UAAU,QAAQA,cAAa,SAAS;AACtC,QAAI;AACJ,QAAI,QAAQ;AACV,eAAS,mBAAmB,MAAM;AAAA,IACpC,OAAO;AACL,eAAS,IAAI,GAAG,IAAI,SAAS,EAAE,GAAG;AAChC,YAAIA,aAAY,WAAW,GAAG;AAC5B,eAAK,SAAS;AACd,eAAK,SAAS;AACd;AAAA,QACF;AACA,QAAAA;AAAA,QAA6CA,aAAY,CAAC;AAAA,MAC5D;AACA,eAASA,aAAY;AACrB,eAAS,mBAAmB,MAAM;AAAA,IACpC;AACA,SAAK,SAAS;AACd,SAAK,SAAS;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,eAAe,aAAa;AAC1B,QAAI,KAAK,iBAAiB;AACxB,kBAAY,KAAK,iBAAiB,KAAK,iBAAiB,KAAK,MAAM;AACnE,WAAK,QAAQ;AAAA,IACf;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,OAAO,QAAQ;AACpB,UAAM,kBAAkB,KAAK,mBAAmB;AAChD,QAAI,iBAAiB;AACnB,YAAM,SAAS,KAAK,UAAU;AAC9B,MAAAC;AAAA,QACE;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,WAAK,QAAQ;AAAA,IACf;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAM,IAAI,IAAI,QAAQ;AACpB,QAAI,OAAO,QAAW;AACpB,WAAK;AAAA,IACP;AACA,QAAI,CAAC,QAAQ;AACX,eAAS,UAAU,KAAK,UAAU,CAAC;AAAA,IACrC;AACA,UAAM,kBAAkB,KAAK,mBAAmB;AAChD,QAAI,iBAAiB;AACnB,YAAM,SAAS,KAAK,UAAU;AAC9B,MAAAC;AAAA,QACE;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,WAAK,QAAQ;AAAA,IACf;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,QAAQ,QAAQ;AACxB,UAAM,kBAAkB,KAAK,mBAAmB;AAChD,QAAI,iBAAiB;AACnB,YAAM,SAAS,KAAK,UAAU;AAC9B,MAAAC;AAAA,QACE;AAAA,QACA;AAAA,QACA,gBAAgB;AAAA,QAChB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AACA,WAAK,QAAQ;AAAA,IACf;AAAA,EACF;AACF;AAMO,SAAS,mBAAmB,QAAQ;AACzC,MAAI;AACJ,MAAI,UAAU,GAAG;AACf,aAAS;AAAA,EACX,WAAW,UAAU,GAAG;AACtB,aAAS;AAAA,EACX,WAAW,UAAU,GAAG;AACtB,aAAS;AAAA,EACX;AACA;AAAA;AAAA,IAA8D;AAAA;AAChE;AAMO,SAAS,mBAAmB,QAAQ;AACzC,MAAI;AACJ,MAAI,UAAU,MAAM;AAClB,aAAS;AAAA,EACX,WAAW,UAAU,SAAS,UAAU,OAAO;AAC7C,aAAS;AAAA,EACX,WAAW,UAAU,QAAQ;AAC3B,aAAS;AAAA,EACX;AACA;AAAA;AAAA,IAA8B;AAAA;AAChC;AAQO,SAAS,gBAAgB,gBAAgBC,YAAW,MAAM;AAC/D,QAAM,kBAAkB,eAAe,mBAAmB;AAC1D,MAAI,CAAC,iBAAiB;AACpB,WAAO;AAAA,EACT;AACA,QAAM,SAAS,eAAe,UAAU;AACxC,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,gBAAgB;AAAA,IAChB;AAAA,IACAA;AAAA,IACA;AAAA,EACF;AACF;AAEA,IAAO,yBAAQ;;;AC1Uf,SAAS,cACP,iBACA,SACA,SACA,QACA,GACA,GACA,cACA;AACA,QAAM,KAAK,gBAAgB,OAAO;AAClC,QAAM,KAAK,gBAAgB,UAAU,CAAC;AACtC,QAAM,KAAK,gBAAgB,OAAO,IAAI;AACtC,QAAM,KAAK,gBAAgB,UAAU,CAAC,IAAI;AAC1C,MAAIC;AACJ,MAAI,OAAO,KAAK,OAAO,GAAG;AACxB,IAAAA,UAAS;AAAA,EACX,OAAO;AACL,UAAM,MAAM,IAAI,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK,KAAK,KAAK;AAC5D,QAAI,IAAI,GAAG;AACT,MAAAA,UAAS;AAAA,IACX,WAAW,IAAI,GAAG;AAChB,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,qBAAa,CAAC,IAAI;AAAA,UAChB,gBAAgB,UAAU,CAAC;AAAA,UAC3B,gBAAgB,UAAU,CAAC;AAAA,UAC3B;AAAA,QACF;AAAA,MACF;AACA,mBAAa,SAAS;AACtB;AAAA,IACF,OAAO;AACL,MAAAA,UAAS;AAAA,IACX;AAAA,EACF;AACA,WAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,iBAAa,CAAC,IAAI,gBAAgBA,UAAS,CAAC;AAAA,EAC9C;AACA,eAAa,SAAS;AACxB;AAYO,SAAS,gBAAgB,iBAAiBA,SAAQ,KAAK,QAAQ,KAAK;AACzE,MAAI,KAAK,gBAAgBA,OAAM;AAC/B,MAAI,KAAK,gBAAgBA,UAAS,CAAC;AACnC,OAAKA,WAAU,QAAQA,UAAS,KAAKA,WAAU,QAAQ;AACrD,UAAM,KAAK,gBAAgBA,OAAM;AACjC,UAAM,KAAK,gBAAgBA,UAAS,CAAC;AACrC,UAAM,eAAe,gBAAU,IAAI,IAAI,IAAI,EAAE;AAC7C,QAAI,eAAe,KAAK;AACtB,YAAM;AAAA,IACR;AACA,SAAK;AACL,SAAK;AAAA,EACP;AACA,SAAO;AACT;AAUO,SAAS,qBACd,iBACAA,SACA,MACA,QACA,KACA;AACA,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAClB,UAAM,gBAAgB,iBAAiBA,SAAQ,KAAK,QAAQ,GAAG;AAC/D,IAAAA,UAAS;AAAA,EACX;AACA,SAAO;AACT;AAUO,SAAS,0BACd,iBACAA,SACA,OACA,QACA,KACA;AACA,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,CAAC;AACpB,UAAM,qBAAqB,iBAAiBA,SAAQ,MAAM,QAAQ,GAAG;AACrE,IAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACA,SAAO;AACT;AAgBO,SAAS,mBACd,iBACAA,SACA,KACA,QACA,UACA,QACA,GACA,GACA,cACA,oBACA,UACA;AACA,MAAIA,WAAU,KAAK;AACjB,WAAO;AAAA,EACT;AACA,MAAI,GAAGC;AACP,MAAI,aAAa,GAAG;AAElB,IAAAA,mBAAkB;AAAA,MAChB;AAAA,MACA;AAAA,MACA,gBAAgBD,OAAM;AAAA,MACtB,gBAAgBA,UAAS,CAAC;AAAA,IAC5B;AACA,QAAIC,mBAAkB,oBAAoB;AACxC,WAAK,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC3B,qBAAa,CAAC,IAAI,gBAAgBD,UAAS,CAAC;AAAA,MAC9C;AACA,mBAAa,SAAS;AACtB,aAAOC;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACA,aAAW,WAAW,WAAW,CAAC,KAAK,GAAG;AAC1C,MAAI,QAAQD,UAAS;AACrB,SAAO,QAAQ,KAAK;AAClB;AAAA,MACE;AAAA,MACA,QAAQ;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,IAAAC,mBAAkB,gBAAU,GAAG,GAAG,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AAC1D,QAAIA,mBAAkB,oBAAoB;AACxC,2BAAqBA;AACrB,WAAK,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC3B,qBAAa,CAAC,IAAI,SAAS,CAAC;AAAA,MAC9B;AACA,mBAAa,SAAS;AACtB,eAAS;AAAA,IACX,OAAO;AAWL,eACE,SACA,KAAK;AAAA,SACD,KAAK,KAAKA,gBAAe,IAAI,KAAK,KAAK,kBAAkB,KACzD,WACA;AAAA,QACF;AAAA,MACF;AAAA,IACJ;AAAA,EACF;AACA,MAAI,QAAQ;AAEV;AAAA,MACE;AAAA,MACA,MAAM;AAAA,MACND;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,IAAAC,mBAAkB,gBAAU,GAAG,GAAG,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;AAC1D,QAAIA,mBAAkB,oBAAoB;AACxC,2BAAqBA;AACrB,WAAK,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC3B,qBAAa,CAAC,IAAI,SAAS,CAAC;AAAA,MAC9B;AACA,mBAAa,SAAS;AAAA,IACxB;AAAA,EACF;AACA,SAAO;AACT;AAgBO,SAAS,wBACd,iBACAD,SACA,MACA,QACA,UACA,QACA,GACA,GACA,cACA,oBACA,UACA;AACA,aAAW,WAAW,WAAW,CAAC,KAAK,GAAG;AAC1C,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAClB,yBAAqB;AAAA,MACnB;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,IAAAA,UAAS;AAAA,EACX;AACA,SAAO;AACT;AAgBO,SAAS,6BACd,iBACAA,SACA,OACA,QACA,UACA,QACA,GACA,GACA,cACA,oBACA,UACA;AACA,aAAW,WAAW,WAAW,CAAC,KAAK,GAAG;AAC1C,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,CAAC;AACpB,yBAAqB;AAAA,MACnB;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,IAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACA,SAAO;AACT;;;ACpUO,SAAS,kBAAkB,iBAAiBE,SAAQ,YAAY,QAAQ;AAC7E,WAAS,IAAI,GAAG,KAAK,WAAW,QAAQ,IAAI,IAAI,EAAE,GAAG;AACnD,oBAAgBA,SAAQ,IAAI,WAAW,CAAC;AAAA,EAC1C;AACA,SAAOA;AACT;AASO,SAAS,mBACd,iBACAA,SACAC,cACA,QACA;AACA,WAAS,IAAI,GAAG,KAAKA,aAAY,QAAQ,IAAI,IAAI,EAAE,GAAG;AACpD,UAAM,aAAaA,aAAY,CAAC;AAChC,aAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,sBAAgBD,SAAQ,IAAI,WAAW,CAAC;AAAA,IAC1C;AAAA,EACF;AACA,SAAOA;AACT;AAUO,SAAS,wBACd,iBACAA,SACA,cACA,QACA,MACA;AACA,SAAO,OAAO,OAAO,CAAC;AACtB,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,KAAK,aAAa,QAAQ,IAAI,IAAI,EAAE,GAAG;AACrD,UAAM,MAAM;AAAA,MACV;AAAA,MACAA;AAAA,MACA,aAAa,CAAC;AAAA,MACd;AAAA,IACF;AACA,SAAK,GAAG,IAAI;AACZ,IAAAA,UAAS;AAAA,EACX;AACA,OAAK,SAAS;AACd,SAAO;AACT;AAUO,SAAS,6BACd,iBACAA,SACA,eACA,QACA,OACA;AACA,UAAQ,QAAQ,QAAQ,CAAC;AACzB,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,KAAK,cAAc,QAAQ,IAAI,IAAI,EAAE,GAAG;AACtD,UAAM,OAAO;AAAA,MACX;AAAA,MACAA;AAAA,MACA,cAAc,CAAC;AAAA,MACf;AAAA,MACA,MAAM,CAAC;AAAA,IACT;AACA,QAAI,KAAK,WAAW,GAAG;AACrB,WAAK,CAAC,IAAIA;AAAA,IACZ;AACA,UAAM,GAAG,IAAI;AACb,IAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACA,QAAM,SAAS;AACf,SAAO;AACT;;;ACdO,SAAS,eACd,iBACAE,SACA,KACA,QACA,kBACA,2BACA,kBACA;AACA,QAAM,KAAK,MAAMA,WAAU;AAC3B,MAAI,IAAI,GAAG;AACT,WAAOA,UAAS,KAAKA,WAAU,QAAQ;AACrC,gCAA0B,kBAAkB,IAAI,gBAAgBA,OAAM;AACtE,gCAA0B,kBAAkB,IAC1C,gBAAgBA,UAAS,CAAC;AAAA,IAC9B;AACA,WAAO;AAAA,EACT;AAEA,QAAM,UAAU,IAAI,MAAM,CAAC;AAC3B,UAAQ,CAAC,IAAI;AACb,UAAQ,IAAI,CAAC,IAAI;AAEjB,QAAM,QAAQ,CAACA,SAAQ,MAAM,MAAM;AACnC,MAAI,QAAQ;AACZ,SAAO,MAAM,SAAS,GAAG;AACvB,UAAM,OAAO,MAAM,IAAI;AACvB,UAAM,QAAQ,MAAM,IAAI;AACxB,QAAI,qBAAqB;AACzB,UAAM,KAAK,gBAAgB,KAAK;AAChC,UAAM,KAAK,gBAAgB,QAAQ,CAAC;AACpC,UAAM,KAAK,gBAAgB,IAAI;AAC/B,UAAM,KAAK,gBAAgB,OAAO,CAAC;AACnC,aAAS,IAAI,QAAQ,QAAQ,IAAI,MAAM,KAAK,QAAQ;AAClD,YAAM,IAAI,gBAAgB,CAAC;AAC3B,YAAM,IAAI,gBAAgB,IAAI,CAAC;AAC/B,YAAMC,mBAAkB,uBAAuB,GAAG,GAAG,IAAI,IAAI,IAAI,EAAE;AACnE,UAAIA,mBAAkB,oBAAoB;AACxC,gBAAQ;AACR,6BAAqBA;AAAA,MACvB;AAAA,IACF;AACA,QAAI,qBAAqB,kBAAkB;AACzC,eAAS,QAAQD,WAAU,MAAM,IAAI;AACrC,UAAI,QAAQ,SAAS,OAAO;AAC1B,cAAM,KAAK,OAAO,KAAK;AAAA,MACzB;AACA,UAAI,QAAQ,SAAS,MAAM;AACzB,cAAM,KAAK,OAAO,IAAI;AAAA,MACxB;AAAA,IACF;AAAA,EACF;AACA,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B,QAAI,QAAQ,CAAC,GAAG;AACd,gCAA0B,kBAAkB,IAC1C,gBAAgBA,UAAS,IAAI,MAAM;AACrC,gCAA0B,kBAAkB,IAC1C,gBAAgBA,UAAS,IAAI,SAAS,CAAC;AAAA,IAC3C;AAAA,EACF;AACA,SAAO;AACT;AAcO,SAAS,oBACd,iBACAA,SACA,MACA,QACA,kBACA,2BACA,kBACA,gBACA;AACA,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAClB,uBAAmB;AAAA,MACjB;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,mBAAe,KAAK,gBAAgB;AACpC,IAAAA,UAAS;AAAA,EACX;AACA,SAAO;AACT;AAwGO,SAAS,KAAK,OAAO,WAAW;AACrC,SAAO,YAAY,KAAK,MAAM,QAAQ,SAAS;AACjD;AAqBO,SAAS,SACd,iBACAE,SACA,KACA,QACA,WACA,2BACA,kBACA;AAEA,MAAIA,WAAU,KAAK;AACjB,WAAO;AAAA,EACT;AAEA,MAAI,KAAK,KAAK,gBAAgBA,OAAM,GAAG,SAAS;AAChD,MAAI,KAAK,KAAK,gBAAgBA,UAAS,CAAC,GAAG,SAAS;AACpD,EAAAA,WAAU;AAEV,4BAA0B,kBAAkB,IAAI;AAChD,4BAA0B,kBAAkB,IAAI;AAGhD,MAAI,IAAI;AACR,KAAG;AACD,SAAK,KAAK,gBAAgBA,OAAM,GAAG,SAAS;AAC5C,SAAK,KAAK,gBAAgBA,UAAS,CAAC,GAAG,SAAS;AAChD,IAAAA,WAAU;AACV,QAAIA,WAAU,KAAK;AAKjB,gCAA0B,kBAAkB,IAAI;AAChD,gCAA0B,kBAAkB,IAAI;AAChD,aAAO;AAAA,IACT;AAAA,EACF,SAAS,MAAM,MAAM,MAAM;AAC3B,SAAOA,UAAS,KAAK;AAEnB,UAAM,KAAK,KAAK,gBAAgBA,OAAM,GAAG,SAAS;AAClD,UAAM,KAAK,KAAK,gBAAgBA,UAAS,CAAC,GAAG,SAAS;AACtD,IAAAA,WAAU;AAEV,QAAI,MAAM,MAAM,MAAM,IAAI;AACxB;AAAA,IACF;AAEA,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AAEjB,UAAM,MAAM,KAAK;AACjB,UAAM,MAAM,KAAK;AAIjB,QACE,MAAM,OAAO,MAAM,QACjB,MAAM,KAAK,MAAM,OAAQ,OAAO,OAAQ,MAAM,KAAK,MAAM,SACzD,MAAM,KAAK,MAAM,OAAQ,OAAO,OAAQ,MAAM,KAAK,MAAM,MAC3D;AAEA,WAAK;AACL,WAAK;AACL;AAAA,IACF;AAIA,8BAA0B,kBAAkB,IAAI;AAChD,8BAA0B,kBAAkB,IAAI;AAChD,SAAK;AACL,SAAK;AACL,SAAK;AACL,SAAK;AAAA,EACP;AAEA,4BAA0B,kBAAkB,IAAI;AAChD,4BAA0B,kBAAkB,IAAI;AAChD,SAAO;AACT;AAcO,SAAS,cACd,iBACAA,SACA,MACA,QACA,WACA,2BACA,kBACA,gBACA;AACA,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAClB,uBAAmB;AAAA,MACjB;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,mBAAe,KAAK,gBAAgB;AACpC,IAAAA,UAAS;AAAA,EACX;AACA,SAAO;AACT;AAcO,SAAS,mBACd,iBACAA,SACA,OACA,QACA,WACA,2BACA,kBACA,iBACA;AACA,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,CAAC;AAEpB,UAAM,iBAAiB,CAAC;AACxB,uBAAmB;AAAA,MACjB;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,oBAAgB,KAAK,cAAc;AACnC,IAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACA,SAAO;AACT;;;ACjdO,SAAS,mBACd,iBACAC,SACA,KACA,QACAC,cACA;AACA,EAAAA,eAAcA,iBAAgB,SAAYA,eAAc,CAAC;AACzD,MAAI,IAAI;AACR,WAAS,IAAID,SAAQ,IAAI,KAAK,KAAK,QAAQ;AACzC,IAAAC,aAAY,GAAG,IAAI,gBAAgB,MAAM,GAAG,IAAI,MAAM;AAAA,EACxD;AACA,EAAAA,aAAY,SAAS;AACrB,SAAOA;AACT;AAUO,SAAS,wBACd,iBACAD,SACA,MACA,QACA,cACA;AACA,iBAAe,iBAAiB,SAAY,eAAe,CAAC;AAC5D,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAClB,iBAAa,GAAG,IAAI;AAAA,MAClB;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa,CAAC;AAAA,IAChB;AACA,IAAAA,UAAS;AAAA,EACX;AACA,eAAa,SAAS;AACtB,SAAO;AACT;AAWO,SAAS,6BACd,iBACAA,SACA,OACA,QACA,eACA;AACA,kBAAgB,kBAAkB,SAAY,gBAAgB,CAAC;AAC/D,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,CAAC;AACpB,kBAAc,GAAG,IACf,KAAK,WAAW,KAAK,KAAK,CAAC,MAAMA,UAC7B,CAAC,IACD;AAAA,MACE;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAc,CAAC;AAAA,IACjB;AACN,IAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACA,gBAAc,SAAS;AACvB,SAAO;AACT;;;ACnFO,SAAS,WAAW,iBAAiBE,SAAQ,KAAK,QAAQ;AAC/D,MAAI,YAAY;AAChB,MAAI,KAAK,gBAAgB,MAAM,MAAM;AACrC,MAAI,KAAK,gBAAgB,MAAM,SAAS,CAAC;AACzC,SAAOA,UAAS,KAAKA,WAAU,QAAQ;AACrC,UAAM,KAAK,gBAAgBA,OAAM;AACjC,UAAM,KAAK,gBAAgBA,UAAS,CAAC;AACrC,iBAAa,KAAK,KAAK,KAAK;AAC5B,SAAK;AACL,SAAK;AAAA,EACP;AACA,SAAO,YAAY;AACrB;AASO,SAAS,YAAY,iBAAiBA,SAAQ,MAAM,QAAQ;AACjE,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAClB,YAAQ,WAAW,iBAAiBA,SAAQ,KAAK,MAAM;AACvD,IAAAA,UAAS;AAAA,EACX;AACA,SAAO;AACT;AASO,SAAS,aAAa,iBAAiBA,SAAQ,OAAO,QAAQ;AACnE,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,CAAC;AACpB,YAAQ,YAAY,iBAAiBA,SAAQ,MAAM,MAAM;AACzD,IAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACA,SAAO;AACT;;;ACvCA,IAAM,aAAN,MAAM,oBAAmB,uBAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMtC,YAAYC,cAAa,QAAQ;AAC/B,UAAM;AAMN,SAAK,YAAY;AAMjB,SAAK,oBAAoB;AAEzB,QAAI,WAAW,UAAa,CAAC,MAAM,QAAQA,aAAY,CAAC,CAAC,GAAG;AAC1D,WAAK;AAAA,QACH;AAAA;AAAA,QAC8BA;AAAA,MAChC;AAAA,IACF,OAAO;AACL,WAAK;AAAA;AAAA,QAEDA;AAAA,QAEF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ;AACN,WAAO,IAAI,YAAW,KAAK,gBAAgB,MAAM,GAAG,KAAK,MAAM;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe,GAAG,GAAG,cAAc,oBAAoB;AACrD,QAAI,qBAAqB,yBAAyB,KAAK,UAAU,GAAG,GAAG,CAAC,GAAG;AACzE,aAAO;AAAA,IACT;AACA,QAAI,KAAK,qBAAqB,KAAK,YAAY,GAAG;AAChD,WAAK,YAAY,KAAK;AAAA,QACpB;AAAA,UACE,KAAK;AAAA,UACL;AAAA,UACA,KAAK,gBAAgB;AAAA,UACrB,KAAK;AAAA,UACL;AAAA,QACF;AAAA,MACF;AACA,WAAK,oBAAoB,KAAK,YAAY;AAAA,IAC5C;AACA,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA,KAAK,gBAAgB;AAAA,MACrB,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA,KAAK,gBAAgB;AAAA,MACrB,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiB;AACf,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA,KAAK,gBAAgB;AAAA,MACrB,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,8BAA8B,kBAAkB;AAE9C,UAAM,4BAA4B,CAAC;AACnC,8BAA0B,SAAS;AAAA,MACjC,KAAK;AAAA,MACL;AAAA,MACA,KAAK,gBAAgB;AAAA,MACrB,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,IAAI,YAAW,2BAA2B,IAAI;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiB,QAAQ;AACvB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,eAAeA,cAAa,QAAQ;AAClC,SAAK,UAAU,QAAQA,cAAa,CAAC;AACrC,QAAI,CAAC,KAAK,iBAAiB;AACzB,WAAK,kBAAkB,CAAC;AAAA,IAC1B;AACA,SAAK,gBAAgB,SAAS;AAAA,MAC5B,KAAK;AAAA,MACL;AAAA,MACAA;AAAA,MACA,KAAK;AAAA,IACP;AACA,SAAK,QAAQ;AAAA,EACf;AACF;AAEA,IAAO,qBAAQ;;;AC9Kf,IAAM,QAAN,MAAM,eAAc,uBAAe;AAAA;AAAA;AAAA;AAAA;AAAA,EAKjC,YAAYC,cAAa,QAAQ;AAC/B,UAAM;AACN,SAAK,eAAeA,cAAa,MAAM;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ;AACN,UAAM,QAAQ,IAAI,OAAM,KAAK,gBAAgB,MAAM,GAAG,KAAK,MAAM;AACjE,UAAM,gBAAgB,IAAI;AAC1B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe,GAAG,GAAG,cAAc,oBAAoB;AACrD,UAAM,kBAAkB,KAAK;AAC7B,UAAMC,mBAAkB;AAAA,MACtB;AAAA,MACA;AAAA,MACA,gBAAgB,CAAC;AAAA,MACjB,gBAAgB,CAAC;AAAA,IACnB;AACA,QAAIA,mBAAkB,oBAAoB;AACxC,YAAM,SAAS,KAAK;AACpB,eAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,qBAAa,CAAC,IAAI,gBAAgB,CAAC;AAAA,MACrC;AACA,mBAAa,SAAS;AACtB,aAAOA;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiB;AACf,WAAO,KAAK,gBAAgB,MAAM;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,QAAQ;AACpB,WAAO,6BAA6B,KAAK,iBAAiB,MAAM;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiB,QAAQ;AACvB,WAAO,WAAW,QAAQ,KAAK,gBAAgB,CAAC,GAAG,KAAK,gBAAgB,CAAC,CAAC;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,eAAeD,cAAa,QAAQ;AAClC,SAAK,UAAU,QAAQA,cAAa,CAAC;AACrC,QAAI,CAAC,KAAK,iBAAiB;AACzB,WAAK,kBAAkB,CAAC;AAAA,IAC1B;AACA,SAAK,gBAAgB,SAAS;AAAA,MAC5B,KAAK;AAAA,MACL;AAAA,MACAA;AAAA,MACA,KAAK;AAAA,IACP;AACA,SAAK,QAAQ;AAAA,EACf;AACF;AAEA,IAAO,gBAAQ;;;ACzGR,SAAS,yBACd,iBACAE,SACA,KACA,QACA,QACA;AACA,QAAM,UAAU;AAAA,IACd;AAAA;AAAA;AAAA;AAAA;AAAA,IAKA,SAAU,YAAY;AACpB,aAAO,CAAC;AAAA,QACN;AAAA,QACAA;AAAA,QACA;AAAA,QACA;AAAA,QACA,WAAW,CAAC;AAAA,QACZ,WAAW,CAAC;AAAA,MACd;AAAA,IACF;AAAA,EACF;AACA,SAAO,CAAC;AACV;AAWO,SAAS,qBACd,iBACAA,SACA,KACA,QACA,GACA,GACA;AAQA,MAAI,KAAK;AACT,MAAI,KAAK,gBAAgB,MAAM,MAAM;AACrC,MAAI,KAAK,gBAAgB,MAAM,SAAS,CAAC;AACzC,SAAOA,UAAS,KAAKA,WAAU,QAAQ;AACrC,UAAM,KAAK,gBAAgBA,OAAM;AACjC,UAAM,KAAK,gBAAgBA,UAAS,CAAC;AACrC,QAAI,MAAM,GAAG;AACX,UAAI,KAAK,MAAM,KAAK,OAAO,IAAI,OAAO,IAAI,OAAO,KAAK,MAAM,GAAG;AAC7D;AAAA,MACF;AAAA,IACF,WAAW,MAAM,MAAM,KAAK,OAAO,IAAI,OAAO,IAAI,OAAO,KAAK,MAAM,GAAG;AACrE;AAAA,IACF;AACA,SAAK;AACL,SAAK;AAAA,EACP;AACA,SAAO,OAAO;AAChB;AAWO,SAAS,sBACd,iBACAA,SACA,MACA,QACA,GACA,GACA;AACA,MAAI,KAAK,WAAW,GAAG;AACrB,WAAO;AAAA,EACT;AACA,MAAI,CAAC,qBAAqB,iBAAiBA,SAAQ,KAAK,CAAC,GAAG,QAAQ,GAAG,CAAC,GAAG;AACzE,WAAO;AAAA,EACT;AACA,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,QACE,qBAAqB,iBAAiB,KAAK,IAAI,CAAC,GAAG,KAAK,CAAC,GAAG,QAAQ,GAAG,CAAC,GACxE;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AAWO,SAAS,uBACd,iBACAA,SACA,OACA,QACA,GACA,GACA;AACA,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO;AAAA,EACT;AACA,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,CAAC;AACpB,QAAI,sBAAsB,iBAAiBA,SAAQ,MAAM,QAAQ,GAAG,CAAC,GAAG;AACtE,aAAO;AAAA,IACT;AACA,IAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACA,SAAO;AACT;;;AC7HO,SAAS,wBACd,iBACAC,SACA,MACA,QACA,aACA,mBACA,MACA;AACA,MAAI,GAAG,IAAI,GAAG,IAAI,IAAI,IAAI;AAC1B,QAAM,IAAI,YAAY,oBAAoB,CAAC;AAE3C,QAAM,gBAAgB,CAAC;AAEvB,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAClB,SAAK,gBAAgB,MAAM,MAAM;AACjC,SAAK,gBAAgB,MAAM,SAAS,CAAC;AACrC,SAAK,IAAIA,SAAQ,IAAI,KAAK,KAAK,QAAQ;AACrC,WAAK,gBAAgB,CAAC;AACtB,WAAK,gBAAgB,IAAI,CAAC;AAC1B,UAAK,KAAK,MAAM,MAAM,KAAO,MAAM,KAAK,KAAK,IAAK;AAChD,aAAM,IAAI,OAAO,KAAK,OAAQ,KAAK,MAAM;AACzC,sBAAc,KAAK,CAAC;AAAA,MACtB;AACA,WAAK;AACL,WAAK;AAAA,IACP;AAAA,EACF;AAGA,MAAI,SAAS;AACb,MAAI,mBAAmB;AACvB,gBAAc,KAAK,SAAS;AAC5B,OAAK,cAAc,CAAC;AACpB,OAAK,IAAI,GAAG,KAAK,cAAc,QAAQ,IAAI,IAAI,EAAE,GAAG;AAClD,SAAK,cAAc,CAAC;AACpB,UAAM,gBAAgB,KAAK,IAAI,KAAK,EAAE;AACtC,QAAI,gBAAgB,kBAAkB;AACpC,WAAK,KAAK,MAAM;AAChB,UAAI,sBAAsB,iBAAiBA,SAAQ,MAAM,QAAQ,GAAG,CAAC,GAAG;AACtE,iBAAS;AACT,2BAAmB;AAAA,MACrB;AAAA,IACF;AACA,SAAK;AAAA,EACP;AACA,MAAI,MAAM,MAAM,GAAG;AAGjB,aAAS,YAAY,iBAAiB;AAAA,EACxC;AACA,MAAI,MAAM;AACR,SAAK,KAAK,QAAQ,GAAG,gBAAgB;AACrC,WAAO;AAAA,EACT;AACA,SAAO,CAAC,QAAQ,GAAG,gBAAgB;AACrC;AAWO,SAAS,8BACd,iBACAA,SACA,OACA,QACA,aACA;AAEA,MAAI,iBAAiB,CAAC;AACtB,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,CAAC;AACpB,qBAAiB;AAAA,MACf;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,IAAI;AAAA,MACJ;AAAA,IACF;AACA,IAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACA,SAAO;AACT;;;AC7FO,SAAS,QAAQ,iBAAiBC,SAAQ,KAAK,QAAQ,UAAU;AACtE,MAAI;AACJ,EAAAA,WAAU;AACV,SAAOA,UAAS,KAAKA,WAAU,QAAQ;AACrC,UAAM;AAAA,MACJ,gBAAgB,MAAMA,UAAS,QAAQA,OAAM;AAAA,MAC7C,gBAAgB,MAAMA,SAAQA,UAAS,MAAM;AAAA,IAC/C;AACA,QAAI,KAAK;AACP,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;;;ACTO,SAAS,qBACd,iBACAC,SACA,KACA,QACA,QACA;AACA,QAAM,oBAAoB;AAAA,IACxB,YAAY;AAAA,IACZ;AAAA,IACAA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,MAAI,CAAC,WAAW,QAAQ,iBAAiB,GAAG;AAC1C,WAAO;AAAA,EACT;AACA,MAAI,eAAe,QAAQ,iBAAiB,GAAG;AAC7C,WAAO;AAAA,EACT;AACA,MAAI,kBAAkB,CAAC,KAAK,OAAO,CAAC,KAAK,kBAAkB,CAAC,KAAK,OAAO,CAAC,GAAG;AAC1E,WAAO;AAAA,EACT;AACA,MAAI,kBAAkB,CAAC,KAAK,OAAO,CAAC,KAAK,kBAAkB,CAAC,KAAK,OAAO,CAAC,GAAG;AAC1E,WAAO;AAAA,EACT;AACA,SAAO;AAAA,IACL;AAAA,IACAA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAOA,SAAU,QAAQ,QAAQ;AACxB,aAAO,kBAAkB,QAAQ,QAAQ,MAAM;AAAA,IACjD;AAAA,EACF;AACF;AAUO,SAAS,0BACd,iBACAA,SACA,MACA,QACA,QACA;AACA,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,QACE,qBAAqB,iBAAiBA,SAAQ,KAAK,CAAC,GAAG,QAAQ,MAAM,GACrE;AACA,aAAO;AAAA,IACT;AACA,IAAAA,UAAS,KAAK,CAAC;AAAA,EACjB;AACA,SAAO;AACT;AAUO,SAAS,qBACd,iBACAA,SACA,KACA,QACA,QACA;AACA,MAAI,qBAAqB,iBAAiBA,SAAQ,KAAK,QAAQ,MAAM,GAAG;AACtE,WAAO;AAAA,EACT;AACA,MACE;AAAA,IACE;AAAA,IACAA;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,IACR,OAAO,CAAC;AAAA,EACV,GACA;AACA,WAAO;AAAA,EACT;AACA,MACE;AAAA,IACE;AAAA,IACAA;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,IACR,OAAO,CAAC;AAAA,EACV,GACA;AACA,WAAO;AAAA,EACT;AACA,MACE;AAAA,IACE;AAAA,IACAA;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,IACR,OAAO,CAAC;AAAA,EACV,GACA;AACA,WAAO;AAAA,EACT;AACA,MACE;AAAA,IACE;AAAA,IACAA;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,CAAC;AAAA,IACR,OAAO,CAAC;AAAA,EACV,GACA;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AAUO,SAAS,0BACd,iBACAA,SACA,MACA,QACA,QACA;AACA,MAAI,CAAC,qBAAqB,iBAAiBA,SAAQ,KAAK,CAAC,GAAG,QAAQ,MAAM,GAAG;AAC3E,WAAO;AAAA,EACT;AACA,MAAI,KAAK,WAAW,GAAG;AACrB,WAAO;AAAA,EACT;AACA,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,QACE;AAAA,MACE;AAAA,MACA,KAAK,IAAI,CAAC;AAAA,MACV,KAAK,CAAC;AAAA,MACN;AAAA,MACA;AAAA,IACF,GACA;AACA,UACE,CAAC;AAAA,QACC;AAAA,QACA,KAAK,IAAI,CAAC;AAAA,QACV,KAAK,CAAC;AAAA,QACN;AAAA,QACA;AAAA,MACF,GACA;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAUO,SAAS,+BACd,iBACAA,SACA,OACA,QACA,QACA;AACA,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,CAAC;AACpB,QACE,0BAA0B,iBAAiBA,SAAQ,MAAM,QAAQ,MAAM,GACvE;AACA,aAAO;AAAA,IACT;AACA,IAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,EAC/B;AACA,SAAO;AACT;;;AC7NO,SAAS,YAAY,iBAAiBC,SAAQ,KAAK,QAAQ;AAChE,SAAOA,UAAS,MAAM,QAAQ;AAC5B,aAAS,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC/B,YAAM,MAAM,gBAAgBA,UAAS,CAAC;AACtC,sBAAgBA,UAAS,CAAC,IAAI,gBAAgB,MAAM,SAAS,CAAC;AAC9D,sBAAgB,MAAM,SAAS,CAAC,IAAI;AAAA,IACtC;AACA,IAAAA,WAAU;AACV,WAAO;AAAA,EACT;AACF;;;ACLO,SAAS,sBAAsB,iBAAiBC,SAAQ,KAAK,QAAQ;AAG1E,MAAI,OAAO;AACX,MAAI,KAAK,gBAAgB,MAAM,MAAM;AACrC,MAAI,KAAK,gBAAgB,MAAM,SAAS,CAAC;AACzC,SAAOA,UAAS,KAAKA,WAAU,QAAQ;AACrC,UAAM,KAAK,gBAAgBA,OAAM;AACjC,UAAM,KAAK,gBAAgBA,UAAS,CAAC;AACrC,aAAS,KAAK,OAAO,KAAK;AAC1B,SAAK;AACL,SAAK;AAAA,EACP;AACA,SAAO,SAAS,IAAI,SAAY,OAAO;AACzC;AAeO,SAAS,uBACd,iBACAA,SACA,MACA,QACA,OACA;AACA,UAAQ,UAAU,SAAY,QAAQ;AACtC,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAClB,UAAM,cAAc;AAAA,MAClB;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,QAAI,MAAM,GAAG;AACX,UAAK,SAAS,eAAiB,CAAC,SAAS,CAAC,aAAc;AACtD,eAAO;AAAA,MACT;AAAA,IACF,OAAO;AACL,UAAK,SAAS,CAAC,eAAiB,CAAC,SAAS,aAAc;AACtD,eAAO;AAAA,MACT;AAAA,IACF;AACA,IAAAA,UAAS;AAAA,EACX;AACA,SAAO;AACT;AAeO,SAAS,wBACd,iBACAA,SACA,OACA,QACA,OACA;AACA,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,UAAM,OAAO,MAAM,CAAC;AACpB,QAAI,CAAC,uBAAuB,iBAAiBA,SAAQ,MAAM,QAAQ,KAAK,GAAG;AACzE,aAAO;AAAA,IACT;AACA,QAAI,KAAK,QAAQ;AACf,MAAAA,UAAS,KAAK,KAAK,SAAS,CAAC;AAAA,IAC/B;AAAA,EACF;AACA,SAAO;AACT;AAeO,SAAS,kBACd,iBACAA,SACA,MACA,QACA,OACA;AACA,UAAQ,UAAU,SAAY,QAAQ;AACtC,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAClB,UAAM,cAAc;AAAA,MAClB;AAAA,MACAA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,UAAM,UACJ,MAAM,IACD,SAAS,eAAiB,CAAC,SAAS,CAAC,cACrC,SAAS,CAAC,eAAiB,CAAC,SAAS;AAC5C,QAAI,SAAS;AACX,kBAAmB,iBAAiBA,SAAQ,KAAK,MAAM;AAAA,IACzD;AACA,IAAAA,UAAS;AAAA,EACX;AACA,SAAOA;AACT;AAeO,SAAS,uBACd,iBACAA,SACA,OACA,QACA,OACA;AACA,WAAS,IAAI,GAAG,KAAK,MAAM,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC9C,IAAAA,UAAS;AAAA,MACP;AAAA,MACAA;AAAA,MACA,MAAM,CAAC;AAAA,MACP;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACA,SAAOA;AACT;AASO,SAAS,YAAY,iBAAiB,MAAM;AACjD,QAAM,QAAQ,CAAC;AACf,MAAIA,UAAS;AACb,MAAI,eAAe;AACnB,MAAI;AACJ,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,UAAM,MAAM,KAAK,CAAC;AAElB,UAAM,cAAc,sBAAsB,iBAAiBA,SAAQ,KAAK,CAAC;AACzE,QAAI,qBAAqB,QAAW;AAClC,yBAAmB;AAAA,IACrB;AACA,QAAI,gBAAgB,kBAAkB;AACpC,YAAM,KAAK,KAAK,MAAM,cAAc,IAAI,CAAC,CAAC;AAAA,IAC5C,OAAO;AACL,UAAI,MAAM,WAAW,GAAG;AACtB;AAAA,MACF;AACA,YAAM,MAAM,SAAS,CAAC,EAAE,KAAK,KAAK,YAAY,CAAC;AAAA,IACjD;AACA,mBAAe,IAAI;AACnB,IAAAA,UAAS;AAAA,EACX;AACA,SAAO;AACT;;;ACxLA,IAAM,UAAN,MAAM,iBAAgB,uBAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYnC,YAAYC,cAAa,QAAQ,MAAM;AACrC,UAAM;AAMN,SAAK,QAAQ,CAAC;AAMd,SAAK,6BAA6B;AAMlC,SAAK,qBAAqB;AAM1B,SAAK,YAAY;AAMjB,SAAK,oBAAoB;AAMzB,SAAK,oBAAoB;AAMzB,SAAK,2BAA2B;AAEhC,QAAI,WAAW,UAAa,MAAM;AAChC,WAAK;AAAA,QACH;AAAA;AAAA,QAC8BA;AAAA,MAChC;AACA,WAAK,QAAQ;AAAA,IACf,OAAO;AACL,WAAK;AAAA;AAAA,QAEDA;AAAA,QAEF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiBC,aAAY;AAC3B,QAAI,CAAC,KAAK,iBAAiB;AACzB,WAAK,kBAAkBA,YAAW,mBAAmB,EAAE,MAAM;AAAA,IAC/D,OAAO;AACL,aAAO,KAAK,iBAAiBA,YAAW,mBAAmB,CAAC;AAAA,IAC9D;AACA,SAAK,MAAM,KAAK,KAAK,gBAAgB,MAAM;AAC3C,SAAK,QAAQ;AAAA,EACf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ;AACN,UAAM,UAAU,IAAI;AAAA,MAClB,KAAK,gBAAgB,MAAM;AAAA,MAC3B,KAAK;AAAA,MACL,KAAK,MAAM,MAAM;AAAA,IACnB;AACA,YAAQ,gBAAgB,IAAI;AAC5B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe,GAAG,GAAG,cAAc,oBAAoB;AACrD,QAAI,qBAAqB,yBAAyB,KAAK,UAAU,GAAG,GAAG,CAAC,GAAG;AACzE,aAAO;AAAA,IACT;AACA,QAAI,KAAK,qBAAqB,KAAK,YAAY,GAAG;AAChD,WAAK,YAAY,KAAK;AAAA,QACpB;AAAA,UACE,KAAK;AAAA,UACL;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AAAA,UACL;AAAA,QACF;AAAA,MACF;AACA,WAAK,oBAAoB,KAAK,YAAY;AAAA,IAC5C;AACA,WAAO;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,GAAG,GAAG;AACf,WAAO;AAAA,MACL,KAAK,2BAA2B;AAAA,MAChC;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,WAAO;AAAA,MACL,KAAK,2BAA2B;AAAA,MAChC;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAeA,eAAe,OAAO;AACpB,QAAI;AACJ,QAAI,UAAU,QAAW;AACvB,wBAAkB,KAAK,2BAA2B,EAAE,MAAM;AAC1D,wBAAkB,iBAAiB,GAAG,KAAK,OAAO,KAAK,QAAQ,KAAK;AAAA,IACtE,OAAO;AACL,wBAAkB,KAAK;AAAA,IACzB;AAEA,WAAO,wBAAwB,iBAAiB,GAAG,KAAK,OAAO,KAAK,MAAM;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;AACR,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,uBAAuB;AACrB,QAAI,KAAK,8BAA8B,KAAK,YAAY,GAAG;AACzD,YAAM,aAAa,UAAU,KAAK,UAAU,CAAC;AAC7C,WAAK,qBAAqB;AAAA,QACxB,KAAK,2BAA2B;AAAA,QAChC;AAAA,QACA,KAAK;AAAA,QACL,KAAK;AAAA,QACL;AAAA,QACA;AAAA,MACF;AACA,WAAK,6BAA6B,KAAK,YAAY;AAAA,IACrD;AACA;AAAA;AAAA,MACE,KAAK;AAAA;AAAA,EAET;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,mBAAmB;AACjB,WAAO,IAAI,cAAM,KAAK,qBAAqB,GAAG,KAAK;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,qBAAqB;AACnB,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,cAAc,OAAO;AACnB,QAAI,QAAQ,KAAK,KAAK,MAAM,UAAU,OAAO;AAC3C,aAAO;AAAA,IACT;AACA,WAAO,IAAI;AAAA,MACT,KAAK,gBAAgB;AAAA,QACnB,UAAU,IAAI,IAAI,KAAK,MAAM,QAAQ,CAAC;AAAA,QACtC,KAAK,MAAM,KAAK;AAAA,MAClB;AAAA,MACA,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiB;AACf,UAAM,SAAS,KAAK;AACpB,UAAM,kBAAkB,KAAK;AAC7B,UAAM,OAAO,KAAK;AAClB,UAAMC,eAAc,CAAC;AACrB,QAAIC,UAAS;AACb,aAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,IAAI,IAAI,EAAE,GAAG;AAC7C,YAAM,MAAM,KAAK,CAAC;AAClB,YAAMF,cAAa,IAAI;AAAA,QACrB,gBAAgB,MAAME,SAAQ,GAAG;AAAA,QACjC;AAAA,MACF;AACA,MAAAD,aAAY,KAAKD,WAAU;AAC3B,MAAAE,UAAS;AAAA,IACX;AACA,WAAOD;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,6BAA6B;AAC3B,QAAI,KAAK,qBAAqB,KAAK,YAAY,GAAG;AAChD,YAAM,kBAAkB,KAAK;AAC7B,UAAI,uBAAuB,iBAAiB,GAAG,KAAK,OAAO,KAAK,MAAM,GAAG;AACvE,aAAK,2BAA2B;AAAA,MAClC,OAAO;AACL,aAAK,2BAA2B,gBAAgB,MAAM;AACtD,aAAK,yBAAyB,SAAS;AAAA,UACrC,KAAK;AAAA,UACL;AAAA,UACA,KAAK;AAAA,UACL,KAAK;AAAA,QACP;AAAA,MACF;AACA,WAAK,oBAAoB,KAAK,YAAY;AAAA,IAC5C;AACA;AAAA;AAAA,MAAqC,KAAK;AAAA;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,8BAA8B,kBAAkB;AAE9C,UAAM,4BAA4B,CAAC;AAEnC,UAAM,iBAAiB,CAAC;AACxB,8BAA0B,SAAS;AAAA,MACjC,KAAK;AAAA,MACL;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK,KAAK,gBAAgB;AAAA,MAC1B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AACA,WAAO,IAAI,SAAQ,2BAA2B,MAAM,cAAc;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU;AACR,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,iBAAiB,QAAQ;AACvB,WAAO;AAAA,MACL,KAAK,2BAA2B;AAAA,MAChC;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,MACL;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,eAAeF,cAAa,QAAQ;AAClC,SAAK,UAAU,QAAQA,cAAa,CAAC;AACrC,QAAI,CAAC,KAAK,iBAAiB;AACzB,WAAK,kBAAkB,CAAC;AAAA,IAC1B;AACA,UAAM,OAAO;AAAA,MACX,KAAK;AAAA,MACL;AAAA,MACAA;AAAA,MACA,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,SAAK,gBAAgB,SAAS,KAAK,WAAW,IAAI,IAAI,KAAK,KAAK,SAAS,CAAC;AAC1E,SAAK,QAAQ;AAAA,EACf;AACF;AAEA,IAAO,kBAAQ;AAcR,SAAS,SAAS,QAAQ,QAAQ,GAAG,cAAc;AACxD,MAAI,IAAI,IAAI;AAEZ,QAAM,kBAAkB,CAAC;AACzB,WAAS,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG;AAC1B;AAAA,MACE;AAAA,MACA,OAAa,QAAQ,QAAS,IAAI,KAAK,KAAK,IAAK,GAAG,YAAY;AAAA,IAClE;AAAA,EACF;AACA,kBAAgB,KAAK,gBAAgB,CAAC,GAAG,gBAAgB,CAAC,CAAC;AAC3D,SAAO,IAAI,QAAQ,iBAAiB,MAAM,CAAC,gBAAgB,MAAM,CAAC;AACpE;AAQO,SAAS,WAAW,QAAQ;AACjC,MAAI,QAAQ,MAAM,GAAG;AACnB,UAAM,IAAI,MAAM,yCAAyC;AAAA,EAC3D;AACA,QAAM,OAAO,OAAO,CAAC;AACrB,QAAM,OAAO,OAAO,CAAC;AACrB,QAAM,OAAO,OAAO,CAAC;AACrB,QAAM,OAAO,OAAO,CAAC;AACrB,QAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO,IAAI,QAAQ,iBAAiB,MAAM,CAAC,gBAAgB,MAAM,CAAC;AACpE;AAWO,SAAS,WAAW,QAAQ,OAAO,OAAO;AAC/C,UAAQ,QAAQ,QAAQ;AACxB,QAAM,SAAS,OAAO,UAAU;AAChC,QAAM,SAAS,OAAO,UAAU;AAChC,QAAM,SAAS,OAAO,UAAU;AAChC,QAAM,cAAc,UAAU,QAAQ;AACtC,QAAM,kBAAkB,IAAI,MAAM,WAAW;AAC7C,WAAS,IAAI,GAAG,IAAI,aAAa,KAAK,QAAQ;AAC5C,oBAAgB,CAAC,IAAI;AACrB,oBAAgB,IAAI,CAAC,IAAI;AACzB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,sBAAgB,IAAI,CAAC,IAAI,OAAO,CAAC;AAAA,IACnC;AAAA,EACF;AACA,QAAM,OAAO,CAAC,gBAAgB,MAAM;AACpC,QAAM,UAAU,IAAI,QAAQ,iBAAiB,QAAQ,IAAI;AACzD,cAAY,SAAS,QAAQ,OAAO,UAAU,GAAG,KAAK;AACtD,SAAO;AACT;AAUO,SAAS,YAAY,SAAS,QAAQ,QAAQ,OAAO;AAC1D,QAAM,kBAAkB,QAAQ,mBAAmB;AACnD,QAAM,SAAS,QAAQ,UAAU;AACjC,QAAM,QAAQ,gBAAgB,SAAS,SAAS;AAChD,QAAM,aAAa,QAAQ,QAAQ;AACnC,WAAS,IAAI,GAAG,KAAK,OAAO,EAAE,GAAG;AAC/B,UAAMG,UAAS,IAAI;AACnB,UAAMC,SAAQ,aAAc,OAAO,GAAG,KAAK,IAAI,IAAI,KAAK,KAAM;AAC9D,oBAAgBD,OAAM,IAAI,OAAO,CAAC,IAAI,SAAS,KAAK,IAAIC,MAAK;AAC7D,oBAAgBD,UAAS,CAAC,IAAI,OAAO,CAAC,IAAI,SAAS,KAAK,IAAIC,MAAK;AAAA,EACnE;AACA,UAAQ,QAAQ;AAClB;;;AC5fA,IAAM,YAAN,cAAwB,mBAAW;AAAA;AAAA;AAAA;AAAA,EAIjC,YAAY,WAAW;AACrB,UAAM;AAMN,SAAK,YAAY;AAMjB,SAAK,WAAW,SAAS,cAAc,KAAK;AAC5C,SAAK,SAAS,MAAM,WAAW;AAC/B,SAAK,SAAS,MAAM,gBAAgB;AACpC,SAAK,SAAS,YAAY,YAAY;AAMtC,SAAK,OAAO;AAMZ,SAAK,cAAc;AAMnB,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB;AAChB,SAAK,OAAO,IAAI;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU;AACR,UAAM,aAAa,KAAK;AACxB,UAAM,WAAW,KAAK;AACtB,UAAM,KAAK;AACX,UAAM,QAAQ,KAAK,SAAS;AAC5B,UAAM,OAAO,KAAK,IAAI,WAAW,CAAC,GAAG,SAAS,CAAC,CAAC,IAAI;AACpD,UAAM,MAAM,KAAK,IAAI,WAAW,CAAC,GAAG,SAAS,CAAC,CAAC,IAAI;AACnD,UAAM,QAAQ,KAAK,IAAI,SAAS,CAAC,IAAI,WAAW,CAAC,CAAC,IAAI;AACtD,UAAM,SAAS,KAAK,IAAI,SAAS,CAAC,IAAI,WAAW,CAAC,CAAC,IAAI;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,KAAK;AACV,QAAI,KAAK,MAAM;AACb,WAAK,KAAK,oBAAoB,EAAE,YAAY,KAAK,QAAQ;AACzD,YAAM,QAAQ,KAAK,SAAS;AAC5B,YAAM,OAAO;AACb,YAAM,MAAM;AACZ,YAAM,QAAQ;AACd,YAAM,SAAS;AAAA,IACjB;AACA,SAAK,OAAO;AACZ,QAAI,KAAK,MAAM;AACb,WAAK,KAAK,oBAAoB,EAAE,YAAY,KAAK,QAAQ;AAAA,IAC3D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,UAAU,YAAY,UAAU;AAC9B,SAAK,cAAc;AACnB,SAAK,YAAY;AACjB,SAAK,uBAAuB;AAC5B,SAAK,QAAQ;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB;AACvB,UAAM,aAAa,KAAK;AACxB,UAAM,WAAW,KAAK;AACtB,UAAM,SAAS;AAAA,MACb;AAAA,MACA,CAAC,WAAW,CAAC,GAAG,SAAS,CAAC,CAAC;AAAA,MAC3B;AAAA,MACA,CAAC,SAAS,CAAC,GAAG,WAAW,CAAC,CAAC;AAAA,IAC7B;AACA,UAAMC,eAAc,OAAO;AAAA,MACzB,KAAK,KAAK;AAAA,MACV,KAAK;AAAA,IACP;AAEA,IAAAA,aAAY,CAAC,IAAIA,aAAY,CAAC,EAAE,MAAM;AACtC,QAAI,CAAC,KAAK,WAAW;AACnB,WAAK,YAAY,IAAI,gBAAQ,CAACA,YAAW,CAAC;AAAA,IAC5C,OAAO;AACL,WAAK,UAAU,eAAe,CAACA,YAAW,CAAC;AAAA,IAC7C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACZ,WAAO,KAAK;AAAA,EACd;AACF;AAEA,IAAO,cAAQ;;;ACjGf,IAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMvB,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOV,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOT,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOR,WAAW;AACb;AAOO,IAAM,eAAN,cAA2B,cAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMtC,YAAY,MAAM,YAAY,iBAAiB;AAC7C,UAAM,IAAI;AAQV,SAAK,aAAa;AAOlB,SAAK,kBAAkB;AAAA,EACzB;AACF;AAwBA,IAAM,UAAN,cAAsB,gBAAmB;AAAA;AAAA;AAAA;AAAA,EAIvC,YAAY,SAAS;AACnB,UAAM;AAKN,SAAK;AAKL,SAAK;AAKL,SAAK;AAEL,cAAU,UAAU,UAAU,CAAC;AAM/B,SAAK,OAAO,IAAI,YAAU,QAAQ,aAAa,YAAY;AAM3D,SAAK,WAAW,QAAQ,YAAY,SAAY,QAAQ,UAAU;AAElE,QAAI,QAAQ,UAAU;AACpB,WAAK,WAAW,QAAQ;AAAA,IAC1B;AAMA,SAAK,cAAc;AAMnB,SAAK,aAAa,QAAQ,YAAY,QAAQ,YAAY;AAM1D,SAAK,mBAAmB,QAAQ,kBAC5B,QAAQ,kBACR,KAAK;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,uBAAuB,iBAAiB,YAAY,UAAU;AAC5D,UAAM,QAAQ,SAAS,CAAC,IAAI,WAAW,CAAC;AACxC,UAAM,SAAS,SAAS,CAAC,IAAI,WAAW,CAAC;AACzC,WAAO,QAAQ,QAAQ,SAAS,UAAU,KAAK;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc;AACZ,WAAO,KAAK,KAAK,YAAY;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,iBAAiB;AAC/B,SAAK,KAAK,UAAU,KAAK,aAAa,gBAAgB,KAAK;AAE3D,SAAK;AAAA,MACH,IAAI;AAAA,QACF,iBAAiB;AAAA,QACjB,gBAAgB;AAAA,QAChB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,iBAAiB;AAC7B,SAAK,KAAK,OAAO,IAAI;AAErB,UAAM,cAAc,KAAK;AAAA,MACvB;AAAA,MACA,KAAK;AAAA,MACL,gBAAgB;AAAA,IAClB;AACA,QAAI,aAAa;AACf,WAAK,SAAS,eAAe;AAAA,IAC/B;AACA,SAAK;AAAA,MACH,IAAI;AAAA,QACF,cAAc,iBAAiB,SAAS,iBAAiB;AAAA,QACzD,gBAAgB;AAAA,QAChB;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,iBAAiB;AAC/B,QAAI,KAAK,WAAW,eAAe,GAAG;AACpC,WAAK,cAAc,gBAAgB;AACnC,WAAK,KAAK,OAAO,gBAAgB,GAAG;AACpC,WAAK,KAAK,UAAU,KAAK,aAAa,KAAK,WAAW;AACtD,WAAK;AAAA,QACH,IAAI;AAAA,UACF,iBAAiB;AAAA,UACjB,gBAAgB;AAAA,UAChB;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,OAAO;AAAA,EAAC;AACnB;AAEA,IAAO,kBAAQ;;;AClPf,IAAM,WAAN,cAAuB,gBAAQ;AAAA;AAAA;AAAA;AAAA,EAI7B,YAAY,SAAS;AACnB,cAAU,UAAU,UAAU,CAAC;AAE/B,UAAM,YAAY,QAAQ,YAAY,QAAQ,YAAY;AAE1D,UAAM;AAAA,MACJ;AAAA,MACA,WAAW,QAAQ,aAAa;AAAA,MAChC,SAAS,QAAQ;AAAA,IACnB,CAAC;AAMD,SAAK,YAAY,QAAQ,aAAa,SAAY,QAAQ,WAAW;AAMrE,SAAK,OAAO,QAAQ,QAAQ,SAAY,QAAQ,MAAM;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,OAAO;AACd,UAAM,MAAM,KAAK,OAAO;AACxB,UAAM;AAAA;AAAA,MAAqD,IAAI,QAAQ;AAAA;AACvE,QAAI,WAAW,KAAK,YAAY;AAEhC,QAAI,KAAK,MAAM;AACb,YAAM,gBAAgB,KAAK,yBAAyB,QAAQ;AAC5D,YAAM,aAAa,KAAK,+BAA+B,aAAa;AACpE,YAAM,SAAS,KAAK,cAAc,IAAI;AACtC,iBAAW,SAAS,MAAM;AAC1B,eAAS,MAAM,SAAS,MAAM;AAAA,IAChC;AAEA,SAAK,YAAY,UAAU;AAAA,MACzB,UAAU,KAAK;AAAA,MACf,QAAQ;AAAA,IACV,CAAC;AAAA,EACH;AACF;AAEA,IAAO,mBAAQ;;;AC3Ef,IAAO,cAAQ;AAAA,EACb,MAAM;AAAA,EACN,IAAI;AAAA,EACJ,OAAO;AAAA,EACP,MAAM;AACR;;;ACqBA,IAAM,cAAN,cAA0B,oBAAY;AAAA;AAAA;AAAA;AAAA,EAIpC,YAAY,SAAS;AACnB,UAAM;AAEN,cAAU,WAAW,CAAC;AAOtB,SAAK,oBAAoB,SAAU,iBAAiB;AAClD,aACE,eAAe,eAAe,KAAK,kBAAkB,eAAe;AAAA,IAExE;AAMA,SAAK,aACH,QAAQ,cAAc,SAClB,QAAQ,YACR,KAAK;AAMX,SAAK,YAAY,QAAQ,aAAa,SAAY,QAAQ,WAAW;AAMrE,SAAK,cACH,QAAQ,eAAe,SAAY,QAAQ,aAAa;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAY,iBAAiB;AAC3B,QAAI,YAAY;AAChB,QAAI,gBAAgB,QAAQ,kBAAU,SAAS;AAC7C,YAAM;AAAA;AAAA,QACJ,gBAAgB;AAAA;AAElB,YAAM,MAAM,SAAS;AACrB,UACE,KAAK,WAAW,eAAe,MAC9B,OAAO,YAAI,QACV,OAAO,YAAI,QACX,OAAO,YAAI,SACX,OAAO,YAAI,KACb;AACA,cAAM,MAAM,gBAAgB;AAC5B,cAAM,OAAO,IAAI,QAAQ;AACzB,cAAM,gBAAgB,KAAK,cAAc,IAAI,KAAK;AAClD,YAAI,SAAS,GACX,SAAS;AACX,YAAI,OAAO,YAAI,MAAM;AACnB,mBAAS,CAAC;AAAA,QACZ,WAAW,OAAO,YAAI,MAAM;AAC1B,mBAAS,CAAC;AAAA,QACZ,WAAW,OAAO,YAAI,OAAO;AAC3B,mBAAS;AAAA,QACX,OAAO;AACL,mBAAS;AAAA,QACX;AACA,cAAM,QAAQ,CAAC,QAAQ,MAAM;AAC7B,eAAiB,OAAO,KAAK,YAAY,CAAC;AAC1C,YAAI,MAAM,OAAO,KAAK,SAAS;AAC/B,iBAAS,eAAe;AACxB,oBAAY;AAAA,MACd;AAAA,IACF;AACA,WAAO,CAAC;AAAA,EACV;AACF;AAEA,IAAO,sBAAQ;;;AC3Ff,IAAM,eAAN,cAA2B,oBAAY;AAAA;AAAA;AAAA;AAAA,EAIrC,YAAY,SAAS;AACnB,UAAM;AAEN,cAAU,UAAU,UAAU,CAAC;AAM/B,SAAK,aAAa,QAAQ,YACtB,QAAQ,YACR,SAAU,iBAAiB;AACzB,aACE,CAAC,oBAAoB,eAAe,KACpC,kBAAkB,eAAe;AAAA,IAErC;AAMJ,SAAK,SAAS,QAAQ,QAAQ,QAAQ,QAAQ;AAM9C,SAAK,YAAY,QAAQ,aAAa,SAAY,QAAQ,WAAW;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAY,iBAAiB;AAC3B,QAAI,YAAY;AAChB,QACE,gBAAgB,QAAQ,kBAAU,WAClC,gBAAgB,QAAQ,kBAAU,UAClC;AACA,YAAM;AAAA;AAAA,QACJ,gBAAgB;AAAA;AAElB,YAAM,MAAM,SAAS;AACrB,UAAI,KAAK,WAAW,eAAe,MAAM,QAAQ,OAAO,QAAQ,MAAM;AACpE,cAAM,MAAM,gBAAgB;AAC5B,cAAM,QAAQ,QAAQ,MAAM,KAAK,SAAS,CAAC,KAAK;AAChD,cAAM,OAAO,IAAI,QAAQ;AACzB,oBAAY,MAAM,OAAO,QAAW,KAAK,SAAS;AAClD,iBAAS,eAAe;AACxB,oBAAY;AAAA,MACd;AAAA,IACF;AACA,WAAO,CAAC;AAAA,EACV;AACF;AAEA,IAAO,uBAAQ;;;ACvFf,IAAM,UAAN,MAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOZ,YAAY,OAAO,aAAa,OAAO;AAKrC,SAAK,SAAS;AAMd,SAAK,eAAe;AAMpB,SAAK,SAAS;AAMd,SAAK,UAAU,CAAC;AAMhB,SAAK,SAAS;AAMd,SAAK,mBAAmB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ;AACN,SAAK,QAAQ,SAAS;AACtB,SAAK,SAAS;AACd,SAAK,mBAAmB;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,GAAG,GAAG;AACX,SAAK,QAAQ,KAAK,GAAG,GAAG,KAAK,IAAI,CAAC;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM;AACJ,QAAI,KAAK,QAAQ,SAAS,GAAG;AAG3B,aAAO;AAAA,IACT;AACA,UAAM,QAAQ,KAAK,IAAI,IAAI,KAAK;AAChC,UAAM,YAAY,KAAK,QAAQ,SAAS;AACxC,QAAI,KAAK,QAAQ,YAAY,CAAC,IAAI,OAAO;AAGvC,aAAO;AAAA,IACT;AAGA,QAAI,aAAa,YAAY;AAC7B,WAAO,aAAa,KAAK,KAAK,QAAQ,aAAa,CAAC,IAAI,OAAO;AAC7D,oBAAc;AAAA,IAChB;AAEA,UAAM,WAAW,KAAK,QAAQ,YAAY,CAAC,IAAI,KAAK,QAAQ,aAAa,CAAC;AAI1E,QAAI,WAAW,MAAO,IAAI;AACxB,aAAO;AAAA,IACT;AAEA,UAAM,KAAK,KAAK,QAAQ,SAAS,IAAI,KAAK,QAAQ,UAAU;AAC5D,UAAM,KAAK,KAAK,QAAQ,YAAY,CAAC,IAAI,KAAK,QAAQ,aAAa,CAAC;AACpE,SAAK,SAAS,KAAK,MAAM,IAAI,EAAE;AAC/B,SAAK,mBAAmB,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE,IAAI;AACvD,WAAO,KAAK,mBAAmB,KAAK;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACZ,YAAQ,KAAK,eAAe,KAAK,oBAAoB,KAAK;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW;AACT,WAAO,KAAK;AAAA,EACd;AACF;AAEA,IAAO,kBAAQ;;;ACxFf,IAAM,iBAAN,cAA6B,oBAAY;AAAA;AAAA;AAAA;AAAA,EAIvC,YAAY,SAAS;AACnB,cAAU,UAAU,UAAU,CAAC;AAE/B;AAAA;AAAA,MACgE;AAAA,IAChE;AAMA,SAAK,cAAc;AAMnB,SAAK,aAAa;AAMlB,SAAK,YAAY,QAAQ,aAAa,SAAY,QAAQ,WAAW;AAMrE,SAAK,YAAY,QAAQ,aAAa,SAAY,QAAQ,WAAW;AAMrE,SAAK,WAAW,QAAQ,YAAY,SAAY,QAAQ,UAAU;AAMlE,SAAK,aACH,QAAQ,cAAc,SAAY,QAAQ,YAAY;AAMxD,SAAK,uBACH,QAAQ,wBAAwB,SAC5B,QAAQ,sBACR;AAEN,UAAM,YAAY,QAAQ,YAAY,QAAQ,YAAY;AAM1D,SAAK,aAAa,QAAQ,cACtB,IAAI,mBAAmB,SAAS,IAChC;AAMJ,SAAK,cAAc;AAMnB,SAAK,aAAa;AAMlB,SAAK;AAML,SAAK,QAAQ;AAQb,SAAK,oBAAoB;AAMzB,SAAK;AAOL,SAAK,gBAAgB;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB;AAChB,SAAK,qBAAqB;AAC1B,UAAM,MAAM,KAAK,OAAO;AACxB,QAAI,CAAC,KAAK;AACR;AAAA,IACF;AACA,UAAM,OAAO,IAAI,QAAQ;AACzB,SAAK;AAAA,MACH;AAAA,MACA,KAAK,aAAc,KAAK,aAAa,IAAI,IAAI,KAAM;AAAA,MACnD,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,iBAAiB;AAC3B,QAAI,CAAC,KAAK,WAAW,eAAe,GAAG;AACrC,aAAO;AAAA,IACT;AACA,UAAM,OAAO,gBAAgB;AAC7B,QAAI,SAAS,kBAAU,OAAO;AAC5B,aAAO;AAAA,IACT;AAEA,UAAM,MAAM,gBAAgB;AAC5B,UAAM;AAAA;AAAA,MACJ,gBAAgB;AAAA;AAElB,eAAW,eAAe;AAE1B,QAAI,KAAK,YAAY;AACnB,WAAK,cAAc,gBAAgB;AAAA,IACrC;AAIA,QAAI;AACJ,QAAI,gBAAgB,QAAQ,kBAAU,OAAO;AAC3C,cAAQ,WAAW;AACnB,UAAI,WAAW,WAAW,cAAc,WAAW,iBAAiB;AAClE,iBAAS;AAAA,MACX;AACA,UAAI,WAAW,cAAc,WAAW,gBAAgB;AACtD,iBAAS;AAAA,MACX;AAAA,IACF;AAEA,QAAI,UAAU,GAAG;AACf,aAAO;AAAA,IACT;AACA,SAAK,aAAa;AAElB,UAAM,MAAM,KAAK,IAAI;AAErB,QAAI,KAAK,eAAe,QAAW;AACjC,WAAK,aAAa;AAAA,IACpB;AAEA,QAAI,CAAC,KAAK,SAAS,MAAM,KAAK,aAAa,KAAK,mBAAmB;AACjE,WAAK,QAAQ,KAAK,IAAI,KAAK,IAAI,IAAI,aAAa;AAAA,IAClD;AAEA,UAAM,OAAO,IAAI,QAAQ;AACzB,QACE,KAAK,UAAU,cACf,EAAE,KAAK,uBAAuB,KAAK,KAAK,uBACxC;AACA,UAAI,KAAK,oBAAoB;AAC3B,qBAAa,KAAK,kBAAkB;AAAA,MACtC,OAAO;AACL,YAAI,KAAK,aAAa,GAAG;AACvB,eAAK,iBAAiB;AAAA,QACxB;AACA,aAAK,iBAAiB;AAAA,MACxB;AACA,WAAK,qBAAqB;AAAA,QACxB,KAAK,gBAAgB,KAAK,IAAI;AAAA,QAC9B,KAAK;AAAA,MACP;AACA,WAAK,WAAW,CAAC,QAAQ,KAAK,eAAe,KAAK,WAAW;AAC7D,WAAK,aAAa;AAClB,aAAO;AAAA,IACT;AAEA,SAAK,eAAe;AAEpB,UAAM,WAAW,KAAK,IAAI,KAAK,YAAY,MAAM,KAAK,aAAa,CAAC;AAEpE,iBAAa,KAAK,UAAU;AAC5B,SAAK,aAAa;AAAA,MAChB,KAAK,iBAAiB,KAAK,MAAM,GAAG;AAAA,MACpC;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,iBAAiB,KAAK;AACpB,UAAM,OAAO,IAAI,QAAQ;AACzB,QAAI,KAAK,aAAa,GAAG;AACvB,WAAK,iBAAiB;AAAA,IACxB;AACA,QAAI,QACF,CAAC;AAAA,MACC,KAAK;AAAA,MACL,CAAC,KAAK,YAAY,KAAK;AAAA,MACvB,KAAK,YAAY,KAAK;AAAA,IACxB,IAAI,KAAK;AACX,QAAI,KAAK,uBAAuB,KAAK,KAAK,sBAAsB;AAE9D,cAAQ,QAAS,QAAQ,IAAI,IAAI,KAAM;AAAA,IACzC;AACA,gBAAY,MAAM,OAAO,KAAK,aAAa,KAAK,SAAS;AAEzD,SAAK,QAAQ;AACb,SAAK,cAAc;AACnB,SAAK,cAAc;AACnB,SAAK,aAAa;AAClB,SAAK,aAAa;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,eAAe,WAAW;AACxB,SAAK,aAAa;AAClB,QAAI,CAAC,WAAW;AACd,WAAK,cAAc;AAAA,IACrB;AAAA,EACF;AACF;AAEA,IAAO,yBAAQ;;;ACnRf,IAAM,cAAN,cAA0B,gBAAmB;AAAA;AAAA;AAAA;AAAA,EAI3C,YAAY,SAAS;AACnB,cAAU,UAAU,UAAU,CAAC;AAE/B,UAAM;AAAA;AAAA,MACJ;AAAA;AAGF,QAAI,CAAC,eAAe,UAAU;AAC5B,qBAAe,WAAW;AAAA,IAC5B;AAEA,UAAM,cAAc;AAMpB,SAAK,UAAU;AAMf,SAAK,aAAa;AAMlB,SAAK,YAAY;AAMjB,SAAK,iBAAiB;AAMtB,SAAK,aAAa,QAAQ,cAAc,SAAY,QAAQ,YAAY;AAMxE,SAAK,YAAY,QAAQ,aAAa,SAAY,QAAQ,WAAW;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,iBAAiB;AAC/B,QAAI,gBAAgB;AAEpB,UAAM,SAAS,KAAK,eAAe,CAAC;AACpC,UAAM,SAAS,KAAK,eAAe,CAAC;AAGpC,UAAM,QAAQ,KAAK;AAAA,MACjB,OAAO,UAAU,OAAO;AAAA,MACxB,OAAO,UAAU,OAAO;AAAA,IAC1B;AAEA,QAAI,KAAK,eAAe,QAAW;AACjC,YAAM,QAAQ,QAAQ,KAAK;AAC3B,WAAK,kBAAkB;AACvB,UAAI,CAAC,KAAK,aAAa,KAAK,IAAI,KAAK,cAAc,IAAI,KAAK,YAAY;AACtE,aAAK,YAAY;AAAA,MACnB;AACA,sBAAgB;AAAA,IAClB;AACA,SAAK,aAAa;AAElB,UAAM,MAAM,gBAAgB;AAC5B,UAAM,OAAO,IAAI,QAAQ;AACzB,QAAI,KAAK,eAAe,EAAE,aAAa,SAAS;AAC9C;AAAA,IACF;AAKA,SAAK,UAAU,IAAI;AAAA,MACjB,IAAI,cAAc,SAAqB,KAAK,cAAc,CAAC;AAAA,IAC7D;AAGA,QAAI,KAAK,WAAW;AAClB,UAAI,OAAO;AACX,WAAK,uBAAuB,eAAe,KAAK,OAAO;AAAA,IACzD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,iBAAiB;AAC7B,QAAI,KAAK,eAAe,SAAS,GAAG;AAClC,YAAM,MAAM,gBAAgB;AAC5B,YAAM,OAAO,IAAI,QAAQ;AACzB,WAAK,eAAe,KAAK,SAAS;AAClC,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,iBAAiB;AAC/B,QAAI,KAAK,eAAe,UAAU,GAAG;AACnC,YAAM,MAAM,gBAAgB;AAC5B,WAAK,UAAU;AACf,WAAK,aAAa;AAClB,WAAK,YAAY;AACjB,WAAK,iBAAiB;AACtB,UAAI,CAAC,KAAK,wBAAwB;AAChC,YAAI,QAAQ,EAAE,iBAAiB;AAAA,MACjC;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACF;AAEA,IAAO,sBAAQ;;;AC3If,IAAM,YAAN,cAAwB,gBAAmB;AAAA;AAAA;AAAA;AAAA,EAIzC,YAAY,SAAS;AACnB,cAAU,UAAU,UAAU,CAAC;AAE/B,UAAM;AAAA;AAAA,MACJ;AAAA;AAGF,QAAI,CAAC,eAAe,UAAU;AAC5B,qBAAe,WAAW;AAAA,IAC5B;AAEA,UAAM,cAAc;AAMpB,SAAK,UAAU;AAMf,SAAK,YAAY,QAAQ,aAAa,SAAY,QAAQ,WAAW;AAMrE,SAAK,gBAAgB;AAMrB,SAAK,kBAAkB;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,iBAAiB;AAC/B,QAAI,aAAa;AAEjB,UAAM,SAAS,KAAK,eAAe,CAAC;AACpC,UAAM,SAAS,KAAK,eAAe,CAAC;AACpC,UAAM,KAAK,OAAO,UAAU,OAAO;AACnC,UAAM,KAAK,OAAO,UAAU,OAAO;AAGnC,UAAMC,YAAW,KAAK,KAAK,KAAK,KAAK,KAAK,EAAE;AAE5C,QAAI,KAAK,kBAAkB,QAAW;AACpC,mBAAa,KAAK,gBAAgBA;AAAA,IACpC;AACA,SAAK,gBAAgBA;AAErB,UAAM,MAAM,gBAAgB;AAC5B,UAAM,OAAO,IAAI,QAAQ;AAEzB,QAAI,cAAc,GAAK;AACrB,WAAK,kBAAkB;AAAA,IACzB;AAGA,SAAK,UAAU,IAAI;AAAA,MACjB,IAAI,cAAc,SAAqB,KAAK,cAAc,CAAC;AAAA,IAC7D;AAGA,QAAI,OAAO;AACX,SAAK,yBAAyB,YAAY,KAAK,OAAO;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAc,iBAAiB;AAC7B,QAAI,KAAK,eAAe,SAAS,GAAG;AAClC,YAAM,MAAM,gBAAgB;AAC5B,YAAM,OAAO,IAAI,QAAQ;AACzB,YAAM,YAAY,KAAK,kBAAkB,IAAI,IAAI;AACjD,WAAK,eAAe,KAAK,WAAW,SAAS;AAC7C,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,iBAAiB;AAC/B,QAAI,KAAK,eAAe,UAAU,GAAG;AACnC,YAAM,MAAM,gBAAgB;AAC5B,WAAK,UAAU;AACf,WAAK,gBAAgB;AACrB,WAAK,kBAAkB;AACvB,UAAI,CAAC,KAAK,wBAAwB;AAChC,YAAI,QAAQ,EAAE,iBAAiB;AAAA,MACjC;AACA,aAAO;AAAA,IACT;AACA,WAAO;AAAA,EACT;AACF;AAEA,IAAO,oBAAQ;;;ACxER,SAAS,SAAS,SAAS;AAChC,YAAU,UAAU,UAAU,CAAC;AAG/B,QAAM,eAAe,IAAI,mBAAW;AAEpC,QAAM,UAAU,IAAI,gBAAQ,OAAQ,MAAM,GAAG;AAE7C,QAAM,qBACJ,QAAQ,uBAAuB,SAC3B,QAAQ,qBACR;AACN,MAAI,oBAAoB;AACtB,iBAAa,KAAK,IAAI,mBAAW,CAAC;AAAA,EACpC;AAEA,QAAM,kBACJ,QAAQ,oBAAoB,SAAY,QAAQ,kBAAkB;AACpE,MAAI,iBAAiB;AACnB,iBAAa;AAAA,MACX,IAAI,wBAAgB;AAAA,QAClB,OAAO,QAAQ;AAAA,QACf,UAAU,QAAQ;AAAA,MACpB,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,UAAU,QAAQ,YAAY,SAAY,QAAQ,UAAU;AAClE,MAAI,SAAS;AACX,iBAAa;AAAA,MACX,IAAI,gBAAQ;AAAA,QACV,aAAa,QAAQ;AAAA,QACrB;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,cACJ,QAAQ,gBAAgB,SAAY,QAAQ,cAAc;AAC5D,MAAI,aAAa;AACf,iBAAa,KAAK,IAAI,oBAAY,CAAC;AAAA,EACrC;AAEA,QAAM,YAAY,QAAQ,cAAc,SAAY,QAAQ,YAAY;AACxE,MAAI,WAAW;AACb,iBAAa;AAAA,MACX,IAAI,kBAAU;AAAA,QACZ,UAAU,QAAQ;AAAA,MACpB,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,WAAW,QAAQ,aAAa,SAAY,QAAQ,WAAW;AACrE,MAAI,UAAU;AACZ,iBAAa,KAAK,IAAI,oBAAY,CAAC;AACnC,iBAAa;AAAA,MACX,IAAI,qBAAa;AAAA,QACf,OAAO,QAAQ;AAAA,QACf,UAAU,QAAQ;AAAA,MACpB,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,iBACJ,QAAQ,mBAAmB,SAAY,QAAQ,iBAAiB;AAClE,MAAI,gBAAgB;AAClB,iBAAa;AAAA,MACX,IAAI,uBAAe;AAAA,QACjB,aAAa,QAAQ;AAAA,QACrB,UAAU,QAAQ;AAAA,MACpB,CAAC;AAAA,IACH;AAAA,EACF;AAEA,QAAM,gBACJ,QAAQ,kBAAkB,SAAY,QAAQ,gBAAgB;AAChE,MAAI,eAAe;AACjB,iBAAa;AAAA,MACX,IAAI,iBAAS;AAAA,QACX,UAAU,QAAQ;AAAA,MACpB,CAAC;AAAA,IACH;AAAA,EACF;AAEA,SAAO;AACT;",
  "names": ["extend", "coordinates", "offset", "extend", "intersects", "equals", "scale", "squaredDistance", "wrapX", "centroid", "map", "distance", "offset", "transform", "rotate", "scale", "transform", "RADIUS", "EXTENT", "METERS_PER_UNIT", "PROJECTIONS", "add", "add", "get", "transform", "distance", "disable", "add", "get", "toEPSG4326", "get", "add", "get", "equals", "get", "transform", "PROJECTIONS", "offset", "transform", "rotate", "scale", "translate", "transform", "clone", "extent", "get", "scale", "coordinates", "rotate", "scale", "translate", "transform", "offset", "squaredDistance", "offset", "coordinates", "offset", "squaredDistance", "offset", "offset", "coordinates", "offset", "coordinates", "coordinates", "squaredDistance", "offset", "offset", "offset", "offset", "offset", "offset", "coordinates", "linearRing", "linearRings", "offset", "angle", "coordinates", "distance"]
}
